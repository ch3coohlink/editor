{"id":"3944ca39e0217735f454abf7c1c2819c92a6a0543b61e25c25ad7284724ea83b","to":[],"value":"Object.assign($, await require('../util/common.js'))\r\nconst compsys = await require('../util/component.js')\r\nconst grd = await require('../util/random.js')\r\nconsole.clear()\r\n\r\nlet framecount = 0\r\nconst loop = () => {\r\n  if ($.frame) { framecount++; frame() }\r\n  requestAnimationFrame(loop)\r\n}; requestAnimationFrame(loop)\r\n\r\n$.cvs = await createcanvas()\r\n$.ctx = cvs.getContext('2d', { willReadFrequently: true })\r\n$.component = compsys.createcomponentsystem({ cvs, ctx })\r\nObject.defineProperty(component.globalenv, 'framecount', { get: () => framecount })\r\n\r\ncomponent.define('graph', {\r\n  direction: 'horizontal', subgraph: [],\r\n  node: [], edge: [], vnode: [], vedge: [],\r\n}, df => (\r\n  df('add', (m, d, n = component.create('graph-node',\r\n    nm => (nm.parent = m, nm.data = d, nm.ranksum = 0, nm.rankcount = 0))) =>\r\n    (m.graphmoded = true, m.node.push(n), n)),\r\n  df('link', (m, a, b, d, e = component.create('graph-edge',\r\n    em => (em.parent = m, em.from = a, em.to = b, em.data = d))) =>\r\n    (m.graphmoded = true, a.to.push(e), b.from.push(e), m.edge.push(e), e))),\r\n  m => {\r\n    const h = m.direction === 'horizontal'; let r\r\n    m._horizontal = h\r\n    const base = m._size[h ? 0 : 1] * 0.9\r\n    let nonbase = 0\r\n    const distance = 100\r\n    const nbdis = 10\r\n    if (m.rankchanged) {\r\n      const nvs = [], evs = []; let gi = 0\r\n      for (const g of m.subgraph) {\r\n        const gvs = g.map(comp => ({ type: 'component', comp }))\r\n        for (let i = 0, l = g.length; i < l; i++) {\r\n          const n = g[i], [x, y] = n.layer\r\n          const b = base * x / Math.max(g.layer.length - 1, 1)\r\n          const nb = nonbase + (g.layer[x] / 2 - y) * nbdis\r\n          const p = h ? [b, nb] : [nb, b]\r\n          n.position = gvs[i].position = p\r\n          for (const e of n.to) {\r\n            if (e.virtualpoint) {\r\n              for (const vp of e.virtualpoint) {\r\n                const [x, y] = vp.layer\r\n                const b = base * x / Math.max(g.layer.length - 1, 1)\r\n                const nb = nonbase + (g.layer[x] / 2 - y) * nbdis\r\n                const p = h ? [b, nb] : [nb, b]\r\n                vp.position = p\r\n              }\r\n            } evs.push({ type: 'component', comp: e })\r\n            component.markdirty(e)\r\n          }\r\n        } nvs.push(...gvs); nonbase += distance; gi++\r\n      } nonbase = (m.subgraph.length - 1) * distance\r\n\r\n      m.rankchanged = m.graphmoded = false\r\n      r = { type: 'component', comp: { _view: [...evs, ...nvs] } }\r\n    } else { r = m._view ?? [] } r.position = h\r\n      ? [(m._size[0] - base) / 2, (m._size[1] - nonbase) / 2]\r\n      : [(m._size[0] - nonbase) / 2, (m._size[1] - base) / 2]\r\n    return r\r\n  })\r\nconst splitgraph = m => {\r\n  m.subgraph = []; let seen = new Set, sub = 0\r\n  for (let i = 0, l = m.node.length; i < l; i++) {\r\n    let n = m.node[i]; if (seen.has(n)) { continue }\r\n    const s = m.subgraph[sub++] = [], q = [n]\r\n    while (n = q.shift()) {\r\n      if (seen.has(n)) { continue } s.push(n), seen.add(n)\r\n      q.push(...n.to.map(e => e.to), ...n.from.map(e => e.from))\r\n    }\r\n  } m.subgraph = [m.subgraph[0]]\r\n}\r\nconst rankrd = grd.genrd(2462462542)\r\nconst rankgraph = (m, l = 10) => {\r\n  const { rdi } = rankrd, { round, abs } = Math\r\n  for (const g of m.subgraph) {\r\n    if (g.converged) { continue }\r\n    if (g.length <= 1) {\r\n      g[0].layer = [0, 0];\r\n      g.layer = [1];\r\n      g.converged = true;\r\n      continue\r\n    }\r\n    const st = now()\r\n\r\n    for (let i = 0; i < l; i++) {\r\n      const q = [[g[rdi(g.length)], 0]], seen = new Set\r\n      while (q.length > 0) {\r\n        const [n, d] = q.splice(rdi(q.length), 1)[0]\r\n        if (seen.has(n)) { continue } seen.add(n)\r\n        n.ranksum += d, q.push(\r\n          ...n.to.map(e => [e.to, d - 1]),\r\n          ...n.from.map(e => [e.from, d + 1]))\r\n      }\r\n    }\r\n\r\n    const roundrange = 0.05, roundrev = 1 / roundrange\r\n    let d = 0; for (const n of g) {\r\n      n.rankcount ??= 0, n.rankcount += l\r\n      n.oldrank = n.rank ??= 0\r\n      // n.rank = round(n.ranksum / n.rankcount * roundrev) * roundrange\r\n      n.rank = n.ranksum / n.rankcount * roundrev\r\n      d += abs(n.rank - n.oldrank)\r\n    } if (d < 0.001 * g.length) { g.converged = true }\r\n    g.converged = true\r\n\r\n    const gs = [...g].sort((a, b) => b.rank - a.rank)\r\n    let layer = [[]], current = gs[0].rank, ci = 0\r\n    for (const n of gs) {\r\n      if (n.rank !== current) { layer.push([]); ci++; current = n.rank }\r\n      const l = layer[ci]; n.layer = [ci, l.length], l.push(n)\r\n    }\r\n    // for (const n of gs) {\r\n    //   const [x, y] = n.layer\r\n    //   for (const { from } of n.from) if (from.layer[0] === x) {\r\n    //     layer[x].splice(y, 1); const l = layer[x + 1] ??= []\r\n    //     n.layer = [x + 1, l.length]; l.push(n); break\r\n    //   }\r\n    // }\r\n\r\n    let n, seen = new Set; while (n = gs.shift()) {\r\n      if (seen.has(n)) { continue } seen.add(n)\r\n      for (const e of n.to) {\r\n        const to = e.to\r\n        const d = abs(to.layer[0] - n.layer[0])\r\n        e.direction = n.layer[0] <= to.layer[0]\r\n        const s = e.direction ? n.layer[0] : to.layer[0]\r\n        if (d > 1) {\r\n          e.virtualpoint = []; let pre\r\n          for (let i = 1; i < d; i++) {\r\n            const j = s + i\r\n            const from = [{ from: i !== 1 ? pre : e.direction ? n : to }]\r\n            const p = { layer: [j, layer[j].length], from }\r\n            e.virtualpoint.push(p)\r\n            layer[j].push(p)\r\n            pre = p\r\n          }\r\n          const rvp = e.virtualpoint.toReversed()\r\n          rvp[0].to = [{ to: e.direction ? to : n }]\r\n          pre = rvp[0]\r\n          for (const vp of rvp.slice(1)) {\r\n            vp.to = [{ to: pre }]; pre = vp\r\n          }\r\n        } else { delete e.virtualpoint }\r\n      }\r\n    }\r\n\r\n    { // minimize cross\r\n      let templayer = [...layer.map(a => [...a])]\r\n      for (const l of layer) for (const n of l) { n.templayer = [...n.layer] }\r\n      for (let i = 0; i < 10; i++) {\r\n        for (const l of templayer.slice(1)) {\r\n          l.forEach(n => n.fromsum = n.from.reduce(\r\n            (p, e) => p + (e.virtualpoint ? e.virtualpoint[e.virtualpoint.length - 1] : e.from).templayer[1], 0)\r\n            / n.from.length)\r\n          l.sort((a, b) => a.fromsum - b.fromsum)\r\n          l.forEach((n, i) => n.templayer[1] = i)\r\n        }\r\n        for (const l of templayer.toReversed().slice(1)) {\r\n          l.forEach(n => n.tosum = n.to.reduce(\r\n            (p, e) => p + (e.virtualpoint ? e.virtualpoint[0] : e.to).templayer[1], 0)\r\n            / n.to.length)\r\n          l.sort((a, b) => a.tosum - b.tosum)\r\n          l.forEach((n, i) => n.templayer[1] = i)\r\n        }\r\n        // for (const l of templayer.slice(1)) {\r\n        //   l.forEach(n => n.fromsum = n.from.reduce(\r\n        //     (p, e) => p + (e.virtualpoint ? e.virtualpoint[e.virtualpoint.length - 1] : e.from).templayer[1], 0)\r\n        //     / n.from.length)\r\n        //   l.sort((a, b) => a.fromsum - b.fromsum)\r\n        //   l.forEach((n, i) => n.templayer[1] = i)\r\n        // }\r\n\r\n        let crossa = 0, crossb = 0, pre, ci\r\n        pre = layer[0], ci = 0\r\n        for (const l of layer.slice(1)) {\r\n          let cross = 0\r\n          for (const n of layer[ci]) {\r\n            for (const e of n.to) {\r\n              const to = e.virtualpoint ? e.virtualpoint[0] : e.to\r\n\r\n            }\r\n          }\r\n          crossa += cross; ci++\r\n        }\r\n        pre = templayer[0]\r\n        for (const l of templayer.slice(1)) {\r\n        }\r\n        if (true) {\r\n          layer = [...templayer.map(a => [...a])]\r\n          for (const l of layer) for (const n of l) { n.layer = [...n.templayer] }\r\n        } else {\r\n          templayer = [...layer.map(a => [...a])]\r\n          for (const l of layer) for (const n of l) { n.templayer = [...n.layer] }\r\n        }\r\n      }\r\n    }\r\n\r\n    g.layer = layer.map(l => l.length + (l.length % 2 === 0 ? 1 : 0))\r\n\r\n    const et = now()\r\n    // log(et - st)\r\n  } rankrd.next(), m.rankchanged = true\r\n\r\n}\r\nconst layoutgraph = m => {\r\n  if (m.graphmoded) { splitgraph(m) }\r\n  rankgraph(m, 100)\r\n  component.markdirty(m)\r\n}\r\n\r\nconst size = 3\r\ncomponent.define('graph-node', { from: [], to: [], _size: [size, size] }, df => (\r\n  df('link', (m, t, e) => parent.link(m, t, e), false)\r\n), m => ({ type: 'rect', args: [-m._size[0] / 2, -m._size[1] / 2, ...m._size] }))\r\ncomponent.define('graph-edge', _, _, m => {\r\n  const a = m.from.position, b = m.to.position\r\n  const vp = (m.virtualpoint ?? []).map(vp => ['L', ...vp.position])\r\n  if (!m.direction) { vp.reverse() }\r\n  const args = [['M', ...a], ...vp, ['L', ...b]]\r\n  const r = { type: 'path', args }\r\n  if (!m.direction) { r.color = 'red' }\r\n  return r\r\n})\r\n\r\nconst g = component.create('graph')\r\ncomponent.root = g\r\n\r\n// const rgrd = grd.genrd(4123946342)\r\n// const rgrd = grd.genrd(3703646480)\r\nconst rgrd = grd.genrd(); log(rgrd.seed)\r\nconst randomgraph = (g, l = rgrd.rdi(50, 1000), ns = []) => {\r\n  for (let i = 0; i < l; i++) { ns.push(g.add()) }\r\n  for (let i = 0; i < l; i++) {\r\n    const r = rgrd.rd() > 0.9 ? 2 : 1\r\n    // const r = 2\r\n    const a = ns[i], s = [...ns]\r\n    for (let j = 0; j < r && s.length > 0; j++) {\r\n      g.link(a, s.splice(rgrd.rdi(s.length), 1)[0])\r\n    }\r\n  } rgrd.next()\r\n}\r\nrandomgraph(g)\r\nlog(g.node.length)\r\n// randomgraph(g)\r\n\r\n$.frame = () => {\r\n  layoutgraph(g)\r\n  component.frame()\r\n}"}