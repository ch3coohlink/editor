{"id":"674c56e171c5d3f9b7ec6aaadeaff886cdbba104c1b99534d34f1d04a494cd39","to":[],"value":"const _ = undefined\r\nconst now = () => performance.now() / 1000\r\nconst { log, clear } = originconsole\r\n$.log = log\r\nconst rd = await require('../util/random.js')\r\nclear()\r\n\r\nconst local = n => globalThis.location.origin + '/' + n\r\nimportScripts(local('external/opentype.js'))\r\n\r\nconst cvs = await requestcanvas()\r\nconst ctx = cvs.getContext('2d', { willReadFrequently: true })\r\nlet devicePixelRatio = await requestdpi()\r\nlet needresize = true\r\non('canvasresize', () => needresize = true)\r\non('canvasresize', ({ w, h, dpi }) => w !== 0 && h !== 0\r\n  ? (cvs.width = w, cvs.height = h, devicePixelRatio = dpi) : 0)\r\n\r\nlet framecount = 0\r\nconst loop = () => {\r\n  if ($.frame) { framecount++; frame() }\r\n  requestAnimationFrame(loop)\r\n}; requestAnimationFrame(loop)\r\n\r\nconst fonts = {}\r\nconst loadfont = async (n, p) => {\r\n  let font = await fetch(local(p))\r\n  if (font.status !== 200) { throw Error(`Fail to load font file: ${n} at path: ${p}`) }\r\n  font = opentype.parse(await font.arrayBuffer())\r\n  font.defaultglyph = font.glyphs.glyphs[0], fonts[n] = font\r\n  font.scalefactordiv1 = font.tables.os2.sTypoAscender / 1000\r\n  font.scalefactor = 1 / font.scalefactordiv1\r\n}\r\n\r\nawait Promise.all([\r\n  loadfont('consolas', 'assets/font/consolas.ttf'),\r\n  // loadfont('思源黑体', 'assets/font/SourceHanSansHWSC-Regular.otf'),\r\n])\r\n\r\nconst _segmenter = new Intl.Segmenter(\"en\", { granularity: 'grapheme' })\r\nconst splitunicode = t => Array.from(_segmenter.segment(t), ({ segment }) => segment)\r\nconst drawglyph = g => {\r\n  ctx.beginPath()\r\n  for (const c of g.path.commands) {\r\n    switch (c.type) {\r\n      case 'M': ctx.moveTo(c.x, c.y); break\r\n      case 'L': ctx.lineTo(c.x, c.y); break\r\n      case 'Q': ctx.quadraticCurveTo(c.x1, c.y1, c.x, c.y); break\r\n      case 'C': ctx.bezierCurveTo(c.x1, c.y1, c.x2, c.y2, c.x, c.y); break\r\n      case 'Z': break\r\n      default: log(c); throw Error(`unknown path command type: ${c.type}`)\r\n    }\r\n  }\r\n  ctx.fill()\r\n}\r\nconst defaultglyph = fonts['consolas'].defaultglyph\r\nconst usingfonts = ['consolas', '思源黑体'].map(n => fonts[n]).filter(v => v)\r\nconst drawtext = (t, x, y, px = 10) => {\r\n  const a = splitunicode(t), s = px / 1000\r\n  ctx.save(); ctx.transform(s, 0, 0, -s, x, y)\r\n  for (const t of a) {\r\n    const c = t.charCodeAt(0); let usefont, g\r\n    for (const f of usingfonts) {\r\n      const i = f.tables.cmap.glyphIndexMap[c]\r\n      g = f.glyphs.glyphs[i]; if (g) { usefont = f; break }\r\n    } if (!g) { g = defaultglyph, usefont = fonts['consolas'] }\r\n    ctx.scale(usefont.scalefactor, usefont.scalefactor)\r\n    drawglyph(g); ctx.translate(g.advanceWidth, 0)\r\n    ctx.scale(usefont.scalefactordiv1, usefont.scalefactordiv1)\r\n  } ctx.restore()\r\n}\r\n\r\nconst clearclosure = f => {\r\n  const src = f.toString()\r\n  const i = src.indexOf('=>')\r\n  if (i < 0) { throw Error() }\r\n  let h = src.slice(0, i).trim()\r\n  if (h.startsWith('async')) {\r\n    h = h.slice(5).trimStart()\r\n  } if (h.startsWith('(') && h.endsWith(')')) {\r\n    h = h.slice(1, -1)\r\n  } h = h.split(',')\r\n  return new f.constructor(...h, src.slice(i + 2))\r\n}\r\n\r\nconst deepclone = structuredClone\r\nconst deepequal = (a, b) => {\r\n  if (a === b) { return true } else if (\r\n    typeof a === \"object\" && a !== null && typeof b === \"object\" && b !== null) {\r\n    const ka = Object.keys(a)\r\n    if (ka.length !== Object.keys(b).length) { return false }\r\n    for (const k of ka) {\r\n      if (b.hasOwnProperty(k)) { if (!deepequal(a[k], b[k])) { return false } }\r\n      else { return false }\r\n    } return true\r\n  } else { return false }\r\n}\r\n\r\nconst id2color = i =>\r\n  '#' + [...new Uint8Array((new Uint32Array([i])).buffer)\r\n  ].slice(0, 3).map(v => v.toString(16).padStart(2, '0')).join('')\r\n\r\n// ----------------------------------------------------------\r\n$.mousepos = [0, 0], $.mouseevent = false\r\non('pointerrawupdate', async e => {\r\n  const b = await cvs.getBoundingClientRect()\r\n  mousepos[0] = (e.pageX - b.left) * devicePixelRatio\r\n  mousepos[1] = (e.pageY - b.top) * devicePixelRatio\r\n  e.mousepos = mousepos\r\n  mouseevent = e\r\n})\r\n$.dragprocess = (move, cancel) => {\r\n  let mi = on('pointermove', e => move((e.mousepos = mousepos, e)))\r\n  let ui = on('pointerup', e => (off('pointermove', mi),\r\n    off('pointerup', ui), cancel?.((e.mousepos = mousepos, e))))\r\n}\r\n$.getbbox = v => {\r\n  // TODO: rotate and scale not considered\r\n  const left = v.transform.e\r\n  const top = v.transform.f\r\n  const [width, height] = v.size\r\n  const right = left + width\r\n  const bottom = top + height\r\n  return { left, top, right, bottom, width, height }\r\n}\r\nconst globalenv = $\r\n$.component = (($ = {}) => {\r\n  with ($) {\r\n    $.definition = {}\r\n    $.dirty = new Set\r\n    $.dirtyarray = []\r\n    $.markdirty = m => {\r\n      if (dirty.has(m)) { return }\r\n      dirty.add(m); dirtyarray.push(m)\r\n    }\r\n    const cdae = n => Error(`component definition \"${n}\" already exists.`)\r\n    const cdne = n => Error(`component definition \"${n}\" not exists.`)\r\n    const vfne = n => Error(`view function not exist when defining component \"${n}\".`)\r\n    $.define = (n, m, v, tf, d) => {\r\n      if (definition[n]) { throw adae(n) }\r\n      if (typeof v !== 'function') { throw vfne(n) }\r\n      if (typeof m === 'function') { m = m() }\r\n      if (m.recordhistory) { m.history = [] }\r\n      m.type = n, m._iscomp = true\r\n      let t = {}; if (typeof tf === 'function')\r\n        tf((n, f, history = true) => t[n] = new Function('$',\r\n          `with($) {\\nconst __f__ = ${f.toString()}\r\nreturn function (...a) {\\nconst m = this, r = __f__(m, ...a)\r\n// TODO: a should be serialized since it could contain something like component\r\nif(${history} && m.recordhistory) { m.history.push([${n}, a]) }\r\nif(!m._iswatch) { component.markdirty(m) }\r\nreturn r\\n}\\n}`)(globalenv)); definition[n] = { m, v, t, d }\r\n      return (...a) => create(n, ...a)\r\n    }\r\n    $.definewatch = (n, m, v, tf, d) => {\r\n      const _tf = df => df('watch', (w, m) => ((m.watchers ??= new Set).add(w), w))\r\n      if (!tf) { tf = _tf } else { tf = df => { tf(df); _tf(df) } }\r\n      m._iswatch = true; define(n, m, v, tf, d)\r\n      return (...a) => create(n, ...a)\r\n    }\r\n    $.create = (n, f) => {\r\n      if (!definition[n]) { throw cdne(n) }\r\n      const d = definition[n], m = deepclone(d.m)\r\n      Object.setPrototypeOf(m, d.t) // TODO: not sure whether this is slow or not\r\n      if (typeof f === 'function') { f(m) }\r\n      return m\r\n    }\r\n    $.clone = (m, mixin) => {\r\n\r\n    }\r\n    const watchtype = new Map\r\n    $.watch = (m, f) => {\r\n      let fs = f.toString(), n\r\n      if (n = watchtype.get(fs)) { return create(n).watch(m) }\r\n      watchtype.set(fs, n = 'watch-' + rd.uuid(16))\r\n      return definewatch(n, {}, f)().watch(m)\r\n    }\r\n    $.on = (m, en, f) => {\r\n      m.event ??= { id: 0 }\r\n      const id = m.event.id++\r\n      m.event[en] ??= new Map\r\n      let fs = f.toString(), n, o\r\n      if (n = watchtype.get(fs)) { o = create(n) } else {\r\n        watchtype.set(fs, n = 'event-' + rd.uuid(16))\r\n        o = define(n, {}, f)()\r\n      } m.event[en].set(id, o)\r\n      return id\r\n    }\r\n    $.emit = (m, en, ...a) =>\r\n      m.event[en].forEach(({ type }) => definition[type].v(m, ...a))\r\n    let updated = false\r\n    $.update = () => {\r\n      updated = dirtyarray.length > 0\r\n      let c; while (c = dirtyarray.shift()) {\r\n        if (!dirty.has(c)) { continue }\r\n        const d = definition[c.type]\r\n        if (!d) { throw cdne(c.type) }\r\n        c._view = d.v(c)\r\n        if (c.watchers) for (const w of c.watchers) {\r\n          const d = definition[w.type]\r\n          if (!d) { throw cdne(w.type) } d.v(w, c)\r\n        } dirty.delete(c)\r\n      } if (updated) {\r\n        oldobjarr = objarray; objarray = []\r\n        if (!component.root) { return }\r\n        ctx.resetTransform()\r\n        collectobj(component.root._view)\r\n      }\r\n    }\r\n    $.objarray = [], $.oldobjarr = []\r\n    $.mouseid = 0, $.mousecomp = _\r\n    cvs.on('pointerdown', () => {\r\n      if (!mousecomp) { return }\r\n      emit(mousecomp, 'pointerdown', mouseevent)\r\n    })\r\n    const collectobj = c => {\r\n      if (Array.isArray(c)) { c.forEach(collectobj) }\r\n      else switch (c.type) {\r\n        case 'rect': case 'text':\r\n          objarray.push([ctx.getTransform(), c]); break\r\n        case 'component': {\r\n          ctx.save(); ctx.translate(...c.position)\r\n          const v = c.comp._view ??= definition[c.comp.type].v(c.comp)\r\n          if (!v) { throw Error(`component \"${c.comp.type}\" has no view output.`) }\r\n          c.transform = ctx.getTransform(); c.size = c.comp._size\r\n          collectobj(v); ctx.restore()\r\n        } break\r\n        default: { log(c); throw Error(`wrong view type \"${c.type}\"`) }\r\n      }\r\n    }\r\n    $.render = () => {\r\n      let m, c, id = 1\r\n      const id2comp = {}\r\n      const cw = cvs.width, ch = cvs.height\r\n      ctx.reset(); ctx.clearRect(0, 0, cw, ch)\r\n      for (let i = 0, l = objarray.length; i < l; i++) {\r\n        [m, c] = objarray[i]\r\n        if (!c.pointerevent) { continue }\r\n        id2comp[id] = c.eventtarget\r\n        ctx.fillStyle = id2color(id); id += 50\r\n        ctx.setTransform(m); switch (c.type) {\r\n          case 'text': drawtext(...c.args); break\r\n          case 'rect': ctx.fillRect(...c.args); break\r\n          default: throw Error(`wrong view type \"${c.type}\"`)\r\n        }\r\n      }\r\n      const r = ch / 2, t = now()\r\n      const mousecolor = ctx.getImageData(...mousepos.map(Math.floor), 1, 1).data\r\n      mousecolor[3] = 0; id = new Uint32Array(mousecolor.buffer)[0]\r\n      const comp = id2comp[id]; if (mouseid !== id) {\r\n        if (comp) { emit(comp, 'pointerenter', mouseevent) }\r\n        if (mousecomp) { emit(mousecomp, 'pointerleave', mouseevent) }\r\n      } mouseid = id, mousecomp = comp\r\n      // if (deepequal(oldobjarr, objarray)) { return }\r\n      ctx.reset(); ctx.clearRect(0, 0, cw, ch)\r\n      for ([m, c] of objarray) {\r\n        ctx.fillStyle = c.color ?? 'black'\r\n        ctx.setTransform(m); switch (c.type) {\r\n          case 'text': drawtext(...c.args); break\r\n          case 'rect': ctx.fillRect(...c.args); break\r\n          default: throw Error(`wrong view type \"${c.type}\"`)\r\n        }\r\n      } oldobjarr = objarray\r\n    }\r\n    $.destroy = () => { }\r\n    $.animation = () => { }\r\n    $.serialize = () => { }\r\n    $.deserialize = () => { }\r\n  } return $\r\n})()\r\n\r\n$.frame = () => {\r\n  const cw = cvs.width, ch = cvs.height\r\n  if (needresize) {\r\n    if (component.root) {\r\n      component.root._size = [cw, ch]\r\n      component.markdirty(component.root)\r\n    } needresize = false\r\n  } component.update()\r\n  component.render()\r\n}\r\n\r\n// ----------------------------------------------------------\r\ncomponent.define('space-spliter', {\r\n  direction: 'horizontal', barsize: 10,\r\n  children: [], childsizes: [], resizebars: [],\r\n}, m => {\r\n  const h = m.direction === 'horizontal'\r\n  const base = (m._size[h ? 0 : 1] - (m.children.length - 1) * m.barsize) / m.children.length\r\n  const nonbase = m._size[h ? 1 : 0]\r\n  const cs = m.children.map(v => ({ type: 'component', comp: v }))\r\n  const rbs = m.resizebars.map(v => ({ type: 'component', comp: v }))\r\n  let l = 0, i = 0; for (const c of m.children) {\r\n    const childbase = base * m.childsizes[i]\r\n    const s = h ? [childbase, nonbase] : [nonbase, childbase]\r\n    cs[i].position = h ? [l, 0] : [0, l]\r\n    l += childbase; if (rbs[i]) {\r\n      const s = h ? [m.barsize, nonbase] : [nonbase, m.barsize], r = m.resizebars[i]\r\n      if (!deepequal(s, r._size)) { r._size = s; component.markdirty(r) }\r\n      rbs[i].position = h ? [l, 0] : [0, l]; l += m.barsize\r\n    } i++; if (deepequal(s, c._size)) { continue }\r\n    c._size = s; component.markdirty(c)\r\n  } return [...cs, ...rbs]\r\n}, df => df('splice', (m, i, d, ...a) => {\r\n  let sz = []; if (!a[a.length - 1]._iscomp) { sz = a.pop() }\r\n  if (sz.length < a.length) { sz.push(...new Array(a.length - sz.length).fill(1)) }\r\n  else if (sz.length > a.length) { sz = sz.slice(0, a.length) }\r\n  m.children.splice(i, d, ...a); m.childsizes.splice(i, d, ...sz)\r\n  const l = m.children.length - 1\r\n  const rl = m.resizebars.length; if (l > rl) {\r\n    m.resizebars.push(...new Array(l - rl).keys().map(() =>\r\n      component.create('resize-bar', r => (r.parent = m, component.on(r, 'pointerdown', m => {\r\n        const p = m.parent, h = p.direction === 'horizontal'\r\n        const i = p.resizebars.indexOf(m)\r\n        const a = getbbox(p._view[i]), b = getbbox(p._view[i + 1])\r\n        const totalratio = p.childsizes[i] + p.childsizes[i + 1]\r\n        const base = h ? b.right - a.left : b.bottom - a.top\r\n        const actual = base - p.barsize, bs2 = p.barsize / 2\r\n        dragprocess(e => {\r\n          const current = e.mousepos[h ? 0 : 1] - (h ? a.left : a.top)\r\n          const na = Math.min(Math.max(current - bs2, 0), actual)\r\n          const nb = Math.min(Math.max(base - current - bs2, 0), actual)\r\n          p.childsizes[i] = totalratio * na / actual\r\n          p.childsizes[i + 1] = totalratio * nb / actual\r\n          component.markdirty(p)\r\n        })\r\n      })))))\r\n  } else for (let i = 0; i < rl - l; i++) { m.resizebars.pop() }\r\n}))\r\nconst bindpe = (m, o) => (o.pointerevent = true, o.eventtarget = m, o)\r\ncomponent.define('resize-bar', (m = { value: 0 }) => (\r\n  component.on(m, 'pointerenter', m => { component.animation(v => m.value = v, m.value, 1) }),\r\n  component.on(m, 'pointerleave', m => { component.animation(v => m.value = v, m.value, 0) }),\r\n  m), m => bindpe(m, { type: 'rect', args: [0, 0, ...m._size], color: '#aaa' }))\r\ncomponent.define('resize-text', { text: '' },\r\n  m => ({ type: 'text', args: [m.text, 0, 200, 100] }))\r\n// ----------------------------------------------------------\r\ncomponent.root = component.create('space-spliter',\r\n  m => (component.watch(m, (_, m) => m.children.forEach(\r\n    (c, i) => c.text = m.childsizes[i].toFixed(2).replace(/\\.?0+$/, ''))),\r\n    m.splice(0, 0, component.create('resize-text'),\r\n      component.create('resize-text'),\r\n      component.create('resize-text'), [1.5, 0.75, 0.75])))"}