{"id":"6b84571b36e575763fe7e9c5b50310a2e0ea43abbd9f17cc37cfc62e8206b1eb","to":[],"value":"Object.assign($, await require('lib/common.js'))\r\nconst grd = await require('lib/random.js')\r\n\r\n$.component = { globalenv: $ }; with (component) {\r\n  const $ = component; $.definition = {}\r\n  const cdae = n => Error(`component definition \"${n}\" already exists.`)\r\n  const cdne = n => Error(`component definition \"${n}\" not exists.`)\r\n  $.define = (name, model = {}, transf, view, extra = {}) => {\r\n    if (definition[name]) { throw cdae(name) }\r\n    if (model.recordhistory) { model.history = [] }\r\n    model.type = name, model._iscomp = true\r\n    const trans = {};\r\n    Object.assign(trans, extra.static ?? {})\r\n    if (typeof transf === 'function') {\r\n      trans._transdef = transf.toString()\r\n      transf((n, f, history = true) => trans[n] = function (...a) {\r\n        const m = this, r = f(m, ...a)\r\n        // TODO: a should be serialized since it could contain something like component\r\n        if (history && m.recordhistory) { m.history.push([n, a]) } return r\r\n      })\r\n    } definition[name] = { model, view, trans, ...extra }\r\n    return (...a) => create(name, ...a)\r\n  }\r\n  $.create = (name, mod, ...a) => {\r\n    if (!definition[name]) { throw cdne(name) }\r\n    const d = definition[name], m = deepclone(d.model)\r\n    Object.setPrototypeOf(m, d.trans)\r\n    m.id = grd.uuid(); if (d.mod) { d.mod(m, ...a) }\r\n    switch (typeof mod) {\r\n      case 'function': mod(m); break\r\n      case 'object': Object.assign(m, mod); break\r\n    } render(m); return m\r\n  }\r\n  $.render = (c, force = false) => {\r\n    if (force || !c._view) {\r\n      const d = definition[c.type]\r\n      if (!d) { throw cdne(c.type) }\r\n      if (typeof d.view !== 'function') { return } try {\r\n        c.beforerender?.()\r\n        c._view = d.view(c)\r\n        c._view._comp = c\r\n        c.afterrender?.()\r\n      } catch { }\r\n    } return c._view\r\n  }\r\n  $.rerender = (m, ov = m._view) => (ov.replaceWith(render(m, 1)), m._view)\r\n  $.diffstate = (a, b) => {\r\n    const aks = new Set(Object.keys(a ?? {})), bks = Object.keys(b ?? {})\r\n    const r = []; let e; for (const k of bks) {\r\n      if (!aks.has(k)) { r.push(['add', k]); continue } aks.delete(k)\r\n      if (!deepequal(a[k], b[k])) { return false }\r\n    } for (const k of aks) { r.push(['del', k]) } return r\r\n  }\r\n  $.patchstate = (m, c, d) => {\r\n    for (const [t, k] of c) switch (t) {\r\n      case 'add': m[k] = d[k]; break\r\n      case 'del': delete m[k]; break\r\n    }\r\n  }\r\n  $.rebuild = changed => {\r\n    if (!root) { return }\r\n    let q = [root._view], v; while (v = q.pop()) {\r\n      const c = v._comp; if (c) {\r\n        const t = c.type, d = definition[t], mc = changed.model.has(t)\r\n        if (mc) {\r\n          const p = changed.model.get(t)\r\n          if (!p) { return true }\r\n          patchstate(c, p, d.model)\r\n        }\r\n        const tc = changed.trans.has(t)\r\n        if (tc) { Object.setPrototypeOf(c, d.trans) }\r\n        if (mc || tc || changed.view.has(t)) { v = rerender(c) }\r\n      } for (const e of v.childNodes) { q.push(e) }\r\n    }\r\n  }\r\n  $.spkey = 'ยง'\r\n  $.frompod = d => {\r\n    const a2o = (m, o = {}) => (\r\n      Object.keys(m).forEach(k => {\r\n        const v = rf(m[k]); if (v[spkey] !== 'ref') { o[k] = v }\r\n        else { refq.push(['ref', o, k, v.id]) }\r\n      }), o)\r\n    const a2a = (m, o = []) => (\r\n      m.forEach((m, i) => {\r\n        const v = rf(m); if (v[spkey] !== 'ref') { o.push(v) }\r\n        else { refq.push(['ref', o, i, v.id]) }\r\n      }), o)\r\n    const a2set = (m, o = new Set) => {\r\n      for (let v of m) {\r\n        v = rf(v); if (v[spkey] !== 'ref') { o.add(v) }\r\n        else { refq.push(['set', o, v.id]) }\r\n      } return o\r\n    }\r\n    const a2map = (m, o = new Map) => {\r\n      for (let [k, v] of m) {\r\n        k = rf(k), v = rf(v)\r\n        if (k[spkey] !== 'ref' && v[spkey] !== 'ref') { o.set(k, v) }\r\n        else { refq.push(['map', o, k, v]) }\r\n      } return o\r\n    }\r\n    const ra = {}, refq = [], rf = m => {\r\n      if (typeof m !== 'object') { return m }\r\n      if (m instanceof Array) { return a2a(m) }\r\n      const sk = m[spkey]; if (!sk) { return a2o(m) }\r\n      switch (sk) {\r\n        case 'exk': return Object.assign(rf(m.v), a2o(m.k))\r\n        case 'ref': return { [spkey]: 'ref', id: m.v }\r\n        case 'set': return a2set(m.v)\r\n        case 'map': return a2map(m.v)\r\n        default: throw Error(`invalid spkey \"${sk}\"`)\r\n      }\r\n    }\r\n    let ds; for (const type in d) for (const id in ds = d[type]) {\r\n      const o = rf(ds[id]); if (!o) { continue }\r\n      o.type = type, o.id = id, ra[id] = o\r\n    }\r\n    for (const [t, o, k, v] of refq) switch (t) {\r\n      case 'set': o.add(ra[k]); break\r\n      case 'map': o.set(\r\n        k[spkey] === 'ref' ? ra[k.id] : k,\r\n        v[spkey] = 'ref' ? ra[v.id] : v); break\r\n      case 'ref': o[k] = ra[v]; break\r\n      default: throw Error(`invalid ref type \"${t}\"`)\r\n    }\r\n    for (const id in ra) {\r\n      const m = ra[id], n = m.type\r\n      const d = definition[n]; if (!d) { throw cdae(n) }\r\n      initmodel(m, n); Object.setPrototypeOf(m, d.trans)\r\n      render(m)\r\n    }\r\n    return ra\r\n  }\r\n}\r\ncomponent.topod = (m = component.root) => {\r\n  const a2o = (m, ks, o = {}) => (ks.forEach(k => {\r\n    if (k[0] === '_') { return } const v = rf(m[k])\r\n    if (v !== undefined && v !== null) { o[k] = v }\r\n  }), o), sk = component.spkey\r\n  const seen = new Set, r = {}, rf = m => {\r\n    if (typeof m === 'object') {\r\n      if (seen.has(m)) {\r\n        if (!m._iscomp) { throw Error(`can't ref a non-component object`) }\r\n        return { [sk]: 'ref', v: m.id }\r\n      }\r\n      let o, ks = Object.keys(m); seen.add(m)\r\n      if (m instanceof Set || m instanceof Map) {\r\n        const sp = m instanceof Set ? 'set' : 'map'\r\n        o = { [sk]: sp, v: [...m].map(rf) }\r\n        if (ks.length > 0) {\r\n          o = { [sk]: 'exk', v: o }\r\n          o.k = a2o(m, ks)\r\n        }\r\n      } else if (m instanceof Array) {\r\n        o = m.map(rf); if (ks.length > m.length) {\r\n          o = { [sk]: 'exk', v: o }\r\n          o.k = a2o(m, ks.slice(m.length))\r\n        }\r\n      } else { o = a2o(m, ks) }\r\n      if (m._iscomp) {\r\n        (r[m.type] ??= {})[m.id] = (delete o.type, delete o.id, o)\r\n        return { [sk]: 'ref', v: m.id }\r\n      } else { return o }\r\n    } else if (typeof m === 'function') {\r\n      throw Error(`public value should not be function`)\r\n    } else { return m }\r\n  }; return (rf(m), r)\r\n}\r\n\r\nconst w3c = 'http://www.w3.org/', svgns = w3c + '2000/svg',\r\n  mmlns = w3c + 'Math/MathML', xhmns = w3c + '1999/xhtml'\r\n$.h = (tag, attribute, ...children) => {\r\n  let ns = '', e, nssi = tag.indexOf('@'); if (nssi >= 0) {\r\n    ns = tag.slice(0, nssi); tag = tag.slice(nssi + 1)\r\n  } switch (ns) {\r\n    case 'svg': e = document.createElementNS(svgns, tag); break\r\n    case 'mathml': e = document.createElementNS(mmlns, tag); break\r\n    case 'xhtml': e = document.createElementNS(xhmns, tag); break\r\n    default: e = document.createElement(tag); break\r\n  } for (const k in attribute) {\r\n    if (k !== 'js') { e.setAttribute(k, attribute[k]) }\r\n    else for (const l in attribute.js) { e[l] = attribute.js[l] }\r\n  } e.append(...children.map(c => c?._iscomp ? component.render(c) : c)); return e\r\n}"}