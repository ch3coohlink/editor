{"id":"1fe10e1be03f0ef6a2d4a1ebe3e915d00a4fafe436344f1bd4d6fcc22eda5890","to":[],"value":"Object.assign($, await require('../lib/common.js'))\r\nObject.assign($, await require('../comp.js'))\r\n\r\nconst { abs, log10, floor, ceil, round, min, max, sqrt } = Math\r\n\r\n{\r\n  // TODO: color class\r\n  const { max, min } = Math; $.clamp = (v, s, l) => max(min(v, l), s)\r\n  $.itp = (a, b, t) => (t = clamp(t, 0, 1), a + t * (b - a))\r\n  $.itp3 = (a, b, t) => (t = clamp(t, 0, 1),\r\n    [a[0] + t * (b[0] - a[0]), a[1] + t * (b[1] - a[1]), a[2] + t * (b[2] - a[2])])\r\n\r\n  $.callhotkey = (m, k, e, f) => {\r\n    while (m) { if (f = m._hotkey[k]) { return f(e) } m = m.parent }\r\n  }\r\n}\r\n\r\ncomponent.define('placeincenter', (m, c) => m.child = c, _,\r\n  m => h('div', {\r\n    style: `height:100%;display:flex;\r\n      justify-content: center;align-items: center;`\r\n  }, m.child))\r\n\r\ncomponent.define('top', _, df => {\r\n\r\n}, m => { })\r\n\r\nconst ematchsize = (t, e, f) => {\r\n  const cd = e.childNodes; if (t > cd.length) {\r\n    e.append(...[...new Array(t - cd.length).keys()].map(f))\r\n  } else if (t < cd.length) {\r\n    [...cd].slice(t).forEach(c => c.remove())\r\n  } return cd\r\n}\r\n\r\ncomponent.define('infinite-panel', (m, ...a) => {\r\n  m.camera = [0, 0, 1], m.realcamera = [...m.camera]\r\n  m.children = a\r\n}, df => {\r\n  df('offset', (m, e, v = m._view,\r\n    r = v.getBoundingClientRect(), s = v.clientWidth / r.width) =>\r\n    [(e.pageX - r.left) * s, (e.pageY - r.top) * s])\r\n  df('zoom', (m, e, r, [x, y] = Array.isArray(e) ? e : m.offset(e), s) => (\r\n    Array.isArray(e) ? 0 : (s = m.halfsize(), x -= s[0], y -= s[1]),\r\n    m.camera[2] *= r, // equation: y - nsy === (y - sy) * r\r\n    m.camera[0] = x - (x - m.camera[0]) * r,\r\n    m.camera[1] = y - (y - m.camera[1]) * r, m.setcamera()))\r\n  df('setcamera', (m, c = m.camera) => (m.camera = c,\r\n    m.animation('move', (dt, t, st) => (\r\n      m.camera.forEach((v, i) => m.realcamera[i]\r\n        = expdecay(m.realcamera[i], v, 16, dt)),\r\n      m._canvas.style.transform = `translate(50%, 50%) ` +\r\n      `translate(${m.realcamera[0] + 'px'}, ${m.realcamera[1] + 'px'}) ` +\r\n      `scale(${m.realcamera[2]})`, m.coordbg(),\r\n      t - st > .5 || deepequal(m.camera, m.realcamera)),\r\n      () => m.realcamera = [...m.camera])))\r\n  df('halfsize', m => [m._view.clientWidth / 2, m._view.clientHeight / 2])\r\n  df('out2in', (m, x, y, [cx, cy, s] = m.realcamera, [w, h] = m.halfsize()) =>\r\n    [(x - cx - w) / s, (y - cy - h) / s])\r\n  df('in2out', (m, x, y, [cx, cy, s] = m.realcamera, [w, h] = m.halfsize()) =>\r\n    [x * s + cx + w, y * s + cy + h])\r\n  df('getcamerapos', (m, [x, y, s] = m.realcamera) => [-x / s, -y / s])\r\n  df('coordbg', m => {\r\n    const [w, h] = m.halfsize()\r\n    const [lf, tp] = m.out2in(0, 0), [rt, bt] = m.out2in(2 * w, 2 * h)\r\n    const s = m.realcamera[2], sr = 10 ** -ceil(log10(s)), l = s * sr\r\n    const ti = [1, 0.3, 0.1].map((v, i) => [abs(l - v), i])\r\n      .sort(([a], [b]) => a - b)[0][1], sw = 1, sg = [5, 4, 5][ti]\r\n    const st = sr * [20, 50, 100][ti], t = st * sg\r\n    const hr = [], vt = [], hrs = [], vts = []\r\n    for (let s = ceil(lf / st) * st, i = sg - round((floor(lf / t) * t - s) / st)\r\n      ; s < rt; s += st, i++) { (i % sg === 0 ? hr : hrs).push(s) }\r\n    for (let s = ceil(tp / st) * st, i = sg - round((floor(tp / t) * t - s) / st)\r\n      ; s < bt; s += st, i++) { (i % sg === 0 ? vt : vts).push(s) }\r\n    const dc = m.darkcolor, lc = m.lightcolor, a = [...ematchsize(\r\n      hr.length + hrs.length + vt.length + vts.length,\r\n      m._background, () => component.h('svg@path'))]\r\n    let i = 0, f = (e, x1, y1, x2, y2, s, sw) => {\r\n      [x1, y1] = m.in2out(x1, y1, cm, sz), [x2, y2] = m.in2out(x2, y2, cm, sz)\r\n      e.setAttribute('d', `M ${x1} ${y1} L ${x2} ${y2}`)\r\n      e.setAttribute('stroke', s), e.setAttribute('stroke-width', sw + 'px')\r\n    }, cm = m.realcamera, sz = m.halfsize()\r\n    a.slice(i, i += vts.length).forEach((e, i) => f(e, lf, vts[i], rt, vts[i], lc, sw / 2))\r\n    a.slice(i, i += hrs.length).forEach((e, i) => f(e, hrs[i], tp, hrs[i], bt, lc, sw / 2))\r\n    a.slice(i, i += hr.length).forEach((e, i) => f(e, hr[i], tp, hr[i], bt, dc, sw))\r\n    a.slice(i, i += vt.length).forEach((e, i) => f(e, lf, vt[i], rt, vt[i], dc, sw))\r\n  })\r\n}, m => (setTimeout(() => m.setcamera()),\r\n  h('div', {\r\n    js: {\r\n      onwheel: (e, r = m.zoomfactor) => (\r\n        m.zoom(e, e.deltaY < 0 ? r : 1 / r), e.preventDefault()),\r\n      onpointerdown: e => {\r\n        if (e.target !== m._svg) { return }\r\n        const [cx, cy] = m.realcamera, o = m.out2in(...m.offset(e))\r\n        dragprocess((e, [x, y] = m.out2in(...m.offset(e), [cx, cy, m.realcamera[2]])) => (\r\n          m.camera[0] = cx + (x - o[0]) * m.realcamera[2],\r\n          m.camera[1] = cy + (y - o[1]) * m.realcamera[2], m.setcamera()))\r\n      }, onresize: () => m.setcamera(),\r\n    }, style: `height:100%;overflow:hidden;user-select:none;`,\r\n  },\r\n    m._svg = h('svg@svg', { style: `width:100%;height:100%;` },\r\n      m._background = h('svg@g', { style: `pointer-events: none;` }),\r\n      m._canvas = h('svg@g', _,\r\n        ...m.children.map(c => {\r\n          const v = c._iscomp ? c._view : c; return v instanceof SVGElement ? v :\r\n            h('svg@foreignObject', { style: `width:1px;height:1px;overflow:visible;` }, v)\r\n        })\r\n      )\r\n    )\r\n  )\r\n), {\r\n  static: {\r\n    zoomfactor: 1.2,\r\n    darkcolor: '#ddd',\r\n    lightcolor: '#eee',\r\n  },\r\n})\r\n\r\ncomponent.define('graph', m => {\r\n  m.node = new Set\r\n  m.direction = 'vertical'\r\n  m.hierarchy = true\r\n  m.usemargin = true\r\n  m.focusnode = _\r\n}, df => {\r\n  df('add', (m, d, p) => {\r\n    const n = h('comp@graph-node', _, m, d, p)\r\n    m._graphmoded = true, m.node.add(n)\r\n    m._svgnode.append(n._view); return n\r\n  })\r\n  df('del', (m, n) => {\r\n    m._graphmoded = true, m.node.delete(n), n.remove()\r\n    for (const [to] of n.to) { m.unlink(n, to) }\r\n    for (const [fr] of n.from) { m.unlink(fr, n) }\r\n  })\r\n  df('link', (m, a, b, d) => {\r\n    if (a.to.has(b)) { return a.to.get(b) }\r\n    const e = h('comp@graph-edge', _, m, d, a, b)\r\n    m.animation('split', () => m.splitgraph())\r\n    a.to.set(b, e), b.from.set(a, e)\r\n    m._svgedge.append(e._view); return e\r\n  })\r\n  df('unlink', (m, a, b, e = a.to.get(b)) => {\r\n    a.to.delete(b), b.from.delete(a)\r\n    m._graphmoded = true, e.remove()\r\n  })\r\n\r\n  df('splitgraph', m => {\r\n    m._subgraph = []; let seen = new Set, sub = 0\r\n    for (let n of m.node) {\r\n      if (seen.has(n)) { continue }\r\n      const s = m._subgraph[sub++] = [], q = [n]\r\n      while (n = q.shift()) {\r\n        if (seen.has(n)) { continue } s.push(n), seen.add(n)\r\n        q.push(...[...n.to.keys()], ...[...n.from.keys()])\r\n      }\r\n    }\r\n    for (const n of m.node) {\r\n      n.rank = n.ranksum = n.rankcount = 0\r\n    }\r\n    m._graphmoded = false\r\n    m.needlayout = true\r\n  })\r\n  df('rankgraph', (m, l = 100) => {\r\n    const { rdi, next } = m._rankrd\r\n    for (const g of m._subgraph) {\r\n      if (g.converged) { continue }\r\n      if (g.length <= 1) { g[0].rank = 0; g.converged = true; continue }\r\n      for (let i = 0; i < l; i++) {\r\n        const q = [[g[rdi(g.length)], 0]], seen = new Set\r\n        while (q.length > 0) {\r\n          const [n, d] = q.splice(rdi(q.length), 1)[0]\r\n          if (seen.has(n)) { continue } seen.add(n)\r\n          n.ranksum += d, q.push(\r\n            ...[...n.to.keys()].map(v => [v, d - 1]),\r\n            ...[...n.from.keys()].map(v => [v, d + 1]))\r\n        }\r\n      }\r\n      let d = 0; for (const n of g) {\r\n        n.rankcount += l\r\n        n.oldrank = n.rank\r\n        n.rank = n.ranksum / n.rankcount\r\n        d += abs(n.rank - n.oldrank)\r\n      }\r\n      if (m.progressiveranking) {\r\n        if (d < 0.001 * g.length) { g.converged = true }\r\n      } else { g.converged = true }\r\n    } next()\r\n\r\n  })\r\n  df('forcedirect', (m, step = 4) => {\r\n    const gravity = { rposition: [0, 0], _acc: [0, 0] }\r\n    const { usemargin } = m, mg = usemargin ? 15 : 0\r\n    const electric = (a, b, p, minl = 1) => {\r\n      const pdx = b.rposition[0] - a.rposition[0]\r\n      const pdy = b.rposition[1] - a.rposition[1]\r\n      const lsq = max(pdx * pdx + pdy * pdy, minl)\r\n      const l = sqrt(lsq), f = p / (lsq * l)\r\n      let fx = f * pdx, fy = f * pdy\r\n      // if (usemargin &&\r\n      //   a.bbox[0] < b.bbox[2] + mg && b.bbox[0] < a.bbox[2] + mg &&\r\n      //   a.bbox[1] < b.bbox[3] + mg && b.bbox[1] < a.bbox[3] + mg) {\r\n      //   const d0 = b.bbox[2] + mg - a.bbox[0]\r\n      //   const d1 = b.bbox[0] - mg - a.bbox[2]\r\n      //   const d2 = b.bbox[3] + mg - a.bbox[1]\r\n      //   const d3 = b.bbox[1] - mg - a.bbox[3]\r\n      //   const dx = abs(d0) < abs(d1) ? d0 : d1\r\n      //   const dy = abs(d2) < abs(d3) ? d2 : d3\r\n      //   if (abs(dx) < abs(dy)) { a.rposition[0] += dx; b.rposition[0] -= dx }\r\n      //   else { a.rposition[1] += dy; b.rposition[1] -= dy }\r\n      // }\r\n      a._acc[0] += fx, a._acc[1] += fy\r\n      b._acc[0] -= fx, b._acc[1] -= fy\r\n    }, distance = (a, b, p) => {\r\n      const pdx = b.rposition[0] - a.rposition[0]\r\n      const pdy = b.rposition[1] - a.rposition[1]\r\n      const fx = p * pdx, fy = p * pdy\r\n      a._acc[0] += fx, a._acc[1] += fy\r\n      b._acc[0] -= fx, b._acc[1] -= fy\r\n    }, friction = usemargin ? 0.5 : 0.01, dt = 0.05\r\n    const tl = m.target_length, ts = tl * 2\r\n    const pe = -ts * tl ** 2, pd = ts * 20 / tl, pg = 0.05 * pd\r\n    const h = m.direction === 'horizontal' ? 0 : 1\r\n    const g = m._subgraph.flat(1)\r\n    for (let i = 0; i < step; i++) {\r\n      for (let i = 0, l = g.length; i < l; i++) {\r\n        const a = g[i], nto = 1 / a.to.size\r\n        for (let j = i + 1; j < l; j++) { electric(a, g[j], pe) }\r\n        for (const [to] of a.to) { distance(a, to, pd * nto) }\r\n        if (a._lock) { a._vel[0] = a._vel[1] = 0; continue }\r\n        if (m.hierarchy) { a._acc[h] -= a.rank * tl * 1 }\r\n        distance(a, gravity, pg)\r\n        const vx = a._vel[0] + a._acc[0] * dt\r\n        const vy = a._vel[1] + a._acc[1] * dt\r\n        let v = sqrt(vx * vx + vy * vy), vrx = vx / v, vry = vy / v\r\n        v = max(min(v, ts) - ts * friction, 0)\r\n        a.rposition[0] += (a._vel[0] = vrx * v) * dt\r\n        a.rposition[1] += (a._vel[1] = vry * v) * dt\r\n        a._acc[0] = a._acc[1] = 0\r\n      }\r\n    }\r\n  })\r\n  df('layout', (m, dt) => {\r\n    if (m._graphmoded) { m.splitgraph() }\r\n    if (m.needlayout) {\r\n      m.animation('layout', dt => {\r\n        for (const n of m.node) {\r\n          n._oldposition = [...n.position]\r\n        }\r\n        m.rankgraph(100), m.forcedirect(4)\r\n        let totalspeed = 0\r\n        for (const n of m.node) {\r\n          n.position = n.rposition.map(\r\n            (v, i) => expdecay(n.position[i], v, 10, dt))\r\n          // n.position = [...n.rposition] // show the real world (hint: horrify)\r\n          totalspeed += abs(n.position[0] - n._oldposition[0])\r\n            + abs(n.position[1] - n._oldposition[1])\r\n          n.update()\r\n        }\r\n        if (totalspeed <= 0.1 * m.node.size) { m.needlayout = false }\r\n        if (m._moving) { m.updatemove() }\r\n        return m.needlayout\r\n      })\r\n    }\r\n    if (m.focusnode) {\r\n      for (const [, e] of m.focusnode.to) {\r\n        e._view.setAttribute('stroke', m.focuscolor)\r\n        e._view.setAttribute('stroke-width', '2px')\r\n      } for (const [, e] of m.focusnode.from) {\r\n        e._view.setAttribute('stroke', '#ff9700')\r\n        e._view.setAttribute('stroke-width', '2px')\r\n      }\r\n    }\r\n  })\r\n  df('getmovetarget', m => {\r\n    const a = m._previewmove ? m._previewmove.position :\r\n      m.focusnode ? m.focusnode.position : m._svgpanel.getcamerapos()\r\n    let i = 0, mvup = i, mvdw = i, mvlf = i, mvrt = i\r\n    const maxnode = {}; for (const n of m.node) {\r\n      const dx = n.position[0] - a[0], dy = n.position[1] - a[1]\r\n      let l = Math.sqrt(dx * dx + dy * dy), ld = 1 / l, lp = 1 - l / 500\r\n      const dup = dy * -ld, ddw = dy * ld, dlf = dx * -ld, drt = dx * ld\r\n      if (dup > 0) { v = lp + dup; if (mvup < v) { mvup = v; maxnode.up = n } }\r\n      if (ddw > 0) { v = lp + ddw; if (mvdw < v) { mvdw = v; maxnode.dw = n } }\r\n      if (dlf > 0) { v = lp + dlf; if (mvlf < v) { mvlf = v; maxnode.lf = n } }\r\n      if (drt > 0) { v = lp + drt; if (mvrt < v) { mvrt = v; maxnode.rt = n } }\r\n    } m._movetarget = maxnode\r\n  })\r\n  df('updatemove', (m, _, d) => {\r\n    let n; if (m._movetarget) {\r\n      for (const k in m._movetarget) if (n = m._movetarget[k]) {\r\n        n.settitle(''); n.resetcolor()\r\n      } if (m._previewmove) { m._previewmove.resetcolor() }\r\n      if (d) { m._previewmove = m._movetarget[d] }\r\n    }\r\n    if (m.focusnode) { m.focusnode.setcolor(m.focuscolor) }\r\n    if (!m._moving) {\r\n      if (m.focusnode) { m.focusnode.setcolor(m.focuscolor, '44') }\r\n      if (m._previewmove) { m._previewmove.focus() }\r\n      return m._edgecreated = m._movetarget = m._previewmove = undefined\r\n    } m.getmovetarget()\r\n    for (const k in m._movetarget) if (n = m._movetarget[k]) {\r\n      n._title.setAttribute('stroke-width', '1px')\r\n      n._title.setAttribute('stroke', '#333')\r\n      n._title.setAttribute('fill', '#c8ff17')\r\n      n._title.setAttribute('font-size', '50px')\r\n      switch (k) {\r\n        case 'up': n.addtitle('↑'); break\r\n        case 'dw': n.addtitle('↓'); break\r\n        case 'lf': n.addtitle('←'); break\r\n        case 'rt': n.addtitle('→'); break\r\n      }\r\n    } if (m._previewmove) { m._previewmove.setcolor('#ff9700') }\r\n  })\r\n  df('startmove', m => m._moving || m._forceleavemove\r\n    ? 0 : m.updatemove(m._moving = true))\r\n  df('move', (m, d) => m.updatemove(m._moving = true, d))\r\n  df('endmove', m => {\r\n    m.updatemove(m._moving = false)\r\n    m._forceleavemove = false\r\n  })\r\n  df('pausemove', m => {\r\n    const n = m.focusnode; m.updatemove(m._moving = false)\r\n    m._forceleavemove = true; (n ? n : m).focus()\r\n  })\r\n  df('focus', m => m._view.focus())\r\n  df('blur', m => m._view.blur())\r\n  df('createorconnect', (m, second = false) => {\r\n    if (m._previewmove) {\r\n      if (!m.focusnode) { return } const b = m._previewmove\r\n      const a = m.focusnode, ab = a.to.has(b), ba = b.to.has(a)\r\n      if (second) {\r\n        if (ab) { m.unlink(a, b) } if (ba) { m.unlink(b, a) }\r\n      } else {\r\n        if (ab && ba) { m.unlink(b, a) } else if (ab) {\r\n          m.link(b, a); if (m._reverted) { delete m._reverted }\r\n          else { m.unlink(a, b), m._reverted = true }\r\n        } else if (ba) {\r\n          m.link(a, b); if (m._reverted) { delete m._reverted }\r\n          else { m.unlink(b, a), m._reverted = true }\r\n        } else { m.link(m.focusnode, b) }\r\n      }\r\n    } else {\r\n      m.endmove(); const a = m.focusnode, b = m.add(\r\n        h('comp@text-editor'), a ? a.position : m._svgpanel.getcamerapos())\r\n      if (a) { m.link(a, b); second ? b.focus() : 0 } else { b.focus() }\r\n    }\r\n  })\r\n  df('callhotkey', callhotkey)\r\n  df('onload', m => {\r\n    m._graphmoded = true\r\n    // \r\n    setTimeout(() => {\r\n      m.focusnode?.focus?.()\r\n    }, 20)\r\n  })\r\n  df('save', () => save())\r\n}, m => (\r\n  m._rankrd = grd.genrd(2462462542),\r\n  m._horizontal = m.direction === 'horizontal',\r\n  h('div', { style: `height:100%;` },\r\n    // TODO: config UI,\r\n    m._svgpanel = h('comp@infinite-panel', _,\r\n      m._svgedge = h('svg@g', { filter: 'drop-shadow(0 2px 2px #00000055)', },\r\n        ...[...m.node].map(n => [...n.to.values()]).flat(1)\r\n      ),\r\n      m._svgnode = h('div', _, ...m.node)\r\n    )\r\n  )), {\r\n  static: {\r\n    color: [90, 90, 90],\r\n    focuscolor: '#0087ff',\r\n    target_length: 50,\r\n    hotkey: {\r\n\r\n    },\r\n  },\r\n})\r\n\r\nconst ndrd = grd.genrd(294502028)\r\ncomponent.define('graph-node', (m, pr, d, p = [0, 0]) => {\r\n  m.parent = pr\r\n  m.data = d\r\n  m.from = new Map\r\n  m.to = new Map\r\n  m.position = p\r\n  m.rposition = p.map(v => v + ndrd.rd(-1, 1))\r\n  m.rank = 0\r\n}, df => {\r\n  df('del', m => (m.parent.focus(), m.parent.del(m)))\r\n  df('link', (m, t, e) => m.parent.link(m, t, e))\r\n  df('unlink', (m, t) => m.parent.unlink(m, t))\r\n  df('setcolor', (m, c, o = '88') => {\r\n    m._view.style.boxShadow = c + o + ' 0px 4px 10px'\r\n    m._insign.setAttribute('stroke', c)\r\n    m._title.setAttribute('stroke', c)\r\n  })\r\n  df('resetcolor', m => {\r\n    m._view.style.boxShadow = '#00000044 0px 4px 10px'\r\n    m._insign.setAttribute('stroke', m._dragsigncolor)\r\n    m._title.setAttribute('stroke', m._dragsigncolor)\r\n    m._title.setAttribute('fill', m._dragsigncolor)\r\n  })\r\n  df('update', m => {\r\n    const x = m.position[0] - m._size[0] / 2\r\n    const y = m.position[1] - 5\r\n    m.bbox = [x, y, x + m._size[0], y + m._size[1]]\r\n    m.center = [m.position[0], y + m._size[1] / 2]\r\n    m._view.style.transform = `translate(${[x + 'px', y + 'px'].join(', ')})`\r\n    for (const [, e] of m.to) { e.reset() }\r\n  })\r\n  df('focus', m => (m._view.style.zIndex = '100',\r\n    m._size ? 0 : (m.preupdate(), m.update()),\r\n    m.setcolor(m.parent.focuscolor, '44'),\r\n    m.parent.focusnode = m, m.data.focus?.()))\r\n  df('blur', m => (m.resetcolor(), m._view.style.zIndex = '',\r\n    m.to.forEach(e => e.reset()), m.from.forEach(e => e.reset()),\r\n    m.parent.focusnode = _, m.data.blur?.(), m.parent.endmove()))\r\n  df('callhotkey', callhotkey)\r\n  df('addtitle', (m, t) => {\r\n    m.settitle(m._title.textContent + t)\r\n  })\r\n  df('settitle', (m, t) => {\r\n    m._title.textContent = t\r\n    const w = m._title.getBBox().width\r\n    m._title.style.transform =\r\n      `translate(calc(50% - ${w / 2}px), calc(50% - 10px))`\r\n  })\r\n  df('quitconnectmode', m => m.parent.setconnectmode(m))\r\n}, m => (\r\n  m._acc = [0, 0],\r\n  m._vel = [0, 0],\r\n  m._size = [0, 0],\r\n  m._bbox = [0, 0, 0, 0],\r\n  m._ranksum = 0,\r\n  m._rankcount = 0,\r\n  h('div', {\r\n    js: {\r\n      onpointerdown: e => {\r\n        if (e.target !== m._view) { return }\r\n        // TODO: relative movement\r\n        const p = m.parent._svgpanel\r\n        dragprocess(e => {\r\n          m._lock = true\r\n          m.position = p.out2in(...p.offset(e))\r\n        }, () => { m._lock = false })\r\n      },\r\n      onresize: () => {\r\n        m._size = [m._view.clientWidth, m._view.clientHeight]\r\n        m.parent.layout()\r\n      }\r\n    }, style: `box-shadow: #00000044 0px 4px 10px;\r\n      backdrop-filter: blur(1px); cursor: pointer;\r\n      color: #333; transition: box-shadow 0.3s; position: absolute;\r\n      background: linear-gradient(12deg, #0000001f, #00000010);\r\n      min-width: 100px; max-width: 50vw; width: fit-content;\r\n      border-radius: 10px; padding: 10px;`},\r\n    h('svg@svg', { style: `position:absolute;width:100%;height:100%;overflow:visible;` },\r\n      m._insign = h('svg@path'),\r\n      m._outsign = h('svg@path'),\r\n      m._title = h('svg@text'),\r\n    ),\r\n    h('div', {}, m.data),\r\n  )\r\n))\r\n\r\ncomponent.define('graph-edge', (m, d, a, b) => {\r\n  if (d) { m.data = d }\r\n  m.from = a\r\n  m.to = b\r\n}, df => {\r\n  df('reset', (m, p = m.from.parent, h = p._horizontal, clr = p.color) => {\r\n    const s = 0.6, c = 10, v = m._view\r\n    const a = m.from.position, b = m.to.position\r\n    if (m.from === m.to) {\r\n      const r = 20, r2 = r * 2, x = a[0], y = a[1]\r\n      v.setAttribute('d', `M ${x + r} ${y} m ${r} 0 ` +\r\n        `a ${r},${r} 0 1,0 ${-r2}, 0 a ${r},${r} 0 1,0 ${r2}, 0 ` +\r\n        `M ${x + r2 + c} ${y + c} L ${x + r2} ${y} L ${x + r2 - c} ${y + c}`)\r\n      v.removeAttribute('stroke')\r\n    } else {\r\n      let dx = b[0] - a[0], dy = b[1] - a[1]\r\n      const mx = a[0] + dx * s, my = a[1] + dy * s\r\n      const l = Math.sqrt(dx * dx + dy * dy)\r\n      const ld = 1 / l; dx *= ld, dy *= ld\r\n      const cl = itp3(clr, [256, ...clr.slice(1)], -(h ? dx : dy) + 0.5)\r\n      v.setAttribute('stroke', `rgb(${cl.join(', ')})`)\r\n      if (l < c) {\r\n        v.setAttribute('d', ['M', ...a, 'L', ...b].join(' '))\r\n      } else {\r\n        dx *= c, dy *= c, v.setAttribute('d', ['M', ...a, 'L', ...b,\r\n          'M', mx + dy, my - dx, 'L', mx + dx, my + dy, 'L', mx - dy, my + dx].join(' '))\r\n      }\r\n    } v.removeAttribute('stroke-width')\r\n  })\r\n}, m => h('svg@path'))"}