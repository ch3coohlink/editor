{"id":"3e7873781951e8aea5a9a1ce8571fb7f7d4719e28c93fcaaf54ba80560d57cda","to":[],"value":"Object.assign($, await require('../util/common.js'))\r\nconst compsys = await require('../util/component.js')\r\nconst grd = await require('../util/random.js')\r\nconsole.clear()\r\n\r\nlet framecount = 0\r\nconst loop = () => {\r\n  if ($.frame) { framecount++; frame() }\r\n  requestAnimationFrame(loop)\r\n}; requestAnimationFrame(loop)\r\n\r\n$.cvs = await createcanvas()\r\n$.ctx = cvs.getContext('2d', { willReadFrequently: true })\r\n$.component = compsys.createcomponentsystem({ cvs, ctx })\r\nObject.defineProperty(component.globalenv, 'framecount', { get: () => framecount })\r\n\r\ncomponent.define('graph', {\r\n  direction: 'horizontal', subgraph: [],\r\n  target_length: 50,\r\n  node: [], edge: [], vnode: [], vedge: [],\r\n}, df => (\r\n  df('add', (m, d, n = component.create('graph-node',\r\n    nm => (nm.parent = m, nm.data = d, nm.ranksum = 0, nm.rankcount = 0))) =>\r\n    (m.graphmoded = true, m.node.push(n), n)),\r\n  df('link', (m, a, b, d, e = component.create('graph-edge',\r\n    em => (em.parent = m, em.from = a, em.to = b, em.data = d))) =>\r\n    (m.graphmoded = true, a.to.push(e), b.from.push(e), m.edge.push(e), e))),\r\n  m => {\r\n    const h = m.direction === 'horizontal'; let r\r\n    m._horizontal = h\r\n    if (true || m.rankchanged) {\r\n      const nvs = [], evs = []\r\n      // for (const g of m.subgraph)\r\n      const g = m.node\r\n      {\r\n        const gvs = g.map(comp => ({ type: 'component', comp }))\r\n        for (let i = 0, l = g.length; i < l; i++) {\r\n          const n = g[i]\r\n          gvs[i].position = n.position\r\n          component.markdirty(n)\r\n          for (const e of n.to) {\r\n            evs.push({ type: 'component', comp: e })\r\n            component.markdirty(e)\r\n          }\r\n        } nvs.push(...gvs)\r\n      }\r\n\r\n      m.rankchanged = m.graphmoded = false\r\n      r = { type: 'component', comp: { _view: [...evs, ...nvs] } }\r\n    } else { r = m._view ?? [] } r.position = h\r\n      ? [m._size[0] / 2, m._size[1] / 2] : [m._size[0] / 2, m._size[1] / 2]\r\n    return r\r\n  })\r\nconst splitgraph = m => {\r\n  m.subgraph = []; let seen = new Set, sub = 0\r\n  for (let i = 0, l = m.node.length; i < l; i++) {\r\n    let n = m.node[i]; if (seen.has(n)) { continue }\r\n    const s = m.subgraph[sub++] = [], q = [n]\r\n    while (n = q.shift()) {\r\n      if (seen.has(n)) { continue } s.push(n), seen.add(n)\r\n      q.push(...n.to.map(e => e.to), ...n.from.map(e => e.from))\r\n    }\r\n  } m.subgraph = [m.subgraph[0]]\r\n}\r\nconst rankrd = grd.genrd(2462462542)\r\nconst rankgraph = (m, l = 1) => {\r\n  const { rdi } = rankrd, { round, abs } = Math\r\n  for (const g of m.subgraph) {\r\n    if (g.converged) { continue }\r\n    if (g.length <= 1) {\r\n      g[0].layer = [0, 0];\r\n      g.layer = [1];\r\n      g.converged = true;\r\n      continue\r\n    }\r\n    const st = now()\r\n\r\n    for (let i = 0; i < l; i++) {\r\n      const q = [[g[rdi(g.length)], 0]], seen = new Set\r\n      while (q.length > 0) {\r\n        const [n, d] = q.splice(rdi(q.length), 1)[0]\r\n        if (seen.has(n)) { continue } seen.add(n)\r\n        n.ranksum += d, q.push(\r\n          ...n.to.map(e => [e.to, d - 1]),\r\n          ...n.from.map(e => [e.from, d + 1]))\r\n      }\r\n    }\r\n\r\n    let d = 0; for (const n of g) {\r\n      n.rankcount ??= 0, n.rankcount += l\r\n      n.oldrank = n.rank ??= 0\r\n      n.rank = n.ranksum / n.rankcount\r\n      d += abs(n.rank - n.oldrank)\r\n    }\r\n    // if (d < 0.001 * g.length) { g.converged = true }\r\n    g.converged = true\r\n\r\n    const gs = [...g].sort((a, b) => b.rank - a.rank)\r\n    let layer = [[]], current = gs[0].rank, ci = 0\r\n    for (const n of gs) {\r\n      if (n.rank !== current) { layer.push([]); ci++; current = n.rank }\r\n      const l = layer[ci]; n.layer = [ci, l.length], l.push(n)\r\n    }\r\n\r\n    g.layer = layer.map(l => l.length + (l.length % 2 === 0 ? 1 : 0))\r\n\r\n    const et = now()\r\n    // log(et - st)\r\n  } rankrd.next(), m.rankchanged = true\r\n\r\n}\r\nconst forcerd = grd.genrd(136360090)\r\nconst forcedirect = m => {\r\n  const { sqrt, max, min } = Math\r\n  const gravity = { position: [0, 0], acceleration: [0, 0] }\r\n  const electric = (a, b, p, minl = 1) => {\r\n    const pdx = b.position[0] - a.position[0]\r\n    const pdy = b.position[1] - a.position[1]\r\n    const lsq = max(pdx * pdx + pdy * pdy, minl)\r\n    const l = sqrt(lsq), f = p / (lsq * l)\r\n    const fx = f * pdx, fy = f * pdy\r\n    a.acceleration[0] += fx, a.acceleration[1] += fy\r\n    b.acceleration[0] -= fx, b.acceleration[1] -= fy\r\n  }, distance = (a, b, p) => {\r\n    const pdx = b.position[0] - a.position[0]\r\n    const pdy = b.position[1] - a.position[1]\r\n    const fx = p * pdx, fy = p * pdy\r\n    a.acceleration[0] += fx, a.acceleration[1] += fy\r\n    b.acceleration[0] -= fx, b.acceleration[1] -= fy\r\n  }, friction = 0.01, dt = 0.05\r\n  const tl = m.target_length, ts = tl * 2\r\n  const pe = -ts * tl ** 2, pd = ts * 20 / tl, pg = 0.05 * pd\r\n  const h = m.direction === 'horizontal' ? 0 : 1\r\n\r\n  const g = m.node\r\n  // for (const g of m.subgraph)\r\n\r\n  for (let i = 0; i < 1; i++) {\r\n    let total_speed = 0; for (const n of g) {\r\n      n.acceleration = [0, 0], n.velocity ??= [0, 0]\r\n      n.position ??= [forcerd.rd(-1, 1) * tl, forcerd.rd(-1, 1) * tl]\r\n    } for (let i = 0, l = g.length; i < l; i++) {\r\n      const n = g[i], nto = 1 / n.to.length\r\n      for (let j = i + 1; j < l; j++) { electric(n, g[j], pe) }\r\n      for (const { to } of n.to) { distance(n, to, pd * nto) }\r\n      // if (a.hardlock) { a.velocity[0] = a.velocity[1] = 0; continue }\r\n      // a.acceleration[h] -= a.rank * tl * 20\r\n      distance(n, gravity, pg)\r\n      const vx = n.velocity[0] + n.acceleration[0] * dt\r\n      const vy = n.velocity[1] + n.acceleration[1] * dt\r\n      let v = sqrt(vx * vx + vy * vy), vrx = vx / v, vry = vy / v\r\n      total_speed += v = max(min(v, ts) - ts * friction, 0)\r\n      // if (a.lock) { a.velocity[0] = a.velocity[1] = 0; continue }\r\n      n.position[0] += (n.velocity[0] = vrx * v) * dt\r\n      n.position[1] += (n.velocity[1] = vry * v) * dt\r\n      // a.position[0] = a.layer[0] * 10 - g.layer.length * 10 / 2\r\n      n.acceleration[0] = n.acceleration[1] = 0\r\n    }\r\n    // g.layout_time += time.realdelta\r\n    // if (framecount < 100) { log(total_speed - g.total_speed) }\r\n    g.total_speed = total_speed\r\n  }\r\n}\r\nconst layoutgraph = m => {\r\n  // if (m.graphmoded) { splitgraph(m) }\r\n  // rankgraph(m, 100)\r\n  forcedirect(m)\r\n  component.markdirty(m)\r\n}\r\n\r\nconst size = 3\r\ncomponent.define('graph-node', { from: [], to: [], _size: [size, size] }, df => (\r\n  df('link', (m, t, e) => parent.link(m, t, e), false)\r\n), m => [{ type: 'rect', args: [-m._size[0] / 2, -m._size[1] / 2, ...m._size] },\r\n{ type: 'path', args: [['M', 0, 0], ['L', ...m.velocity]], color: 'green' },\r\n// { type: 'path', args: [['M', 0, 0], ['L', ...m.position]], color: 'blue' },\r\n{ type: 'path', args: [['M', 0, 0], ['L', ...m.acceleration.map(v => v * 0.02)]], color: 'red' },\r\n])\r\ncomponent.define('graph-edge', _, _, m => {\r\n  const a = m.from.position, b = m.to.position\r\n  const vp = (m.virtualpoint ?? []).map(vp => ['L', ...vp.position])\r\n  // if (!m.direction) { vp.reverse() }\r\n  const args = [['M', ...a], ...vp, ['L', ...b]]\r\n  const r = { type: 'path', args }\r\n  // if (!m.direction) { r.color = 'red' }\r\n  return r\r\n})\r\n\r\nconst g = component.create('graph', m => m.target_length = 100)\r\ncomponent.root = g\r\n\r\n// const rgrd = grd.genrd(3703646480)\r\nconst rgrd = grd.genrd(); log(rgrd.seed)\r\nconst randomgraph = (g, l = rgrd.rdi(50, 100), ns = []) => {\r\n  for (let i = 0; i < l; i++) { ns.push(g.add()) }\r\n  for (let i = 0; i < l; i++) {\r\n    // const r = rgrd.rd() > 0.9 ? 2 : 1\r\n    const r = 2\r\n    // const r = 1\r\n    const a = ns[i], s = [...ns]\r\n    for (let j = 0; j < r && s.length > 0; j++) {\r\n      g.link(a, s.splice(rgrd.rdi(s.length), 1)[0])\r\n    }\r\n  } rgrd.next()\r\n}\r\nrandomgraph(g)\r\n// randomgraph(g)\r\n\r\n$.frame = () => {\r\n  layoutgraph(g)\r\n  if (framecount === 1) {\r\n    log(g.subgraph[0]?.length)\r\n    log(g)\r\n  }\r\n  component.frame()\r\n}"}