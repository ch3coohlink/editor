{"id":"025472a0c458dd24e9219eff339c7b5490b8dc6b733bc905b89c786c96f705ac","to":[],"value":"Object.assign($, await require('../util/common.js'))\r\nconst compsys = await require('../util/component.js')\r\nconst grd = await require('../util/random.js')\r\nconsole.clear()\r\n\r\nlet framecount = 0\r\nconst loop = () => {\r\n  if ($.frame) { framecount++; frame() }\r\n  requestAnimationFrame(loop)\r\n}; requestAnimationFrame(loop)\r\n\r\n$.cvs = await createcanvas()\r\n$.ctx = cvs.getContext('2d', { willReadFrequently: true })\r\n\r\nconst forcerd = grd.genrd(136360090)\r\nconst forcedirect = m => {\r\n  const { sqrt, max, min } = Math\r\n  const gravity = { position: [0, 0], acceleration: [0, 0] }\r\n  const electric = (a, b, p, minl = 1) => {\r\n    const pdx = b.position[0] - a.position[0]\r\n    const pdy = b.position[1] - a.position[1]\r\n    const lsq = max(pdx * pdx + pdy * pdy, minl)\r\n    const l = sqrt(lsq), f = p / (lsq * l)\r\n    const fx = f * pdx, fy = f * pdy\r\n    a.acceleration[0] += fx, a.acceleration[1] += fy\r\n    b.acceleration[0] -= fx, b.acceleration[1] -= fy\r\n  }, distance = (a, b, p) => {\r\n    const pdx = b.position[0] - a.position[0]\r\n    const pdy = b.position[1] - a.position[1]\r\n    const fx = p * pdx, fy = p * pdy\r\n    a.acceleration[0] += fx, a.acceleration[1] += fy\r\n    b.acceleration[0] -= fx, b.acceleration[1] -= fy\r\n  }\r\n\r\n  const friction = 0.01, dt = 0.05\r\n  const tl = 200, ts = tl * 2\r\n  const pe = -ts * tl ** 2, pd = ts * 20 / tl, pg = 0.05 * pd\r\n\r\n  const g = m.node\r\n  for (let i = 0; i < 1; i++) {\r\n    for (let i = 0, l = g.length; i < l; i++) {\r\n      const n = g[i], nto = 1 / n.to.length\r\n      for (let j = i + 1; j < l; j++) { electric(n, g[j], pe) }\r\n      for (const { to } of n.to) { distance(n, to, pd * nto) }\r\n      distance(n, gravity, pg)\r\n      const vx = n.velocity[0] + n.acceleration[0] * dt\r\n      const vy = n.velocity[1] + n.acceleration[1] * dt\r\n      let v = sqrt(vx * vx + vy * vy), vrx = vx / v, vry = vy / v\r\n      v = max(min(v, ts) - ts * friction, 0)\r\n      n.position[0] += (n.velocity[0] = vrx * v) * dt\r\n      n.position[1] += (n.velocity[1] = vry * v) * dt\r\n      n.acceleration[0] = n.acceleration[1] = 0\r\n    }\r\n  }\r\n}\r\n\r\nconst g = { node: [] }\r\ng.add = (r = { to: [] }) => {\r\n  g.node.push(r)\r\n  return r\r\n}\r\ng.link = (a, b) => {\r\n  a.to.push({ from: a, to: b })\r\n}\r\n\r\n// const rgrd = grd.genrd(3703646480)\r\nconst rgrd = grd.genrd(); log(rgrd.seed)\r\nconst randomgraph = (g, l = rgrd.rdi(50, 100), ns = []) => {\r\n  for (let i = 0; i < l; i++) { ns.push(g.add()) }\r\n  for (let i = 0; i < l; i++) {\r\n    // const r = rgrd.rd() > 0.9 ? 2 : 1\r\n    const r = 2\r\n    // const r = 1\r\n    const a = ns[i], s = [...ns]\r\n    for (let j = 0; j < r && s.length > 0; j++) {\r\n      g.link(a, s.splice(rgrd.rdi(s.length), 1)[0])\r\n    }\r\n  } rgrd.next()\r\n}\r\nrandomgraph(g)\r\n// randomgraph(g)\r\n\r\nconst tl = 200\r\nfor (const n of g.node) {\r\n  n.acceleration = [0, 0], n.velocity ??= [0, 0]\r\n  n.position ??= [forcerd.rd(-1, 1) * tl, forcerd.rd(-1, 1) * tl]\r\n}\r\n\r\n$.frame = () => {\r\n  forcedirect(g)\r\n\r\n  const w = cvs.width, h = cvs.height, s = 1 / 4\r\n  ctx.reset()\r\n  ctx.fillStyle = 'white'\r\n  ctx.fillRect(0, 0, w, h)\r\n  ctx.setTransform(s, 0, 0, -s, w * 0.5, h * 0.5)\r\n  ctx.fillStyle = ctx.strokeStyle = 'black'\r\n  ctx.lineWidth = 1\r\n\r\n  const ns = g.node\r\n  for (const n of ns) {\r\n    const [x, y] = n.position\r\n    ctx.beginPath(), ctx.arc(x, y, 2 / s, 0, 2 * Math.PI), ctx.fill()\r\n    for (const { to } of n.to) {\r\n      const bp = to.position\r\n      ctx.beginPath(), ctx.moveTo(x, y)\r\n      ctx.lineTo(...bp), ctx.stroke()\r\n    }\r\n  }\r\n\r\n  if (framecount === 1) { log(ns) }\r\n  // if (!drawforce) { return }\r\n  // ctx.strokeStyle = 'red'\r\n  // for (const n of ns) {\r\n  //   const { x, y } = n.data.pos, r = .1\r\n  //   n.data.oldacc.x -= Math.sign(n.data.vec.x) * target_speed * friction\r\n  //   n.data.oldacc.y -= Math.sign(n.data.vec.y) * target_speed * friction\r\n  //   ctx.beginPath(), ctx.moveTo(x, y)\r\n  //   ctx.lineTo(x + n.data.oldacc.x * r, y + n.data.oldacc.y * r), ctx.stroke()\r\n  // }\r\n  // ctx.strokeStyle = 'green'\r\n  // for (const n of ns) {\r\n  //   const { x, y } = n.data.pos, r = 1\r\n  //   ctx.beginPath(), ctx.moveTo(x, y)\r\n  //   ctx.lineTo(x + n.data.vec.x * r, y + n.data.vec.y * r), ctx.stroke()\r\n  // }\r\n}"}