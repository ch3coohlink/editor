{"id":"af4e07ff1735468583dfdbf3dd71afd2168403a5af906fccc900eae1f843d961","to":[],"value":"const solvepath = (b, p) => b + (\r\n  p.startsWith('/') || b === '' || b.endsWith('/') ? '' : '/') + p\r\n\r\nlet i = 0, waitload = new Map\r\nconst call = f => (...a) => {\r\n  let rj, j, p = new Promise((...a) => [, j] = rj = a)\r\n    .finally(() => (clearTimeout(h), waitload.delete(id)))\r\n  const id = i++; send('$function$' + f, (a.id = id, a))\r\n  const h = setTimeout(() => j(a), 5000)\r\n  waitload.set(id, rj); return p\r\n}\r\nconst callvoid = f => (...a) =>\r\n  send('$function$' + f, a)\r\n\r\nconst _log = callvoid('console.log')\r\nconst _error = callvoid('console.error')\r\nconst _clear = callvoid('console.clear')\r\nglobalThis.originconsole = console\r\nglobalThis.console = { log: _log, error: _error, clear: _clear }\r\n\r\nconst read = globalThis.rawread = call('$.__sandbox__.read')\r\nconst write = globalThis.rawwrite = call('$.__sandbox__.write')\r\nglobalThis.__sandbox__ = { read, write }\r\nglobalThis.read = call('read')\r\nglobalThis.write = call('write')\r\nglobalThis.__read__ = (v, b, fst) => (p, opt) =>\r\n  read(v, solvepath(b, p), fst, opt, !(opt?.raw))\r\nglobalThis.__write__ = (v, b, fst) => (p, t, force) =>\r\n  write(v, solvepath(b, p), t, fst, force)\r\nglobalThis.__require = (v, b, fst) => async (ph, p = solvepath(b, ph)) => {\r\n  const data = await load(v, p, fst, { watch: true }), file = data.id\r\n  if (loaded.has(file)) { return loaded.get(file) }\r\n  const ex = await exec(...data); loaded.set(file, ex); return ex\r\n}\r\nglobalThis.requestcanvas = call('requestcanvas')\r\n\r\nconst loaded = new Map, AF = (async () => { }).constructor\r\nconst exec = (ver, path, src, first = false) => new AF('$',\r\n  `//# sourceURL=${ver.slice(0, 16) + '/' + path}\\nconst __repoid = '${ver}'\\n` +\r\n  `const __dirname = '${path.split('/').slice(0, -1).join('/')}'\\n` +\r\n  `const readlocal = __read__(__repoid, __dirname, ${first})\\n` +\r\n  `const writelocal = __write__(__repoid, __dirname, ${first})\\n` +\r\n  `const require = __require(__repoid, __dirname, ${first})\\n` +\r\n  `with($) {\\n${src}\\n}\\n return $`)({})\r\n\r\nconst send = (t, o = {}, ...a) => {\r\n  if (Array.isArray(o)) { o = { a: o, isarr: true } }\r\n  postMessage((o.type = t, o), a)\r\n}\r\naddEventListener('message', e => {\r\n  let o = e.data\r\n  if (o.isarr) { o.a.type = o.type; o = o.a }\r\n  if (o.type === 'init') { exec(...o, true) }\r\n  else if (o.type === 'callfin') {\r\n    if (waitload.has(o.id)) {\r\n      waitload.get(o.id)[0](o.r)\r\n    }\r\n  } else if (o.type === 'error') {\r\n    if (waitload.has(o.id)) {\r\n      waitload.get(o.id)[1](o.error)\r\n    } _error(o.error)\r\n  }\r\n})\r\nsetInterval(() => send('heartbeat'), 500)\r\naddEventListener('error', _error)"}