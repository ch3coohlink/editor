{"id":"50d3889f4212762154388549384e7cb79cc40936e6693706e9044fc479fc9e99","to":[],"value":"Object.assign($, await require('../util/common.js'))\r\nconst compsys = await require('../util/component.js')\r\nconst grd = await require('../util/random.js')\r\nconsole.clear()\r\n\r\nlet framecount = 0\r\nconst loop = () => {\r\n  if ($.frame) { framecount++; frame() }\r\n  requestAnimationFrame(loop)\r\n}; requestAnimationFrame(loop)\r\n\r\n$.cvs = await createcanvas()\r\n$.ctx = cvs.getContext('2d', { willReadFrequently: true })\r\n$.component = compsys.createcomponentsystem({ cvs, ctx })\r\nObject.defineProperty(component.globalenv, 'framecount', { get: () => framecount })\r\n\r\ncomponent.define('graph', {\r\n  direction: 'horizontal', subgraph: [],\r\n  node: [], edge: [], vnode: [], vedge: [],\r\n}, df => (\r\n  df('add', (m, d, n = component.create('graph-node',\r\n    nm => (nm.parent = m, nm.data = d, nm.ranksum = 0, nm.rankcount = 0))) =>\r\n    (m.graphmoded = true, m.node.push(n), n)),\r\n  df('link', (m, a, b, d, e = component.create('graph-edge',\r\n    em => (em.parent = m, em.from = a, em.to = b, em.data = d))) =>\r\n    (m.graphmoded = true, a.to.push(e), b.from.push(e), m.edge.push(e), e))),\r\n  m => {\r\n    const h = m.direction === 'horizontal'; let r\r\n    m._horizontal = h\r\n    const base = m._size[h ? 0 : 1] * 0.9\r\n    let nonbase = 0\r\n    const distance = 100\r\n    if (m.rankchanged) {\r\n      const nvs = [], evs = []; let gi = 0\r\n      for (const g of m.subgraph) {\r\n        const gvs = g.map(comp => ({ type: 'component', comp }))\r\n        for (let i = 0, l = g.length; i < l; i++) {\r\n          const n = g[i], [x, y] = n.layer\r\n          const b = base * x / Math.max(g.layer.length - 1, 1)\r\n          const nb = nonbase + (g.layer[x] / 2 - y) * 50\r\n          const p = h ? [b, nb] : [nb, b]\r\n          n.position = gvs[i].position = p\r\n          for (const e of n.to) {\r\n            if (e.virtualpoint) {\r\n              for (const vp of e.virtualpoint) {\r\n                const [x, y] = vp.layer\r\n                const b = base * x / Math.max(g.layer.length - 1, 1)\r\n                const nb = nonbase + (g.layer[x] / 2 - y) * 50\r\n                const p = h ? [b, nb] : [nb, b]\r\n                vp.position = p\r\n              }\r\n            } evs.push({ type: 'component', comp: e })\r\n            component.markdirty(e)\r\n          }\r\n        } nvs.push(...gvs); nonbase += distance; gi++\r\n      } nonbase = (m.subgraph.length - 1) * distance\r\n\r\n      m.rankchanged = m.graphmoded = false\r\n      r = { type: 'component', comp: { _view: [...evs, ...nvs] } }\r\n    } else { r = m._view ?? [] } r.position = h\r\n      ? [(m._size[0] - base) / 2, (m._size[1] - nonbase) / 2]\r\n      : [(m._size[0] - nonbase) / 2, (m._size[1] - base) / 2]\r\n    return r\r\n  })\r\nconst splitgraph = m => {\r\n  m.subgraph = []; let seen = new Set, sub = 0\r\n  for (let i = 0, l = m.node.length; i < l; i++) {\r\n    let n = m.node[i]; if (seen.has(n)) { continue }\r\n    const s = m.subgraph[sub++] = [], q = [n]\r\n    while (n = q.shift()) {\r\n      if (seen.has(n)) { continue } s.push(n), seen.add(n)\r\n      q.push(...n.to.map(e => e.to), ...n.from.map(e => e.from))\r\n    }\r\n  } m.subgraph = [m.subgraph[0]]\r\n}\r\nconst rankrd = grd.genrd()\r\nconst rankgraph = (m, l = 100) => {\r\n  const { rdi } = rankrd, { min, max } = Math\r\n  for (const g of m.subgraph) {\r\n    if (g.converged) { continue }\r\n    if (g.length <= 1) {\r\n      g[0].layer = [0, 0];\r\n      g.layer = [1];\r\n      g.converged = true;\r\n      continue\r\n    }\r\n    // TODO: filter more simple case like ring\r\n    const st = now()\r\n\r\n    for (let i = 0; i < l; i++) {\r\n      const q = [[g[rdi(g.length)], 0]], seen = new Set\r\n      while (q.length > 0) {\r\n        const [n, d] = q.splice(rdi(q.length), 1)[0]\r\n        if (seen.has(n)) { continue } seen.add(n)\r\n        n.ranksum += d, q.push(\r\n          ...n.to.map(e => [e.to, d - 1]),\r\n          ...n.from.map(e => [e.from, d + 1]))\r\n      }\r\n    }\r\n\r\n    let maxv = -Infinity, minv = Infinity\r\n    const round = 0.05, roundrev = 1 / round\r\n    let d = 0; for (const n of g) {\r\n      n.rankcount ??= 0, n.rankcount += l\r\n      n.oldrank = n.rawrank ??= 0\r\n      n.rawrank = Math.round(n.ranksum / n.rankcount * roundrev) * round\r\n      maxv = max(maxv, n.rawrank)\r\n      minv = min(minv, n.rawrank)\r\n      d += Math.abs(n.rawrank - n.oldrank)\r\n    } if (d < 0.001 * g.length) { g.converged = true }\r\n    const minmaxdiv = 1 / (maxv - minv)\r\n    for (const n of g) { n.rank = 1 - (n.rawrank - minv) * minmaxdiv }\r\n\r\n    const gs = [...g].sort((a, b) => a.rank - b.rank)\r\n    let layer = [[]], current = gs[0].rank, ci = 0\r\n    for (const n of gs) {\r\n      if (n.rank !== current) {\r\n        layer.push([]); ci++; current = n.rank\r\n      } n.layer = [ci, layer[ci].length]; layer[ci].push(n)\r\n    }\r\n\r\n    let n, seen = new Set; while (n = gs.shift()) {\r\n      if (seen.has(n)) { continue } seen.add(n)\r\n      for (const e of n.to) {\r\n        const to = e.to\r\n        const d = Math.abs(to.layer[0] - n.layer[0])\r\n        const s = Math.min(to.layer[0], n.layer[0])\r\n        if (d > 1) {\r\n          e.virtualpoint = []\r\n          for (let i = 1; i < d; i++) {\r\n            const j = i + s\r\n            const p = { layer: [j, layer[j].length], from: e.from }\r\n            e.virtualpoint.push(p)\r\n            layer[j].push(p)\r\n          }\r\n        } else { delete e.virtualpoint }\r\n      }\r\n    }\r\n\r\n    g.layer = layer.map(l => l.length)\r\n\r\n    const et = now()\r\n    // log(et - st)\r\n  } rankrd.next(), m.rankchanged = true\r\n\r\n}\r\nconst layoutgraph = m => {\r\n  if (m.graphmoded) { splitgraph(m) }\r\n  rankgraph(m)\r\n  component.markdirty(m)\r\n}\r\n\r\nconst size = 3\r\ncomponent.define('graph-node', { from: [], to: [], _size: [size, size] }, df => (\r\n  df('link', (m, t, e) => parent.link(m, t, e), false)\r\n), m => ({ type: 'rect', args: [-m._size[0] / 2, -m._size[1] / 2, ...m._size] }))\r\ncomponent.define('graph-edge', _, _, m => {\r\n  const a = m.from.position, b = m.to.position\r\n  const vp = (m.virtualpoint ?? []).map(vp => ['L', ...vp.position])\r\n  const args = [['M', ...a], ...vp, ['L', ...b]]\r\n  return { type: 'path', args }\r\n})\r\n\r\nconst g = component.create('graph')\r\ncomponent.root = g\r\n\r\n// const rgrd = grd.genrd(23545236)\r\n// const rgrd = grd.genrd(1027765915) // has a ring, don't converge\r\n// const rgrd = grd.genrd(1164806220)\r\nconst rgrd = grd.genrd(); log(rgrd.seed)\r\nconst randomgraph = (g, l = 300, ns = []) => {\r\n  for (let i = 0; i < l; i++) { ns.push(g.add()) }\r\n  for (let i = 0; i < l; i++) {\r\n    // const r = rgrd.rd() > 0.9 ? 2 : 1\r\n    const r = 1\r\n    const a = ns[i], s = [...ns]\r\n    for (let j = 0; j < r && s.length > 0; j++) {\r\n      g.link(a, s.splice(rgrd.rdi(s.length), 1)[0])\r\n    }\r\n  } rgrd.next()\r\n}\r\nrandomgraph(g)\r\nlog(g.node.length)\r\n// randomgraph(g)\r\n\r\n$.frame = () => {\r\n  layoutgraph(g)\r\n  component.frame()\r\n}"}