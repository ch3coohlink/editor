{"id":"8decaed74a95c44388a9175488b50c47b9d2fdbb5f8d08d7b80350cde42397c8","to":[],"value":"const _segmenter = new Intl.Segmenter(\"en\", { granularity: 'grapheme' })\r\nconst splitunicode = t => Array.from(_segmenter.segment(t), ({ segment }) => segment)\r\nconst drawglyph = g => {\r\n  ctx.beginPath()\r\n  for (const c of g.path.commands) {\r\n    switch (c.type) {\r\n      case 'M': ctx.moveTo(c.x, c.y); break\r\n      case 'L': ctx.lineTo(c.x, c.y); break\r\n      case 'Q': ctx.quadraticCurveTo(c.x1, c.y1, c.x, c.y); break\r\n      case 'C': ctx.bezierCurveTo(c.x1, c.y1, c.x2, c.y2, c.x, c.y); break\r\n      case 'Z': break\r\n      default: log(c); throw Error(`unknown path command type: ${c.type}`)\r\n    }\r\n  }\r\n  ctx.fill()\r\n}\r\nconst defaultglyph = fonts['consolas'].defaultglyph\r\nconst usingfonts = ['consolas', '思源黑体'].map(n => fonts[n]).filter(v => v)\r\nconst drawtext = (t, x, y, px = 10) => {\r\n  const a = splitunicode(t), s = px / 1000\r\n  ctx.save(); ctx.transform(s, 0, 0, -s, x, y)\r\n  for (const t of a) {\r\n    const c = t.charCodeAt(0); let usefont, g\r\n    for (const f of usingfonts) {\r\n      const i = f.tables.cmap.glyphIndexMap[c]\r\n      g = f.glyphs.glyphs[i]; if (g) { usefont = f; break }\r\n    } if (!g) { g = defaultglyph, usefont = fonts['consolas'] }\r\n    ctx.scale(usefont.scalefactor, usefont.scalefactor)\r\n    drawglyph(g); ctx.translate(g.advanceWidth, 0)\r\n    ctx.scale(usefont.scalefactordiv1, usefont.scalefactordiv1)\r\n  } ctx.restore()\r\n}"}