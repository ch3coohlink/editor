{"id":"7dd99e8b9c193239f3cafd80314ba0b655ffb28471b8c63b2e2185b34dd16fdc","to":[],"value":"Object.assign($, await require('lib/common.js'))\r\nconst grd = await require('lib/random.js')\r\nconsole.clear()\r\n\r\n$.framecount = 0\r\nconst loop = () => {\r\n  if ($.frame) { framecount++; frame() }\r\n  requestAnimationFrame(loop)\r\n}; requestAnimationFrame(loop)\r\n\r\nconst dom = (n = 'div') => document.createElement(n)\r\nconst svg = n => document.createElementNS('http://www.w3.org/2000/svg', n)\r\nconst svgtags = new Set(`a altGlyph altGlyphDef altGlyphItem\r\n  animate animateColor animateMotion animateTransform animation\r\n  audio canvas circle clipPath color-profile cursor defs desc discard\r\n  ellipse feBlend feColorMatrix feComponentTransfer feComposite\r\n  feConvolveMatrix feDiffuseLighting feDisplacementMap feDistantLight\r\n  feDropShadow feFlood feFuncA feFuncB feFuncG feFuncR feGaussianBlur\r\n  feImage feMerge feMergeNode feMorphology feOffset fePointLight\r\n  feSpecularLighting feSpotLight feTile feTurbulence filter font\r\n  font-face font-face-format font-face-name font-face-src font-face-uri\r\n  foreignObject g glyph glyphRef handler hkern iframe image line\r\n  linearGradient listener marker mask metadata missing-glyph mpath path\r\n  pattern polygon polyline prefetch radialGradient rect script set\r\n  solidColor stop style svg switch symbol tbreak text textArea textPath\r\n  title tref tspan unknown use video view vker`.split(/\\s+/))\r\n\r\n$.component = { globalenv: $ }; with (component) {\r\n  const $ = component\r\n  $.definition = {}\r\n  const cdae = n => Error(`component definition \"${n}\" already exists.`)\r\n  const cdne = n => Error(`component definition \"${n}\" not exists.`)\r\n  $.define = (name, model = {}, transition, view, extra = {}) => {\r\n    if (definition[name]) { throw adae(name) }\r\n    view = new Function('$', `with($) {\\nreturn ${view.toString()}\\n}`)(globalenv)\r\n    if (typeof model === 'function') { model = model() }\r\n    if (model.recordhistory) { model.history = [] }\r\n    model.type = name, model._iscomp = true\r\n    const t = {}; if (typeof transition === 'function') {\r\n      transition((n, f, history = true) => t[n] = new Function('$',\r\n        `with($) {\\nconst __f__ = ${f.toString()}\r\nconst __rf__ = function (...a) {\\nconst m = this, r = __f__(m, ...a)\r\n// TODO: a should be serialized since it could contain something like component\r\nif(${history} && m.recordhistory) { m.history.push([${n}, a]) }\\nreturn r\\n}\r\nreturn __rf__\\n}`)(globalenv))\r\n    }\r\n    definition[name] = { model, view, transition: t }\r\n    return (...a) => create(n, ...a)\r\n  }\r\n  $.create = (name, mod) => {\r\n    if (!definition[name]) { throw cdne(name) }\r\n    const d = definition[name], m = deepclone(d.model); m.id = grd.uuid()\r\n    Object.setPrototypeOf(m, d.transition) // TODO: not sure whether this is slow or not\r\n    if (typeof mod === 'function') { mod(m) }\r\n    m._view = d.view(m); render(m)\r\n    return m\r\n  }\r\n  $.render = c => {\r\n    const iscomp = c._iscomp\r\n    if (iscomp && !c._view) {\r\n      const d = definition[c.type]\r\n      if (!d) { throw cdne(c.type) }\r\n      c._view = d.view(c)\r\n    }\r\n    const v = iscomp ? c._view : c\r\n    if (!c._dom) {\r\n      c._dom = v._namespace !== 'dom'\r\n        && svgtags.has(v.type) ? svg(v.type) : dom(v.type)\r\n    }\r\n\r\n    const d = c._dom\r\n    const vcs = v.children ?? []\r\n    for (const cd of vcs) {\r\n      if (!cd._iscomp || !cd._dom) { render(cd, true) }\r\n      d.append(cd._dom)\r\n    } delete v.children\r\n\r\n    if (v.jsobj) for (const k of Object.keys(v.jsobj)) {\r\n      d[k] = v.jsobj[k]\r\n    } delete v.jsobj; delete v.type\r\n\r\n    for (const k of Object.keys(v)) {\r\n      if (k[0] === '_') { continue }\r\n      d.setAttribute(k, v[k])\r\n    }\r\n  }\r\n  let previoussize = [0, 0]\r\n  $.frame = () => {\r\n    const groot = globalenv.root\r\n    const rbcr = groot.getBoundingClientRect()\r\n    const size = [rbcr.width, rbcr.height]\r\n    if (!deepequal(size, previoussize)) { root._size = size; }\r\n    previoussize = size\r\n    if (groot.childNodes[0] !== root._dom) {\r\n      groot.insertBefore(root._dom, groot.childNodes[0])\r\n    }\r\n  }\r\n}\r\n\r\nroot.style.overflow = 'hidden'\r\n\r\n$.glrd = grd.genrd(6834652831)\r\n{\r\n  $.splitgraph = m => {\r\n    m.subgraph = []; let seen = new Set, sub = 0\r\n    for (let n of m.node) {\r\n      if (seen.has(n)) { continue }\r\n      const s = m.subgraph[sub++] = [], q = [n]\r\n      while (n = q.shift()) {\r\n        if (seen.has(n)) { continue } s.push(n), seen.add(n)\r\n        q.push(...[...n.to].map(e => e.to), ...[...n.from].map(e => e.from))\r\n      }\r\n    }\r\n    for (const n of m.node) {\r\n      n.acceleration ??= [0, 0], n.velocity ??= [0, 0]\r\n      n.position ??= [glrd.rd(-1, 1), glrd.rd(-1, 1)]\r\n      n.rank = n.ranksum = n.rankcount = 0\r\n    }\r\n    m.graphmoded = false\r\n    m.needlayout = true\r\n  }\r\n  const rankrd = grd.genrd(2462462542)\r\n  $.rankgraph = (m, l = 100) => {\r\n    const { rdi } = rankrd, { round, abs } = Math\r\n    for (const g of m.subgraph) {\r\n      if (g.converged) { continue }\r\n      if (g.length <= 1) { g[0].rank = 0; g.converged = true; continue }\r\n      for (let i = 0; i < l; i++) {\r\n        const q = [[g[rdi(g.length)], 0]], seen = new Set\r\n        while (q.length > 0) {\r\n          const [n, d] = q.splice(rdi(q.length), 1)[0]\r\n          if (seen.has(n)) { continue } seen.add(n)\r\n          n.ranksum += d, q.push(\r\n            ...[...n.to].map(e => [e.to, d - 1]),\r\n            ...[...n.from].map(e => [e.from, d + 1]))\r\n        }\r\n      }\r\n      let d = 0; for (const n of g) {\r\n        n.rankcount += l\r\n        n.oldrank = n.rank\r\n        n.rank = n.ranksum / n.rankcount\r\n        d += abs(n.rank - n.oldrank)\r\n      }\r\n      if (m.progressiveranking) {\r\n        if (d < 0.001 * g.length) { g.converged = true }\r\n      } else { g.converged = true }\r\n    } rankrd.next()\r\n\r\n  }\r\n  $.forcedirect = (m, step = 4) => {\r\n    const { sqrt, max, min } = Math\r\n    const gravity = { position: [0, 0], acceleration: [0, 0] }\r\n    const electric = (a, b, p, minl = 1) => {\r\n      const pdx = b.position[0] - a.position[0]\r\n      const pdy = b.position[1] - a.position[1]\r\n      const lsq = max(pdx * pdx + pdy * pdy, minl)\r\n      const l = sqrt(lsq), f = p / (lsq * l)\r\n      const fx = f * pdx, fy = f * pdy\r\n      a.acceleration[0] += fx, a.acceleration[1] += fy\r\n      b.acceleration[0] -= fx, b.acceleration[1] -= fy\r\n    }, distance = (a, b, p) => {\r\n      const pdx = b.position[0] - a.position[0]\r\n      const pdy = b.position[1] - a.position[1]\r\n      const fx = p * pdx, fy = p * pdy\r\n      a.acceleration[0] += fx, a.acceleration[1] += fy\r\n      b.acceleration[0] -= fx, b.acceleration[1] -= fy\r\n    }, friction = 0.01, dt = 0.05\r\n    const tl = m.target_length, ts = tl * 2\r\n    const pe = -ts * tl ** 2, pd = ts * 20 / tl, pg = 0.05 * pd\r\n    const h = m.direction === 'horizontal' ? 0 : 1\r\n    const g = m.subgraph.flat(1)\r\n    for (let i = 0; i < step; i++) {\r\n      let total_speed = 0\r\n      for (let i = 0, l = g.length; i < l; i++) {\r\n        const n = g[i], nto = 1 / n.to.size\r\n        for (let j = i + 1; j < l; j++) { electric(n, g[j], pe) }\r\n        for (const { to } of n.to) { distance(n, to, pd * nto) }\r\n        if (n.hardlock) { n.velocity[0] = n.velocity[1] = 0; continue }\r\n        n.acceleration[h] -= n.rank * tl * 10\r\n        distance(n, gravity, pg)\r\n        const vx = n.velocity[0] + n.acceleration[0] * dt\r\n        const vy = n.velocity[1] + n.acceleration[1] * dt\r\n        let v = sqrt(vx * vx + vy * vy), vrx = vx / v, vry = vy / v\r\n        total_speed += v = max(min(v, ts) - ts * friction, 0)\r\n        if (n.lock) { n.velocity[0] = n.velocity[1] = 0; continue }\r\n        n.position[0] += (n.velocity[0] = vrx * v) * dt\r\n        n.position[1] += (n.velocity[1] = vry * v) * dt\r\n        n.acceleration[0] = n.acceleration[1] = 0\r\n      } m.total_speed = total_speed\r\n    }\r\n  }\r\n  $.randomgraph = (g, a = 50, b = 100, l = rgrd.rdi(a, b), ns = []) => {\r\n    for (let i = 0; i < l; i++) { ns.push(g.add(component.create('text-editor'))) }\r\n    for (let i = 0; i < l; i++) {\r\n      // const r = rgrd.rd() > 0.8 ? 2 : 1\r\n      // const r = 2\r\n      const r = 1\r\n      const a = ns[i], s = [...ns]\r\n      for (let j = 0; j < r && s.length > 0; j++) {\r\n        g.link(a, s.splice(rgrd.rdi(s.length), 1)[0])\r\n      }\r\n    } rgrd.next()\r\n  }\r\n}\r\n\r\n{\r\n  const { max, min } = Math; $.clamp = (v, s, l) => max(min(v, l), s)\r\n  $.itp = (a, b, t) => (t = clamp(t, 0, 1), a + t * (b - a))\r\n  $.itp3 = (a, b, t) => (t = clamp(t, 0, 1),\r\n    [a[0] + t * (b[0] - a[0]), a[1] + t * (b[1] - a[1]), a[2] + t * (b[2] - a[2])])\r\n\r\n  $.dragprocess = (move, cancel) => {\r\n    const c = e => (off('pointermove', mi),\r\n      off('pointerup', ui), off('pointercancel', ci), cancel?.(e))\r\n    const mi = on('pointermove', e => move(e))\r\n    const ui = on('pointerup', c)\r\n    const ci = on('pointercancel', c)\r\n  }\r\n  $.expdecay = (a, b, d, dt) => b + (a - b) * Math.exp(-d * dt)\r\n  $.callhotkey = (m, k, e) => {\r\n    while (m) {\r\n      if (m._hotkey[k]) {\r\n        return m._hotkey[k]?.(e)\r\n      } m = m.parent\r\n    }\r\n  }\r\n  $.formatkeyevent = (e, up) => e.key.toLowerCase() + (up ? 'up' : [\r\n    e.altKey, e.ctrlKey, e.shiftKey].map(v => v ? 't' : 'f').join(''))\r\n}\r\n\r\ncomponent.define('graph', {\r\n  direction: 'vertical', subgraph: [],\r\n  target_length: 50, node: new Set,\r\n  camera: [1, 0, 0], realcameravalue: [1, 0, 0],\r\n  color: [90, 90, 90], focuscolor: '#0087ff',\r\n  zoomfactor: 1.2,\r\n}, df => {\r\n  df('add', (m, d) => {\r\n    const n = component.create('graph-node', n => (\r\n      n.parent = m, n.data = d, n.ranksum = 0, n.rankcount = 0))\r\n    m.graphmoded = true, m.node.add(n)\r\n    m._vnode._dom.append(n._dom)\r\n    m._resizewatcher.observe(n._foreign._dom)\r\n    return n\r\n  })\r\n  df('del', (m, n) => {\r\n    m.graphmoded = true, m.node.delete(n)\r\n    n._dom.remove()\r\n    m._resizewatcher.observe(n._foreign._dom)\r\n    for (const e of n.to) { m.unlink(e) }\r\n    for (const e of n.from) { m.unlink(e) }\r\n  })\r\n  df('link', (m, a, b, d) => {\r\n    const e = component.create('graph-edge', e => (\r\n      e.parent = m, e.from = a, e.to = b, e.data = d))\r\n    m.graphmoded = true, a.to.add(e), b.from.add(e)\r\n    m._vedge._dom.append(e._dom)\r\n    return e\r\n  })\r\n  df('unlink', (m, e) => {\r\n    m.graphmoded = true\r\n    e.from.from.delete(e)\r\n    e.to.to.delete(e)\r\n    e._dom.remove()\r\n  })\r\n  df('offsetcoord', (m, e, r = m._dom.getBoundingClientRect()) =>\r\n    [e.pageX - r.left, e.pageY - r.top])\r\n  df('graphcoord', (m, e, cx = m.camera[1], cy = m.camera[2]) => {\r\n    const [x, y] = m.offsetcoord(e)\r\n    const { clientWidth: w, clientHeight: h } = m._dom\r\n    return [(x - cx) / m.camera[0] - w / 2,\r\n    (y - cy) / m.camera[0] - h / 2]\r\n  })\r\n  df('zoom', (m, e, r) => {\r\n    let [x, y] = Array.isArray(e) ? e : m.offsetcoord(e)\r\n    const { clientWidth: w, clientHeight: h } = m._dom\r\n    if (!Array.isArray(e)) { x -= w / 2; y -= h / 2 }\r\n    m.camera[0] *= r // equation: y - nsy === (y - sy) * r\r\n    m.camera[1] = x - (x - m.camera[1]) * r\r\n    m.camera[2] = y - (y - m.camera[2]) * r\r\n  })\r\n  df('updatecamera', (m, dt) => {\r\n    if (m.focusnode) {\r\n      [m.camera[1], m.camera[2]] = m.focusnode.center.map(v => -v * m.camera[0])\r\n    } const camera = [...m.camera]\r\n    if (m._movetarget) {\r\n      let mx = -Infinity, my = -Infinity, { abs } = Math\r\n      const a = m.focusnode ? m.focusnode.center : m.cameraposition()\r\n      for (const n of Object.values(m._movetarget).concat(m._previewmove)) {\r\n        if (!n) { continue } let v\r\n        v = abs(n.position[0] - a[0]); if (v > mx) { mx = v }\r\n        v = abs(n.position[1] - a[1]); if (v > my) { my = v }\r\n      } let { clientWidth: w, clientHeight: h } = m._dom\r\n      const ox = mx * m.camera[0] > (w *= .4)\r\n      const oy = my * m.camera[0] > (h *= .4)\r\n      camera[0] = ox || oy ? Math.min(w / mx, h / my) : camera[0]\r\n      camera[1] = -a[0] * camera[0]\r\n      camera[2] = -a[1] * camera[0]\r\n    }\r\n    m.realcameravalue = camera.map((v, i) =>\r\n      expdecay(m.realcameravalue[i], v, 16, dt))\r\n\r\n    const [s, x, y] = m.realcameravalue\r\n    m._canvas._dom.style.transform = `translate(50%, 50%) ` +\r\n      `translate(${x + 'px'}, ${y + 'px'}) scale(${s})`\r\n  })\r\n  df('frame', (m, dt) => {\r\n    m.updatecamera(dt)\r\n    if (m.graphmoded) { splitgraph(m) }\r\n    if (m.needlayout) {\r\n      for (const n of m.node) {\r\n        const d = n._foreign._dom\r\n        n.size = [d.clientWidth, d.clientHeight]\r\n      }\r\n      rankgraph(m, 100), forcedirect(m, 4)\r\n      if (m.total_speed <= 0) { m.needlayout = false }\r\n\r\n      const h = m.direction === 'horizontal'\r\n      for (const n of m.node) {\r\n        const x = n.position[0] - n.size[0] / 2\r\n        const y = n.position[1] - 5\r\n        n.center = [n.position[0], y + n.size[1] / 2]\r\n        n._dom.style.transform = `translate(${[x + 'px', y + 'px'].join(', ')})`\r\n        for (const e of n.to) {\r\n          const s = 0.6, c = 10\r\n          const a = e.from.position, b = e.to.position\r\n          if (a === b) {\r\n            const r = 20, r2 = r * 2, x = a[0], y = a[1]\r\n            e._dom.setAttribute('d', `M ${x + r} ${y} m ${r} 0 ` +\r\n              `a ${r},${r} 0 1,0 ${-r2}, 0 a ${r},${r} 0 1,0 ${r2}, 0 ` +\r\n              `M ${x + r2 + c} ${y + c} L ${x + r2} ${y} L ${x + r2 - c} ${y + c}`)\r\n          } else {\r\n            let dx = b[0] - a[0], dy = b[1] - a[1]\r\n            const mx = a[0] + dx * s, my = a[1] + dy * s\r\n            const l = 1 / Math.sqrt(dx * dx + dy * dy); dx *= l, dy *= l\r\n            const cl = itp3(m.color, [256, ...m.color.slice(1)], -(h ? dx : dy) + 0.5)\r\n            e._dom.setAttribute('stroke', `rgb(${cl.join(', ')})`)\r\n            dx *= c, dy *= c, e._dom.setAttribute('d', ['M', ...a, 'L', ...b,\r\n              'M', mx + dy, my - dx, 'L', mx + dx, my + dy, 'L', mx - dy, my + dx].join(' '))\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // TODO: render focusnode edge\r\n    // TODO: render virtual edge\r\n    if (m.focusnode) {\r\n    }\r\n  })\r\n  df('getmovetarget', m => {\r\n    const a = m._previewmove ? m._previewmove.position :\r\n      m.focusnode ? m.focusnode.position : m.cameraposition()\r\n    let i = 0, mvup = i, mvdw = i, mvlf = i, mvrt = i\r\n    const maxnode = {}; for (const n of m.node) {\r\n      const dx = n.position[0] - a[0], dy = n.position[1] - a[1]\r\n      let l = Math.sqrt(dx * dx + dy * dy), ld = 1 / l, lp = 1 - l / 500\r\n      const dup = dy * -ld, ddw = dy * ld, dlf = dx * -ld, drt = dx * ld\r\n      if (dup > 0) { v = lp + dup; if (mvup < v) { mvup = v; maxnode.up = n } }\r\n      if (ddw > 0) { v = lp + ddw; if (mvdw < v) { mvdw = v; maxnode.dw = n } }\r\n      if (dlf > 0) { v = lp + dlf; if (mvlf < v) { mvlf = v; maxnode.lf = n } }\r\n      if (drt > 0) { v = lp + drt; if (mvrt < v) { mvrt = v; maxnode.rt = n } }\r\n    } m._movetarget = maxnode\r\n  })\r\n  df('updatemove', (m, _, d) => {\r\n    let n; if (m._movetarget) {\r\n      for (const k in m._movetarget) if (n = m._movetarget[k]) {\r\n        n.settitle(''); n.resetcolor()\r\n      } if (m._previewmove) { m._previewmove.resetcolor() }\r\n      if (d) { m._previewmove = m._movetarget[d] }\r\n    }\r\n    if (m.focusnode) { m.focusnode.setcolor(m.focuscolor) }\r\n    if (!m._moving) {\r\n      if (m._previewmove) { m._previewmove.focus() }\r\n      m._movetarget = m._previewmove = undefined; return\r\n    } m.getmovetarget()\r\n    for (const k in m._movetarget) if (n = m._movetarget[k]) {\r\n      switch (k) {\r\n        case 'up': n.settitle('↑'); break\r\n        case 'dw': n.settitle('↓'); break\r\n        case 'lf': n.settitle('←'); break\r\n        case 'rt': n.settitle('→'); break\r\n      } n.setcolor('#c8ff17')\r\n    } if (m._previewmove) { m._previewmove.setcolor('#aa33bb') }\r\n  })\r\n  df('startmove', m => m._moving || m._forceleavemove\r\n    ? 0 : m.updatemove(m._moving = true))\r\n  df('move', (m, d) => m.updatemove(m._moving = true, d))\r\n  df('endmove', m => {\r\n    m.updatemove(m._moving = false)\r\n    m._forceleavemove = false\r\n  })\r\n  df('quitmove', m => {\r\n    const n = m.focusnode\r\n    m.updatemove(m._moving = false)\r\n    m._forceleavemove = true; (n ? n : m).focus()\r\n  })\r\n  df('focus', m => m._dom.focus())\r\n  df('blur', m => m._dom.blur())\r\n  df('createorconnect', (m, n) => {\r\n    if (m._connectmode) {\r\n      // TODO\r\n    } else {\r\n      const nn = m.add(component.create('text-editor'))\r\n      m.link(nn); nn.position = n.position.map(v => v + glrd.rd(-1, 1))\r\n    }\r\n  })\r\n  df('setconnectmode', (m, n) => {\r\n    // TODO\r\n    if (m._connectmode) { }\r\n    else { }\r\n  })\r\n  df('loadjson', m => {\r\n    // TODO\r\n  })\r\n  df('tojson', m => {\r\n    // TODO\r\n  })\r\n  df('cameraposition', m => [-m.camera[1] / m.camera[0], -m.camera[2] / m.camera[0]])\r\n  df('callhotkey', callhotkey)\r\n}, m => (m._resizewatcher = new ResizeObserver(() => m.needlayout = true),\r\n  m._hotkey = {\r\n    ntff: () => {\r\n      const n = m.add(component.create('text-editor'))\r\n      n.position = m.cameraposition()\r\n      // TODO: focus on new create node\r\n    },\r\n    alttff: () => m.startmove(), altup: () => m.endmove(),\r\n    utff: () => m.quitmove(),\r\n    ytff: () => m.zoom([0, 0], m.zoomfactor),\r\n    htff: () => m.zoom([0, 0], 1 / m.zoomfactor),\r\n    itff: () => m.move('up'), ktff: () => m.move('dw'),\r\n    jtff: () => m.move('lf'), ltff: () => m.move('rt'),\r\n    otff: () => m.camera = [1, 0, 0],\r\n    ptff: () => (m.needlayout = true, m.direction =\r\n      m.direction === 'horizontal' ? 'vertical' : 'horizontal'),\r\n  }, {\r\n  type: 'svg', jsobj: {\r\n    onwheel: (e, r = m.zoomfactor) => (\r\n      m.zoom(e, e.deltaY < 0 ? r : 1 / r), e.preventDefault()),\r\n    onpointerdown: e => {\r\n      if (e.target !== m._dom) { return }\r\n      const cx = m.camera[1], cy = m.camera[2]\r\n      const o = m.graphcoord(e, cx, cy)\r\n      dragprocess(e => {\r\n        const [x, y] = m.graphcoord(e, cx, cy)\r\n        m.camera[1] = cx + (x - o[0]) * m.camera[0]\r\n        m.camera[2] = cy + (y - o[1]) * m.camera[0]\r\n      })\r\n    },\r\n    onfocus: () => m._dom.style.boxShadow = m.focuscolor + '88 0px 0px 20px inset',\r\n    onblur: () => m._dom.style.boxShadow = '',\r\n    onkeydown: e => {\r\n      if (e.target !== m._dom) { return }\r\n      e.preventDefault(), e.stopImmediatePropagation()\r\n      m.callhotkey(formatkeyevent(e), e)\r\n    },\r\n    onkeyup: e => {\r\n      if (e.target !== m._dom) { return }\r\n      e.preventDefault(), e.stopImmediatePropagation()\r\n      m.callhotkey(formatkeyevent(e, true), e)\r\n    },\r\n  }, children: [m._canvas = {\r\n    type: 'g', children: [m._vedge = {\r\n      type: 'g', children: [...m.node].map(n => [...n.to]).flat(1),\r\n      filter: 'drop-shadow(0 2px 2px #00000055)'\r\n    }, m._vnode = { type: 'g', children: [...m.node] }],\r\n    stroke: `rgb(${m.color.join(', ')})`, 'stroke-width': '1px',\r\n    fill: 'none', 'stroke-linecap': 'round',\r\n  }], 'tab-index': 1, style: `outline: none;\r\n    width:100%; height:100%;user-select:none; cursor: grab;\r\n    transition: box-shadow 0.3s;\r\n    background: #fafafa;` }))\r\n\r\n// graph-node ===========================================================\r\ncomponent.define('graph-node', { from: new Set, to: new Set }, df => {\r\n  df('link', (m, t, e) => m.parent.link(m, t, e))\r\n  df('unlink', (m, t) => m.parent.unlink(m.to.get(t)))\r\n  df('del', m => m.parent.del(m))\r\n  df('setcolor', (m, c) => {\r\n    m._foreign._dom.style.boxShadow = c + '44' + ' 0px 4px 10px'\r\n    m._dragsign._dom.setAttribute('stroke', c)\r\n    // m._title._dom.setAttribute('fill', c)\r\n  })\r\n  df('resetcolor', (m, c) => {\r\n    m._foreign._dom.setAttribute('style', m._foreign.style)\r\n    m._dragsign._dom.setAttribute('stroke', m._dragsigncolor)\r\n    m._title._dom.setAttribute('fill', m._dragsigncolor)\r\n  })\r\n  df('focus', m => (m.setcolor(m.parent.focuscolor),\r\n    m.parent.focusnode = m, m.data.focus?.()))\r\n  df('blur', m => (m.resetcolor(),\r\n    m.parent.focusnode = _, m.data.blur?.()))\r\n  df('callhotkey', callhotkey)\r\n  df('settitle', (m, t) => {\r\n    m._title._dom.textContent = t\r\n    const w = m._title._dom.getBBox().width\r\n    m._title._dom.style.transform =\r\n      `translate(calc(50% - ${w / 2}px), calc(50% - 10px))`\r\n  })\r\n  df('quitconnectmode', m => m.parent.setconnectmode(m))\r\n}, m => (m.data.parent = m, m._hotkey = {\r\n  ntff: () => m.parent.createorconnect(m),\r\n  deletetft: () => m.del(),\r\n  escapefff: () => m.parent.focus(),\r\n}, m._dragsigncolor = '#666', {\r\n  type: 'foreignObject', style: `overflow:visible;width:1px;height:1px;`,\r\n  children: [m._foreign = {\r\n    type: 'div', children: [{\r\n      type: 'svg', children: [m._dragsign = {\r\n        type: 'path', d: 'M -10 0 L 10 0',\r\n        'stroke-width': '2', stroke: m._dragsigncolor,\r\n        'stroke-linecap': 'round',\r\n        style: `transform:translate(50%, 50%);`\r\n      }, m._title = { type: 'text', stroke: 'none', fill: m._dragsigncolor }],\r\n      style: `width: 100%; height: 10px;\r\n      display: block; cursor: pointer;overflow: visible;` }, {\r\n      type: 'div', children: [m.data], style: `\r\n      padding: 10px; padding-top: 0;` }],\r\n    jsobj: { onclick: () => m.data.focus?.() },\r\n    style: `box-shadow: #00000044 0px 4px 10px;\r\n    backdrop-filter: blur(1px); cursor: initial;\r\n    color: #333; transition: box-shadow 0.3s;\r\n    background: linear-gradient(12deg, #0000001f, #00000010);\r\n    min-width: 100px; max-width: 50vw; width: fit-content;\r\n    border-radius: 10px;` }]\r\n}))\r\ncomponent.define('graph-edge', _, _, _ => ({ type: 'path' }))\r\n\r\n$.te_keyfilter = new Set('axcv'.split('').map(n => n + 'ftf'))\r\ncomponent.define('text-editor', _, df => {\r\n  df('focus', m => m._dom.focus())\r\n  df('blur', m => m._dom.blur())\r\n}, m => ({\r\n  type: 'div', contentEditable: true, jsobj: {\r\n    onkeydown: (e, k = formatkeyevent(e)) => {\r\n      e.stopImmediatePropagation()\r\n      if (k.slice(-3) !== 'fff') {\r\n        if (!te_keyfilter.has(k)) { e.preventDefault() }\r\n      } else if (k === 'tabfff') { e.preventDefault() }\r\n      m.parent.callhotkey(k, e)\r\n    },\r\n    onkeyup: e => (e.stopImmediatePropagation(),\r\n      m.parent.callhotkey(formatkeyevent(e, true), e)),\r\n    onfocus: () => m.parent.focus(),\r\n    onblur: () => m.parent.blur(),\r\n  }, class: 'text-editor', style: `outline: none;\r\n    overflow: hidden;\r\n    white-space: pre; overflow-wrap: anywhere;` }))\r\n\r\nconst gstyle = dom('style')\r\ngstyle.innerHTML = `\r\ndiv.text-editor * {\r\n  text-wrap: inherit !important;\r\n}`; root.append(gstyle)\r\n\r\nconst g = component.create('graph', m => m.target_length = 150)\r\ncomponent.root = g\r\n\r\n// const rgrd = grd.genrd(3703646480)\r\nconst rgrd = grd.genrd()\r\nrandomgraph(g, 50, 100)\r\nrandomgraph(g, 50, 100)\r\n\r\nlet pt = now()\r\n$.frame = () => {\r\n  const t = now(), dt = t - pt; pt = t\r\n  g.frame(dt)\r\n  component.frame()\r\n}"}