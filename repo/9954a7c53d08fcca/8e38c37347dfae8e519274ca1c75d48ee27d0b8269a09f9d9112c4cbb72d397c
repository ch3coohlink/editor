{"id":"8e38c37347dfae8e519274ca1c75d48ee27d0b8269a09f9d9112c4cbb72d397c","to":[],"value":"const jsmime = 'application/javascript'\r\nconst bootworker = (src, url) => {\r\n  url ??= URL.createObjectURL(new Blob([src], { type: jsmime }))\r\n  return new Worker(url)\r\n}\r\nconst loadsrc = async (p, type = jsmime) => {\r\n  let [ver, path, src] = await readlocal(p, { raw: true, watch: true })\r\n  if (type === jsmime) {\r\n    src = `//# sourceURL=${ver.slice(0, 16) + '/' + path}\\n` + src\r\n  } return URL.createObjectURL(new Blob([src], { type }))\r\n}\r\n\r\nconst w = bootworker(undefined, await loadsrc('./worker.js'))\r\nconst send = (t, o, a) => {\r\n  if (Array.isArray(o)) { o = { a: o, isarr: true } }\r\n  w.postMessage((o.type = t, o), a)\r\n}\r\n\r\nlet canvasrequested = false\r\nconst requestcanvas = o => {\r\n  const id = $$.uuid(16)\r\n  const cvs = document.createElement('canvas')\r\n  cvs.style.imageRendering = 'pixelated'\r\n  cvs.style.width = cvs.style.height = '100%'\r\n  root.append(cvs)\r\n\r\n  cvs.addEventListener('keydown', e =>\r\n    send('objevent', { id, eventtype: 'keydown', e: keyboardevent(e) }))\r\n  cvs.addEventListener('keyup', e =>\r\n    send('objevent', { id, eventtype: 'keyup', e: keyboardevent(e) }))\r\n  pointerevents.forEach(n => cvs.addEventListener(n, e =>\r\n    send('objevent', { id, eventtype: n, e: pointerevent(e, mouseevent(e)) })))\r\n\r\n  const resize = () => {\r\n    let changed = false\r\n    const w = root.clientWidth, h = root.clientHeight\r\n    const r = window.devicePixelRatio\r\n    const wr = Math.floor(w * r), hr = Math.floor(h * r)\r\n    if (cvs.width !== wr) { changed = true }\r\n    if (cvs.height !== hr) { changed = true }\r\n    cvs.style.width = (wr / r) + 'px'\r\n    cvs.style.height = (hr / r) + 'px'\r\n    if (changed) { send('canvasresize', { w: wr, h: hr, dpi: r }) }\r\n  }; {\r\n    const w = root.clientWidth, h = root.clientHeight\r\n    const r = window.devicePixelRatio\r\n    const wr = Math.floor(w * r), hr = Math.floor(h * r)\r\n    if (cvs.width !== wr) { cvs.width = wr }\r\n    if (cvs.height !== hr) { cvs.height = hr }\r\n    cvs.style.width = (wr / r) + 'px'\r\n    cvs.style.height = (hr / r) + 'px'\r\n  } new ResizeObserver(resize).observe(root)\r\n  const offcvs = cvs.transferControlToOffscreen()\r\n  canvasrequested = true\r\n  return { r: { offcvs, id }, __transfer__: [offcvs] }\r\n}\r\n\r\nconst requestdpi = () => window.devicePixelRatio\r\n\r\nconst fs = '$function$', vfs = '$voidfunction$'\r\nw.addEventListener('message', async e => {\r\n  let o = e.data; if (o.isarr) { o.a.type = o.type; o = o.a }\r\n  if (o.type.startsWith(fs)) {\r\n    const fn = o.type.slice(fs.length)\r\n    const r = await (eval(fn)(...o))\r\n    if (!r?.__transfer__) { send('callfin', { r, id: o.id }) }\r\n    else { send('callfin', { r: r.r, id: o.id }, r.__transfer__) }\r\n  } else if (o.type.startsWith(vfs)) {\r\n    const fn = o.type.slice(vfs.length)\r\n    await (eval(fn)(...o))\r\n  } else if (o.type === 'heartbeat') {\r\n    alive = performance.now()\r\n    resetlight()\r\n  } else { throw Error(`unknown type: ${o.type}`) }\r\n})\r\n\r\n$.loadworker = async p =>\r\n  send('init', await read(p, { raw: true, watch: true }))\r\n\r\nconst pointerevents = 'cancel down up enter leave move out over rawupdate'\r\n  .split(' ').map(n => 'pointer' + n)\r\npointerevents.forEach(n => on(n, e => send('event',\r\n  { eventtype: n, e: pointerevent(e, mouseevent(e)) })))\r\nconst mouseevent = (e, o = {}) => (\r\n  o.altKey = e.altKey,\r\n  o.button = e.button,\r\n  o.buttons = e.buttons,\r\n  o.clientX = e.clientX,\r\n  o.clientY = e.clientY,\r\n  o.ctrlKey = e.ctrlKey,\r\n  o.metaKey = e.metaKey,\r\n  o.movementX = e.movementX,\r\n  o.movementY = e.movementY,\r\n  o.offsetX = e.offsetX,\r\n  o.offsetY = e.offsetY,\r\n  o.pageX = e.pageX,\r\n  o.pageY = e.pageY,\r\n  o.screenX = e.screenX,\r\n  o.screenY = e.screenY,\r\n  o.shiftKey = e.shiftKey,\r\n  o.x = e.x,\r\n  o.y = e.y, o)\r\nconst pointerevent = (e, o = {}) => (\r\n  o.altitudeAngle = e.altitudeAngle,\r\n  o.azimuthAngle = e.azimuthAngle,\r\n  o.height = e.height,\r\n  o.isPrimary = e.isPrimary,\r\n  o.pointerId = e.pointerId,\r\n  o.pointerType = e.pointerType,\r\n  o.pressure = e.pressure,\r\n  o.tangentialPressure = e.tangentialPressure,\r\n  o.tiltX = e.tiltX,\r\n  o.tiltY = e.tiltY,\r\n  o.twist = e.twist,\r\n  o.width = e.width, o)\r\nconst keyboardevent = (e, o = {}) => (\r\n  o.altKey = e.altKey,\r\n  o.charCode = e.charCode,\r\n  o.code = e.code,\r\n  o.ctrlKey = e.ctrlKey,\r\n  o.isComposing = e.isComposing,\r\n  o.key = e.key,\r\n  o.keyCode = e.keyCode,\r\n  o.keyIdentifier = e.keyIdentifier,\r\n  o.location = e.location,\r\n  o.metaKey = e.metaKey,\r\n  o.repeat = e.repeat,\r\n  o.shiftKey = e.shiftKey, o)\r\n\r\n\r\nlet alive = performance.now()\r\nconst light = document.createElement('div')\r\nconst resetlight = () => {\r\n  light.textContent = 'ðŸŸ¢'\r\n  light.style.position = 'absolute'\r\n  light.style.top = '-100px'\r\n  light.style.right = '-100px'\r\n  light.style.transition = 'all 0.2s'\r\n}; resetlight()\r\nsetInterval(() => {\r\n  if (alive + 1100 < performance.now()) {\r\n    light.textContent = 'ðŸ”´'\r\n    light.style.top = '0px'\r\n    light.style.right = '0px'\r\n  }\r\n}, 1000)\r\nroot.style.overflow = 'hidden'\r\nroot.style.position = 'relative'\r\nroot.append(light)"}