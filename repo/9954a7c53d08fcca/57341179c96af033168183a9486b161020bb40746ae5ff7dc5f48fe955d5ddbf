{"id":"57341179c96af033168183a9486b161020bb40746ae5ff7dc5f48fe955d5ddbf","to":[],"value":"Object.assign($, await require('lib/common.js'))\r\nconst grd = await require('lib/random.js')\r\n\r\nconst cdae = n => Error(`component definition \"${n}\" already exists.`)\r\nconst cdne = n => Error(`component definition \"${n}\" not exists.`)\r\nconst getctx = (m, n) => {\r\n  while (m = m.parent) if (m._ctx && m._ctx === n) { return m }\r\n}\r\nconst animation = (m, tag,) => { }\r\n$.component = { globalenv: $ }; with (component) {\r\n  const $ = component; $.definition = {}\r\n  $.define = (name, init, tf, view, extra = {}) => {\r\n    if (definition[name]) { throw cdae(name) }\r\n    const f = function C(...a) {\r\n      init?.(this, ...a); this.id = grd.uuid()\r\n      if (extra.history) { this.history = [] } return this\r\n    }, p = f.prototype; p.type = name; p._iscomp = true\r\n    Object.defineProperty(f, 'name', { value: name })\r\n    const df = (n, f, history = true) => p[n] = function (...a) {\r\n      const m = this, r = f(m, ...a)\r\n      // TODO: a should be serialized since it could contain something like component\r\n      if (history && m.recordhistory) { m.history.push([n, a]) } return r\r\n    }; df('getctx', getctx)\r\n    if (typeof tf === 'function') { tf(df) }\r\n    Object.assign(p, extra.static ?? {})\r\n    definition[name] = { view, create: f }\r\n  }\r\n  $.create = (name, mod, ...a) => {\r\n    if (!definition[name]) { throw cdne(name) }\r\n    const m = new definition[name].create(...a)\r\n    switch (typeof mod) {\r\n      case 'function': mod(m); break\r\n      case 'object': Object.assign(m, mod); break\r\n    } render(m); return m\r\n  }\r\n  const ar = m => {\r\n    if (!m._view) { return }\r\n    m._view.classList.add(m.type)\r\n    m._view._comp = m\r\n    m.afterrender?.()\r\n  }\r\n  $.render = (m, force = false) => {\r\n    if (force || !m._view) {\r\n      const d = definition[m.type]\r\n      if (!d) { throw cdne(m.type) }\r\n      if (typeof d.view !== 'function') { return } try {\r\n        m.beforerender?.(); m._view = d.view(m)\r\n        if (m._view instanceof Promise) {\r\n          m._view.then(v => { m._view = v; ar(m) })\r\n        } else { ar(m) }\r\n      } catch { }\r\n    } return m._view\r\n  }\r\n  $.rerender = (m, ov = m._view) => (ov.replaceWith(render(m, 1)), m._view)\r\n  $.rebuild = changed => {\r\n    if (!root) { return }\r\n    let q = [root._view], v; while (v = q.pop()) {\r\n      const c = v._comp; if (c) {\r\n        const t = c.type, d = definition[t]\r\n        if (changed.reload.has(t)) { return true }\r\n        if (changed.view.has(t)) { v = rerender(c) }\r\n      } for (const e of v.childNodes) { q.push(e) }\r\n    }\r\n  }\r\n  $.spkey = 'ยง'\r\n  $.frompod = d => {\r\n    const a2o = (m, o = {}) => (\r\n      Object.keys(m).forEach(k => {\r\n        const v = rf(m[k]); if (v[spkey] !== 'ref') { o[k] = v }\r\n        else { refq.push(['ref', o, k, v.id]) }\r\n      }), o)\r\n    const a2a = (m, o = []) => (\r\n      m.forEach((m, i) => {\r\n        const v = rf(m); if (v[spkey] !== 'ref') { o.push(v) }\r\n        else { refq.push(['ref', o, i, v.id]) }\r\n      }), o)\r\n    const a2set = (m, o = new Set) => {\r\n      for (let v of m) {\r\n        v = rf(v); if (v[spkey] !== 'ref') { o.add(v) }\r\n        else { refq.push(['set', o, v.id]) }\r\n      } return o\r\n    }\r\n    const a2map = (m, o = new Map) => {\r\n      for (let [k, v] of m) {\r\n        k = rf(k), v = rf(v)\r\n        if (k[spkey] !== 'ref' && v[spkey] !== 'ref') { o.set(k, v) }\r\n        else { refq.push(['map', o, k, v]) }\r\n      } return o\r\n    }\r\n    const ra = {}, refq = [], rf = m => {\r\n      if (typeof m !== 'object') { return m }\r\n      if (m instanceof Array) { return a2a(m) }\r\n      const sk = m[spkey]; if (!sk) { return a2o(m) }\r\n      switch (sk) {\r\n        case 'exk': return Object.assign(rf(m.v), a2o(m.k))\r\n        case 'ref': return { [spkey]: 'ref', id: m.v }\r\n        case 'set': return a2set(m.v)\r\n        case 'map': return a2map(m.v)\r\n        default: throw Error(`invalid spkey \"${sk}\"`)\r\n      }\r\n    }\r\n    let ds; for (const type in d) for (const id in ds = d[type]) {\r\n      const o = rf(ds[id]); if (!o) { continue }\r\n      o.type = type, o.id = id, ra[id] = o\r\n    }\r\n    for (const [t, o, k, v] of refq) switch (t) {\r\n      case 'set': o.add(ra[k]); break\r\n      case 'map': o.set(\r\n        k[spkey] === 'ref' ? ra[k.id] : k,\r\n        v[spkey] = 'ref' ? ra[v.id] : v); break\r\n      case 'ref': o[k] = ra[v]; break\r\n      default: throw Error(`invalid ref type \"${t}\"`)\r\n    }\r\n    for (const id in ra) {\r\n      const m = ra[id], n = m.type\r\n      const d = definition[n]; if (!d) { throw cdae(n) }\r\n      initmodel(m, n); Object.setPrototypeOf(m, d.trans)\r\n      render(m)\r\n    }\r\n    return ra\r\n  }\r\n}\r\ncomponent.topod = (m = component.root) => {\r\n  const a2o = (m, ks, o = {}) => (ks.forEach(k => {\r\n    if (k[0] === '_') { return } const v = rf(m[k])\r\n    if (v !== undefined && v !== null) { o[k] = v }\r\n  }), o), sk = component.spkey\r\n  const seen = new Set, r = {}, rf = m => {\r\n    if (typeof m === 'object') {\r\n      if (seen.has(m)) {\r\n        if (!m._iscomp) { throw Error(`can't ref a non-component object`) }\r\n        return { [sk]: 'ref', v: m.id }\r\n      }\r\n      let o, ks = Object.keys(m); seen.add(m)\r\n      if (m instanceof Set || m instanceof Map) {\r\n        const sp = m instanceof Set ? 'set' : 'map'\r\n        o = { [sk]: sp, v: [...m].map(rf) }\r\n        if (ks.length > 0) {\r\n          o = { [sk]: 'exk', v: o }\r\n          o.k = a2o(m, ks)\r\n        }\r\n      } else if (m instanceof Array) {\r\n        o = m.map(rf); if (ks.length > m.length) {\r\n          o = { [sk]: 'exk', v: o }\r\n          o.k = a2o(m, ks.slice(m.length))\r\n        }\r\n      } else { o = a2o(m, ks) }\r\n      if (m._iscomp) {\r\n        (r[m.type] ??= {})[m.id] = (delete o.type, delete o.id, o)\r\n        return { [sk]: 'ref', v: m.id }\r\n      } else { return o }\r\n    } else if (typeof m === 'function') {\r\n      throw Error(`public value should not be function`)\r\n    } else { return m }\r\n  }; return (rf(m), r)\r\n}\r\n\r\nconst errcomp = '[[ERROR]]'\r\nconst w3c = 'http://www.w3.org/', svgns = w3c + '2000/svg',\r\n  mmlns = w3c + 'Math/MathML', xhmns = w3c + '1999/xhtml'\r\n$.h = (tag, attribute, ...children) => {\r\n  let ns = '', e, nssi = tag.indexOf('@'); if (nssi >= 0) {\r\n    ns = tag.slice(0, nssi); tag = tag.slice(nssi + 1)\r\n  } switch (ns) {\r\n    case 'svg': e = document.createElementNS(svgns, tag); break\r\n    case 'mathml': e = document.createElementNS(mmlns, tag); break\r\n    case 'xhtml': e = document.createElementNS(xhmns, tag); break\r\n    case 'comp': return component.create(tag, attribute, ...children)\r\n    default: e = document.createElement(tag); break\r\n  } for (const k in attribute) {\r\n    if (k !== 'js') { e.setAttribute(k, attribute[k]) }\r\n    else for (const l in attribute.js) { e[l] = attribute.js[l] }\r\n  }\r\n  e.append(...children.map(c => {\r\n    if (!c?._iscomp) { return c }\r\n    const v = component.render(c)\r\n    if (v instanceof Promise) {\r\n      const tmp = h('div')\r\n      v.then(v => tmp.replaceWith(v))\r\n      return tmp ?? errcomp\r\n    } else { return v ?? errcomp }\r\n  }))\r\n  return e\r\n}"}