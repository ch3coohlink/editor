{"id":"a5b4c8483798213ea71041b98d94c285fcafd3e539ab0c685fe1b87a257fef2d","to":[],"value":"[{\"type\":\"text\",\"value\":\"现在我们可以加载代码到工作线程。\",\"open\":true},{\"type\":\"ref\",\"line\":[1,11],\"value\":\"5783d75c33e8d6e6e7b0dac28fa68eaeb3db2c5130540d6db7aadea7fa19f86e\",\"open\":true},{\"type\":\"exec\",\"value\":\"block above\",\"open\":false},{\"type\":\"ref\",\"line\":[1,11],\"value\":\"bf66de86aa78304df6ae579cc1bf15ebb65ea02da6e46bb7b5742864b9d37208\",\"open\":true},{\"type\":\"text\",\"value\":\"上面的代码加载了一个在worker线程的计算负载，如果该线程因为计算而阻塞，右上角会出现一盏红灯进行指示。\",\"open\":true},{\"type\":\"ref\",\"line\":[1,11],\"value\":\"d8437a0a6403aa24ea29d8f5cc9b7b99217696828051522c7c532d8debfbadb3\",\"open\":true,\"content\":\"const cvs = await requestcanvas()\\r\\nconst ctx = await cvs.getContext('2d')\\r\\nconst now = () => performance.now() / 1000\\r\\n\\r\\nrequestAnimationFrame($.loop = () => {\\r\\n  const w = cvs.width, h = cvs.height, t = now()\\r\\n  ctx.clearRect(0, 0, w, h)\\r\\n  ctx.fillRect(w / 2 - 50 + Math.sin(t) * 100,\\r\\n    h / 2 - 50 + Math.cos(t) * 100, 100, 100)\\r\\n  requestAnimationFrame(loop)\\r\\n})\"},{\"type\":\"ref\",\"line\":[1,11],\"value\":\"cfab8500f008cef36253efd4ef861367bee73364fcbb30f1688ae4cbdc21551a\",\"open\":false},{\"type\":\"exec\",\"value\":\"block above\",\"open\":true},{\"type\":\"ref\",\"line\":[1,11],\"value\":\"d8437a0a6403aa24ea29d8f5cc9b7b99217696828051522c7c532d8debfbadb3\",\"open\":true,\"content\":\"const { log } = originconsole\\r\\n\\r\\nconst cvs = await requestcanvas()\\r\\nconst ctx = await cvs.getContext('2d')\\r\\nconst now = () => performance.now() / 1000\\r\\n\\r\\non('canvasresize', ({ w, h, dpi }) => {\\r\\n  cvs.width = w\\r\\n  cvs.height = h\\r\\n})\\r\\n\\r\\nrequestAnimationFrame($.loop = () => {\\r\\n  const w = cvs.width, h = cvs.height, t = now()\\r\\n  ctx.clearRect(0, 0, w, h)\\r\\n  ctx.fillRect(w / 2 - 50 + Math.sin(t) * 100,\\r\\n    h / 2 - 50 + Math.cos(t) * 100, 100, 100)\\r\\n  ctx.font = '100px sans'\\r\\n  ctx.fillText('hello worker', 100, 100)\\r\\n  requestAnimationFrame(loop)\\r\\n})\"},{\"type\":\"ref\",\"line\":[1,11],\"value\":\"cfab8500f008cef36253efd4ef861367bee73364fcbb30f1688ae4cbdc21551a\",\"open\":false},{\"type\":\"exec\",\"value\":\"block above\",\"open\":true},{\"type\":\"text\",\"value\":\"这样我们就实现了对offscreencanvas的resize。\",\"open\":true},{\"type\":\"text\",\"value\":\"下面该写什么呢？可以实现输入事件的处理，也可以直接开写webgpu的封装。<div>那就选后面那个吧。</div>\",\"open\":true},{\"type\":\"ref\",\"line\":[1,11],\"value\":\"d8437a0a6403aa24ea29d8f5cc9b7b99217696828051522c7c532d8debfbadb3\",\"open\":true,\"content\":\"const { log } = originconsole\\r\\n\\r\\nconst canvas = await requestcanvas()\\r\\nconst adapter = await navigator.gpu.requestAdapter()\\r\\nconst device = await adapter.requestDevice()\\r\\nconst context = canvas.getContext('webgpu')\\r\\n\\r\\nconst format = navigator.gpu.getPreferredCanvasFormat()\\r\\ncontext.configure({ device, format, alphaMode: 'premultiplied' })\\r\\n\\r\\nconst now = () => performance.now() / 1000\\r\\non('canvasresize', ({ w, h }) => w !== 0 && h !== 0\\r\\n  ? (canvas.width = w, canvas.height = h) : 0)\\r\\n\\r\\nconst pipeline = device.createRenderPipeline({\\r\\n  layout: 'auto',\\r\\n  vertex: {\\r\\n    module: device.createShaderModule({\\r\\n      code: `@vertex\\r\\nfn main(\\r\\n  @builtin(vertex_index) VertexIndex : u32\\r\\n) -> @builtin(position) vec4f {\\r\\n  var pos = array<vec2f, 3>(\\r\\n    vec2(0.0, 0.5),\\r\\n    vec2(-0.5, -0.5),\\r\\n    vec2(0.5, -0.5)\\r\\n  );\\r\\n\\r\\n  return vec4f(pos[VertexIndex], 0.0, 1.0);\\r\\n}`,\\r\\n    }),\\r\\n  },\\r\\n  fragment: {\\r\\n    module: device.createShaderModule({\\r\\n      code: `@fragment\\r\\nfn main() -> @location(0) vec4f {\\r\\n  return vec4(1.0, 0.0, 0.0, 1.0);\\r\\n}`,\\r\\n    }),\\r\\n    targets: [{ format, }],\\r\\n  },\\r\\n  primitive: { topology: 'triangle-list' },\\r\\n});\\r\\n\\r\\nfunction frame() {\\r\\n  const commandEncoder = device.createCommandEncoder()\\r\\n  const textureView = context.getCurrentTexture().createView()\\r\\n\\r\\n  const renderPassDescriptor = {\\r\\n    colorAttachments: [\\r\\n      {\\r\\n        view: textureView,\\r\\n        clearValue: [0, 0, 0, 1],\\r\\n        loadOp: 'clear',\\r\\n        storeOp: 'store',\\r\\n      },\\r\\n    ],\\r\\n  }\\r\\n\\r\\n  const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor)\\r\\n  passEncoder.setPipeline(pipeline)\\r\\n  passEncoder.draw(3)\\r\\n  passEncoder.end()\\r\\n\\r\\n  device.queue.submit([commandEncoder.finish()])\\r\\n}\\r\\n\\r\\n\\r\\nconst loop = () => {\\r\\n  const w = canvas.width, h = canvas.height, t = now()\\r\\n  frame()\\r\\n  requestAnimationFrame(loop)\\r\\n}; requestAnimationFrame(loop)\"},{\"type\":\"ref\",\"line\":[1,11],\"value\":\"cfab8500f008cef36253efd4ef861367bee73364fcbb30f1688ae4cbdc21551a\",\"open\":false},{\"type\":\"exec\",\"value\":\"block above\",\"open\":true},{\"type\":\"text\",\"value\":\"第一个三角形！\",\"open\":true},{\"type\":\"ref\",\"line\":[1,11],\"value\":\"d8437a0a6403aa24ea29d8f5cc9b7b99217696828051522c7c532d8debfbadb3\",\"open\":true,\"content\":\"const { log, clear } = originconsole\\r\\nclear()\\r\\n\\r\\nconst canvas = await requestcanvas()\\r\\nconst adapter = await navigator.gpu.requestAdapter()\\r\\nconst device = await adapter.requestDevice()\\r\\nconst context = canvas.getContext('webgpu')\\r\\n\\r\\nconst format = navigator.gpu.getPreferredCanvasFormat()\\r\\ncontext.configure({ device, format, alphaMode: 'premultiplied' })\\r\\n\\r\\nconst now = () => performance.now() / 1000\\r\\non('canvasresize', ({ w, h }) => w !== 0 && h !== 0\\r\\n  ? (canvas.width = w, canvas.height = h) : 0)\\r\\n\\r\\nconst pipeline = device.createRenderPipeline({\\r\\n  layout: 'auto',\\r\\n  vertex: {\\r\\n    module: device.createShaderModule({\\r\\n      code: `@vertex\\r\\nfn main(@builtin(vertex_index) VertexIndex: u32) -> @builtin(position) vec4f {\\r\\n  var pos = array<vec2f, 3>(\\r\\n    vec2(0.0, 0.5), vec2(-0.5, -0.5), vec2(0.5, -0.5));\\r\\n  return vec4f(pos[VertexIndex], 0.0, 1.0);\\r\\n}`,\\r\\n    }),\\r\\n  },\\r\\n  fragment: {\\r\\n    module: device.createShaderModule({\\r\\n      code: `@fragment\\r\\nfn main() -> @location(0) vec4f {\\r\\n  return vec4(1.0, 0.0, 1.0, 1.0);\\r\\n}`,\\r\\n    }), targets: [{ format, }],\\r\\n  },\\r\\n  primitive: { topology: 'triangle-list' },\\r\\n});\\r\\n\\r\\nfunction frame() {\\r\\n  const commandEncoder = device.createCommandEncoder()\\r\\n  const textureView = context.getCurrentTexture().createView()\\r\\n\\r\\n  const renderPassDescriptor = {\\r\\n    colorAttachments: [\\r\\n      {\\r\\n        view: textureView,\\r\\n        clearValue: [0, 0, 0, 1],\\r\\n        loadOp: 'clear',\\r\\n        storeOp: 'store',\\r\\n      },\\r\\n    ],\\r\\n  }\\r\\n\\r\\n  const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor)\\r\\n  passEncoder.setPipeline(pipeline)\\r\\n  passEncoder.draw(3)\\r\\n  passEncoder.end()\\r\\n\\r\\n  device.queue.submit([commandEncoder.finish()])\\r\\n}\\r\\n\\r\\n\\r\\nconst loop = () => {\\r\\n  const w = canvas.width, h = canvas.height, t = now()\\r\\n  frame()\\r\\n  requestAnimationFrame(loop)\\r\\n}; requestAnimationFrame(loop)\"},{\"type\":\"ref\",\"line\":[1,11],\"value\":\"cfab8500f008cef36253efd4ef861367bee73364fcbb30f1688ae4cbdc21551a\",\"open\":false},{\"type\":\"exec\",\"value\":\"block above\",\"open\":true},{\"type\":\"text\",\"value\":\"GUI 开发计划：<div>  - webgpu：矢量图绘制</div><div>    - 最简单的状态下，绘制直线即可</div><div>    - 但是对于我那套2d sdf的算法来说，绘制三角形和贝塞尔曲线没有太大的区别，重点是解决图元在像素上的culling。</div><div>  - </div>\",\"open\":true},{\"type\":\"text\",\"value\":\"- 把执行窗口拖到文档外面<div>- 文档块成组</div><div>- 执行块带着引用的文件一起复制</div><div>- 给执行块加启动参数：用code snippet可以实现</div>\",\"name\":\"编辑器需求\",\"open\":true},{\"type\":\"code\",\"links\":[\"6cf3c1f4597df47cf030626c829fe052312762e79f0533966571df339129604c\"],\"value\":\"Object.assign($, await require('0/boot.js'))\\r\\nloadworker('0/worker_test/worker/webgpu1.js')\",\"open\":true},{\"type\":\"exec\",\"value\":\"block above\",\"open\":true},{\"type\":\"text\",\"value\":\"这样就能方便进行各种实验了！\",\"open\":true},{\"type\":\"code\",\"links\":[\"6cf3c1f4597df47cf030626c829fe052312762e79f0533966571df339129604c\"],\"value\":\"Object.assign($, await require('0/boot.js'))\\r\\nloadworker('0/worker_test/worker/webgpu2.js')\",\"open\":false},{\"type\":\"exec\",\"value\":\"block above\",\"open\":true},{\"type\":\"text\",\"value\":\"用canvas实现的picking\",\"open\":true},{\"type\":\"code\",\"links\":[\"6cf3c1f4597df47cf030626c829fe052312762e79f0533966571df339129604c\"],\"value\":\"Object.assign($, await require('0/boot.js'))\\r\\nloadworker('0/gui_test/00.js')\",\"open\":false},{\"type\":\"exec\",\"value\":\"block above\",\"open\":true},{\"type\":\"text\",\"value\":\"加载opentype.js用于解析字体文件<div>加载consolas.ttf作为示例字体</div><div>循环绘制字体中的所有字形</div>\",\"open\":true},{\"type\":\"code\",\"links\":[\"6cf3c1f4597df47cf030626c829fe052312762e79f0533966571df339129604c\"],\"value\":\"Object.assign($, await require('0/boot.js'))\\r\\nloadworker('0/gui_test/01.js')\",\"open\":false},{\"type\":\"exec\",\"value\":\"block above\",\"open\":true},{\"type\":\"text\",\"value\":\"有了绘制单个字形的功能，我们就可以绘制完整的一行文字\",\"open\":true},{\"type\":\"code\",\"links\":[\"6cf3c1f4597df47cf030626c829fe052312762e79f0533966571df339129604c\"],\"value\":\"Object.assign($, await require('0/boot.js'))\\r\\nloadworker('0/gui_test/02.js')\",\"open\":true},{\"type\":\"exec\",\"value\":\"block above\",\"open\":true},{\"type\":\"text\",\"value\":\"现在我们有了绘制单行文字的功能，可以来考虑一些基本的GUI组件了。<div>GUI组件在大小设定上有两种类型，一种是根据其内容占据一部分空间的“组件”</div><div>还有一种是可以根据各种规则决定其大小的“容器”</div><div>“组件”是相对简单的，应该对“容器”的规则进行分类。</div>\",\"open\":true},{\"type\":\"code\",\"links\":[\"6cf3c1f4597df47cf030626c829fe052312762e79f0533966571df339129604c\"],\"value\":\"Object.assign($, await require('0/boot.js'))\\r\\nloadworker('0/gui_test/03.js')\",\"open\":true},{\"type\":\"exec\",\"value\":\"block above\",\"open\":true},{\"type\":\"text\",\"value\":\"<div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div>\",\"name\":\"留出滚动距离\",\"open\":true}]"}