{"id":"58d4fcc5a4d7f6ec5c55cc248fb068bfb706edeacd18f0fa98507b11efd42d80","to":[],"value":"Object.assign($, await require('lib/common.js'))\r\nconst grd = await require('lib/random.js')\r\nroot.style.overflow = 'hidden'\r\nconsole.clear()\r\n\r\n$.framecount = 0\r\nconst loop = () => {\r\n  if ($.frame) { framecount++; frame() }\r\n  requestAnimationFrame(loop)\r\n}; requestAnimationFrame(loop)\r\n\r\nconst dom = (n = 'div') => document.createElement(n)\r\nconst svg = n => document.createElementNS('http://www.w3.org/2000/svg', n)\r\nconst svgtags = new Set(`a altGlyph altGlyphDef altGlyphItem\r\n  animate animateColor animateMotion animateTransform animation\r\n  audio canvas circle clipPath color-profile cursor defs desc discard\r\n  ellipse feBlend feColorMatrix feComponentTransfer feComposite\r\n  feConvolveMatrix feDiffuseLighting feDisplacementMap feDistantLight\r\n  feDropShadow feFlood feFuncA feFuncB feFuncG feFuncR feGaussianBlur\r\n  feImage feMerge feMergeNode feMorphology feOffset fePointLight\r\n  feSpecularLighting feSpotLight feTile feTurbulence filter font\r\n  font-face font-face-format font-face-name font-face-src font-face-uri\r\n  foreignObject g glyph glyphRef handler hkern iframe image line\r\n  linearGradient listener marker mask metadata missing-glyph mpath path\r\n  pattern polygon polyline prefetch radialGradient rect script set\r\n  solidColor stop style svg switch symbol tbreak text textArea textPath\r\n  title tref tspan unknown use video view vker`.split(/\\s+/))\r\n\r\n$.component = { globalenv: $ }; with (component) {\r\n  const $ = component\r\n  $.definition = {}\r\n  const cdae = n => Error(`component definition \"${n}\" already exists.`)\r\n  const cdne = n => Error(`component definition \"${n}\" not exists.`)\r\n  const initmodel = (model, name) => {\r\n    if (model.recordhistory) { model.history = [] }\r\n    model.type = name, model._iscomp = true\r\n  }\r\n  $.define = (name, model = {}, transition, view, extra = {}) => {\r\n    if (definition[name]) { throw cdae(name) }\r\n    if (typeof model !== 'function') { initmodel(model, name) }\r\n    const t = {}; if (typeof transition === 'function') {\r\n      transition((n, f, history = true) => t[n] = function (...a) {\r\n        const m = this, r = f(m, ...a)\r\n        // TODO: a should be serialized since it could contain something like component\r\n        if (history && m.recordhistory) { m.history.push([n, a]) } return r\r\n      })\r\n    } definition[name] = { model, view, transition: t }\r\n    return (...a) => create(n, ...a)\r\n  }\r\n  $.create = (name, mod, ...a) => {\r\n    if (!definition[name]) { throw cdne(name) }\r\n    const d = definition[name], mf = typeof d.model === 'function'\r\n    const m = mf ? d.model(...a) : deepclone(d.model)\r\n    if (mf) { initmodel(m, name) } m.id = grd.uuid()\r\n    Object.setPrototypeOf(m, d.transition)\r\n    if (typeof mod === 'function') { mod(m) }\r\n    m._view = d.view(m); render(m)\r\n    return m\r\n  }\r\n  $.render = c => {\r\n    const iscomp = c._iscomp\r\n    if (iscomp && !c._view) {\r\n      const d = definition[c.type]\r\n      if (!d) { throw cdne(c.type) }\r\n      c._view = d.view(c)\r\n    }\r\n    const v = iscomp ? c._view : c\r\n    if (!c._dom) {\r\n      c._dom = v._namespace !== 'dom'\r\n        && svgtags.has(v.type) ? svg(v.type) : dom(v.type)\r\n    }\r\n\r\n    const d = c._dom\r\n    const vcs = v.children ?? []\r\n    for (const cd of vcs) {\r\n      if (!cd._iscomp || !cd._dom) { render(cd, true) }\r\n      d.append(cd._dom)\r\n    } delete v.children\r\n\r\n    if (v.jsobj) for (const k of Object.keys(v.jsobj)) {\r\n      d[k] = v.jsobj[k]\r\n    } delete v.jsobj; delete v.type\r\n\r\n    for (const k of Object.keys(v)) {\r\n      if (k[0] === '_') { continue }\r\n      d.setAttribute(k, v[k])\r\n    }\r\n  }\r\n  let previoussize = [0, 0]\r\n  $.frame = () => {\r\n    if (!root) { return }\r\n    const groot = globalenv.root\r\n    const rbcr = groot.getBoundingClientRect()\r\n    const size = [rbcr.width, rbcr.height]\r\n    if (!deepequal(size, previoussize)) { root._size = size; }\r\n    previoussize = size\r\n    if (groot.childNodes[0] !== root._dom) {\r\n      groot.innerHTML = ''\r\n      groot.append(root._dom)\r\n    }\r\n  }\r\n  $.spkey = 'ยง'\r\n  $.frompod = d => {\r\n    const a2o = (m, o = {}) => (\r\n      Object.keys(m).forEach(k => {\r\n        const v = rf(m[k]); if (v[spkey] !== 'ref') { o[k] = v }\r\n        else { refq.push(['ref', o, k, v.id]) }\r\n      }), o)\r\n    const a2a = (m, o = []) => (\r\n      m.forEach((m, i) => {\r\n        const v = rf(m); if (v[spkey] !== 'ref') { o.push(v) }\r\n        else { refq.push(['ref', o, i, v.id]) }\r\n      }), o)\r\n    const a2set = (m, o = new Set) => {\r\n      for (let v of m) {\r\n        v = rf(v); if (v[spkey] !== 'ref') { o.add(v) }\r\n        else { refq.push(['set', o, v.id]) }\r\n      } return o\r\n    }\r\n    const a2map = (m, o = new Map) => {\r\n      for (let [k, v] of m) {\r\n        k = rf(k), v = rf(v)\r\n        if (k[spkey] !== 'ref' && v[spkey] !== 'ref') { o.set(k, v) }\r\n        else { refq.push(['map', o, k, v]) }\r\n      } return o\r\n    }\r\n    const ra = {}, refq = [], rf = m => {\r\n      if (typeof m !== 'object') { return m }\r\n      if (m instanceof Array) { return a2a(m) }\r\n      const sk = m[spkey]; if (!sk) { return a2o(m) }\r\n      switch (sk) {\r\n        case 'exk': return Object.assign(rf(m.v), a2o(m.k))\r\n        case 'ref': return { [spkey]: 'ref', id: m.v }\r\n        case 'set': return a2set(m.v)\r\n        case 'map': return a2map(m.v)\r\n        default: throw Error(`invalid spkey \"${sk}\"`)\r\n      }\r\n    }\r\n    let ds; for (const type in d) for (const id in ds = d[type]) {\r\n      const o = rf(ds[id]); if (!o) { continue }\r\n      o.type = type, o.id = id, ra[id] = o\r\n    }\r\n    for (const [t, o, k, v] of refq) switch (t) {\r\n      case 'set': o.add(ra[k]); break\r\n      case 'map': o.set(\r\n        k[spkey] === 'ref' ? ra[k.id] : k,\r\n        v[spkey] = 'ref' ? ra[v.id] : v); break\r\n      case 'ref': o[k] = ra[v]; break\r\n      default: throw Error(`invalid ref type \"${t}\"`)\r\n    }\r\n    for (const id in ra) {\r\n      const m = ra[id], n = m.type\r\n      const d = definition[n]; if (!d) { throw cdae(n) }\r\n      initmodel(m, n); Object.setPrototypeOf(m, d.transition)\r\n      m.onload?.(); m._view = d.view(m); render(m)\r\n    }\r\n    return ra\r\n  }\r\n}\r\ncomponent.topod = (m = component.root) => {\r\n  const a2o = (m, ks, o = {}) => (ks.forEach(k => {\r\n    if (k[0] === '_') { return } const v = rf(m[k])\r\n    if (v !== undefined && v !== null) { o[k] = v }\r\n  }), o), sk = component.spkey\r\n  const seen = new Set, r = {}, rf = m => {\r\n    if (typeof m === 'object') {\r\n      if (seen.has(m)) {\r\n        if (!m._iscomp) { throw Error(`can't ref a non-component object`) }\r\n        return { [sk]: 'ref', v: m.id }\r\n      }\r\n      let o, ks = Object.keys(m); seen.add(m)\r\n      if (m instanceof Set || m instanceof Map) {\r\n        const sp = m instanceof Set ? 'set' : 'map'\r\n        o = { [sk]: sp, v: [...m].map(rf) }\r\n        if (ks.length > 0) {\r\n          o = { [sk]: 'exk', v: o }\r\n          o.k = a2o(m, ks)\r\n        }\r\n      } else if (m instanceof Array) {\r\n        o = m.map(rf); if (ks.length > m.length) {\r\n          o = { [sk]: 'exk', v: o }\r\n          o.k = a2o(m, ks.slice(m.length))\r\n        }\r\n      } else { o = a2o(m, ks) }\r\n      if (m._iscomp) {\r\n        (r[m.type] ??= {})[m.id] = (delete o.type, delete o.id, o)\r\n        return { [sk]: 'ref', v: m.id }\r\n      } else { return o }\r\n    } else if (typeof m === 'function') {\r\n      throw Error(`public value should not be function`)\r\n    } else { return m }\r\n  }; return (rf(m), r)\r\n}\r\n\r\n// graph-layout ===========================================================================================\r\n$.glrd = grd.genrd(6834652831)\r\n{\r\n  $.splitgraph = m => {\r\n    m._subgraph = []; let seen = new Set, sub = 0\r\n    for (let n of m.node) {\r\n      if (seen.has(n)) { continue }\r\n      const s = m._subgraph[sub++] = [], q = [n]\r\n      while (n = q.shift()) {\r\n        if (seen.has(n)) { continue } s.push(n), seen.add(n)\r\n        q.push(...[...n.to.keys()], ...[...n.from.keys()])\r\n      }\r\n    }\r\n    for (const n of m.node) {\r\n      n.rank = n.ranksum = n.rankcount = 0\r\n    }\r\n    m.graphmoded = false\r\n    m.needlayout = true\r\n  }\r\n  const rankrd = grd.genrd(2462462542)\r\n  $.rankgraph = (m, l = 100) => {\r\n    const { rdi } = rankrd, { abs } = Math\r\n    for (const g of m._subgraph) {\r\n      if (g.converged) { continue }\r\n      if (g.length <= 1) { g[0].rank = 0; g.converged = true; continue }\r\n      for (let i = 0; i < l; i++) {\r\n        const q = [[g[rdi(g.length)], 0]], seen = new Set\r\n        while (q.length > 0) {\r\n          const [n, d] = q.splice(rdi(q.length), 1)[0]\r\n          if (seen.has(n)) { continue } seen.add(n)\r\n          n.ranksum += d, q.push(\r\n            ...[...n.to.keys()].map(v => [v, d - 1]),\r\n            ...[...n.from.keys()].map(v => [v, d + 1]))\r\n        }\r\n      }\r\n      let d = 0; for (const n of g) {\r\n        n.rankcount += l\r\n        n.oldrank = n.rank\r\n        n.rank = n.ranksum / n.rankcount\r\n        d += abs(n.rank - n.oldrank)\r\n      }\r\n      if (m.progressiveranking) {\r\n        if (d < 0.001 * g.length) { g.converged = true }\r\n      } else { g.converged = true }\r\n    } rankrd.next()\r\n\r\n  }\r\n  $.forcedirect = (m, step = 4) => {\r\n    const { sqrt, max, min, abs } = Math\r\n    const gravity = { rposition: [0, 0], acceleration: [0, 0] }\r\n    const { usemargin } = m, mg = usemargin ? 15 : 0\r\n    const electric = (a, b, p, minl = 1) => {\r\n      const pdx = b.rposition[0] - a.rposition[0]\r\n      const pdy = b.rposition[1] - a.rposition[1]\r\n      const lsq = max(pdx * pdx + pdy * pdy, minl)\r\n      const l = sqrt(lsq), f = p / (lsq * l)\r\n      let fx = f * pdx, fy = f * pdy; if (usemargin &&\r\n        a.bbox[0] < b.bbox[2] + mg && b.bbox[0] < a.bbox[2] + mg &&\r\n        a.bbox[1] < b.bbox[3] + mg && b.bbox[1] < a.bbox[3] + mg) {\r\n        const d0 = b.bbox[2] + mg - a.bbox[0]\r\n        const d1 = b.bbox[0] - mg - a.bbox[2]\r\n        const d2 = b.bbox[3] + mg - a.bbox[1]\r\n        const d3 = b.bbox[1] - mg - a.bbox[3]\r\n        const dx = abs(d0) < abs(d1) ? d0 : d1\r\n        const dy = abs(d2) < abs(d3) ? d2 : d3\r\n        if (abs(dx) < abs(dy)) { a.rposition[0] += dx; b.rposition[0] -= dx }\r\n        else { a.rposition[1] += dy; b.rposition[1] -= dy }\r\n      } a.acceleration[0] += fx, a.acceleration[1] += fy\r\n      b.acceleration[0] -= fx, b.acceleration[1] -= fy\r\n    }, distance = (a, b, p) => {\r\n      const pdx = b.rposition[0] - a.rposition[0]\r\n      const pdy = b.rposition[1] - a.rposition[1]\r\n      const fx = p * pdx, fy = p * pdy\r\n      a.acceleration[0] += fx, a.acceleration[1] += fy\r\n      b.acceleration[0] -= fx, b.acceleration[1] -= fy\r\n    }, friction = usemargin ? 0.5 : 0.01, dt = 0.05\r\n    const tl = m.target_length, ts = tl * 2\r\n    const pe = -ts * tl ** 2, pd = ts * 20 / tl, pg = 0.05 * pd\r\n    const h = m.direction === 'horizontal' ? 0 : 1\r\n    const g = m._subgraph.flat(1)\r\n    for (let i = 0; i < step; i++) {\r\n      for (let i = 0, l = g.length; i < l; i++) {\r\n        const a = g[i], nto = 1 / a.to.size\r\n        for (let j = i + 1; j < l; j++) { electric(a, g[j], pe) }\r\n        for (const [to] of a.to) { distance(a, to, pd * nto) }\r\n        if (a.lock) { a.velocity[0] = a.velocity[1] = 0; continue }\r\n        if (m.hierarchy) { a.acceleration[h] -= a.rank * tl * 1 }\r\n        distance(a, gravity, pg)\r\n        const vx = a.velocity[0] + a.acceleration[0] * dt\r\n        const vy = a.velocity[1] + a.acceleration[1] * dt\r\n        let v = sqrt(vx * vx + vy * vy), vrx = vx / v, vry = vy / v\r\n        v = max(min(v, ts) - ts * friction, 0)\r\n        a.rposition[0] += (a.velocity[0] = vrx * v) * dt\r\n        a.rposition[1] += (a.velocity[1] = vry * v) * dt\r\n        a.acceleration[0] = a.acceleration[1] = 0\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n{\r\n  const { max, min } = Math; $.clamp = (v, s, l) => max(min(v, l), s)\r\n  $.itp = (a, b, t) => (t = clamp(t, 0, 1), a + t * (b - a))\r\n  $.itp3 = (a, b, t) => (t = clamp(t, 0, 1),\r\n    [a[0] + t * (b[0] - a[0]), a[1] + t * (b[1] - a[1]), a[2] + t * (b[2] - a[2])])\r\n\r\n  $.dragprocess = (move, cancel) => {\r\n    const c = e => (off('pointermove', mi),\r\n      off('pointerup', ui), off('pointercancel', ci), cancel?.(e))\r\n    const mi = on('pointermove', e => move(e))\r\n    const ui = on('pointerup', c)\r\n    const ci = on('pointercancel', c)\r\n  }\r\n  $.expdecay = (a, b, d, dt) => b + (a - b) * Math.exp(-d * dt)\r\n  $.callhotkey = (m, k, e) => {\r\n    while (m) {\r\n      if (m._hotkey[k]) {\r\n        return m._hotkey[k]?.(e)\r\n      } m = m.parent\r\n    }\r\n  }\r\n  $.formatkeyevent = (e, up) => e.key.toLowerCase() + (up ? 'up' : [\r\n    e.altKey, e.ctrlKey, e.shiftKey].map(v => v ? 't' : 'f').join(''))\r\n}\r\n\r\n// graph ==================================================================================================\r\nconst cameradefault = [2, 0, 0]\r\ncomponent.define('graph', (camera = [...cameradefault]) => ({\r\n  direction: 'vertical', _subgraph: [],\r\n  target_length: 50, node: new Set,\r\n  camera, realcameravalue: [...camera],\r\n  color: [90, 90, 90], focuscolor: '#0087ff',\r\n  zoomfactor: 1.2, hierarchy: true,\r\n}), df => {\r\n  df('add', (m, d, p) => {\r\n    const n = component.create('graph-node', n => (\r\n      n.parent = m, n.data = d, n.ranksum = 0, n.rankcount = 0), p)\r\n    m.graphmoded = true, m.node.add(n)\r\n    m._vnode._dom.append(n._dom)\r\n    m._resizewatcher.observe(n._dom)\r\n    return n\r\n  })\r\n  df('del', (m, n) => {\r\n    m.graphmoded = true, m.node.delete(n), n._dom.remove()\r\n    m._resizewatcher.unobserve(n._dom)\r\n    for (const [to] of n.to) { m.unlink(n, to) }\r\n    for (const [fr] of n.from) { m.unlink(fr, n) }\r\n  })\r\n  df('link', (m, a, b, d) => {\r\n    if (a.to.has(b)) { return a.to.get(b) }\r\n    const e = component.create('graph-edge', e => (\r\n      e.parent = m, e.from = a, e.to = b, e.data = d))\r\n    m.graphmoded = true, a.to.set(b, e), b.from.set(a, e)\r\n    m._vedge._dom.append(e._dom)\r\n    return e\r\n  })\r\n  df('unlink', (m, a, b, e = a.to.get(b)) => (m.graphmoded = true,\r\n    e._dom.remove(), a.to.delete(b), b.from.delete(a)))\r\n  df('offsetcoord', (m, e, r = m._dom.getBoundingClientRect()) =>\r\n    [e.pageX - r.left, e.pageY - r.top])\r\n  df('graphcoord', (m, e, cx = m.camera[1], cy = m.camera[2]) => {\r\n    const [x, y] = m.offsetcoord(e)\r\n    const { clientWidth: w, clientHeight: h } = m._dom\r\n    return [(x - cx - w / 2) / m.camera[0], (y - cy - h / 2) / m.camera[0]]\r\n  })\r\n  df('zoom', (m, e, r) => {\r\n    let [x, y] = Array.isArray(e) ? e : m.offsetcoord(e)\r\n    const { clientWidth: w, clientHeight: h } = m._dom\r\n    if (!Array.isArray(e)) { x -= w / 2; y -= h / 2 }\r\n    m.camera[0] *= r // equation: y - nsy === (y - sy) * r\r\n    m.camera[1] = x - (x - m.camera[1]) * r\r\n    m.camera[2] = y - (y - m.camera[2]) * r\r\n  })\r\n  df('updatecamera', (m, dt) => {\r\n    if (m.focusnode) {\r\n      [m.camera[1], m.camera[2]] = m.focusnode.center.map(v => -v * m.camera[0])\r\n    } const camera = [...m.camera]\r\n    if (m._movetarget) {\r\n      let mx = -Infinity, my = -Infinity, { abs } = Math\r\n      const a = m.focusnode ? m.focusnode.center : m.cameraposition()\r\n      for (const n of Object.values(m._movetarget).concat(m._previewmove)) {\r\n        if (!n) { continue } let v\r\n        v = abs(n.position[0] - a[0]); if (v > mx) { mx = v }\r\n        v = abs(n.position[1] - a[1]); if (v > my) { my = v }\r\n      } let { clientWidth: w, clientHeight: h } = m._dom\r\n      const ox = mx * m.camera[0] > (w *= .4)\r\n      const oy = my * m.camera[0] > (h *= .4)\r\n      camera[0] = ox || oy ? Math.min(w / mx, h / my) : camera[0]\r\n      camera[1] = -a[0] * camera[0]\r\n      camera[2] = -a[1] * camera[0]\r\n    }\r\n    m.realcameravalue = camera.map((v, i) =>\r\n      expdecay(m.realcameravalue[i], v, 16, dt))\r\n\r\n    const [s, x, y] = m.realcameravalue\r\n    m._canvas._dom.style.transform = `translate(50%, 50%) ` +\r\n      `translate(${x + 'px'}, ${y + 'px'}) scale(${s})`\r\n  })\r\n  df('frame', (m, dt) => {\r\n    m.updatecamera(dt)\r\n    if (m.graphmoded) { splitgraph(m) }\r\n    if (m.needlayout) {\r\n      for (const n of m.node) {\r\n        n.preupdate()\r\n        n._oldposition = [...n.position]\r\n      }\r\n      rankgraph(m, 100), forcedirect(m, 4)\r\n      let totalspeed = 0, { abs } = Math\r\n      for (const n of m.node) {\r\n        n.position = n.rposition.map(\r\n          (v, i) => expdecay(n.position[i], v, 10, dt))\r\n        // n.position = [...n.rposition] // show the real world (hint: horrify)\r\n        totalspeed += abs(n.position[0] - n._oldposition[0])\r\n          + abs(n.position[1] - n._oldposition[1])\r\n        n.update()\r\n      }\r\n      if (totalspeed <= 0.1 * m.node.size) { m.needlayout = false }\r\n      if (m._moving) { m.updatemove() }\r\n    }\r\n    if (m.focusnode) {\r\n      for (const [, e] of m.focusnode.to) {\r\n        e._dom.setAttribute('stroke', m.focuscolor)\r\n        e._dom.setAttribute('stroke-width', '2px')\r\n      } for (const [, e] of m.focusnode.from) {\r\n        e._dom.setAttribute('stroke', '#ff9700')\r\n        e._dom.setAttribute('stroke-width', '2px')\r\n      }\r\n    }\r\n  })\r\n  df('getmovetarget', m => {\r\n    const a = m._previewmove ? m._previewmove.position :\r\n      m.focusnode ? m.focusnode.position : m.cameraposition()\r\n    let i = 0, mvup = i, mvdw = i, mvlf = i, mvrt = i\r\n    const maxnode = {}; for (const n of m.node) {\r\n      const dx = n.position[0] - a[0], dy = n.position[1] - a[1]\r\n      let l = Math.sqrt(dx * dx + dy * dy), ld = 1 / l, lp = 1 - l / 500\r\n      const dup = dy * -ld, ddw = dy * ld, dlf = dx * -ld, drt = dx * ld\r\n      if (dup > 0) { v = lp + dup; if (mvup < v) { mvup = v; maxnode.up = n } }\r\n      if (ddw > 0) { v = lp + ddw; if (mvdw < v) { mvdw = v; maxnode.dw = n } }\r\n      if (dlf > 0) { v = lp + dlf; if (mvlf < v) { mvlf = v; maxnode.lf = n } }\r\n      if (drt > 0) { v = lp + drt; if (mvrt < v) { mvrt = v; maxnode.rt = n } }\r\n    } m._movetarget = maxnode\r\n  })\r\n  df('updatemove', (m, _, d) => {\r\n    let n; if (m._movetarget) {\r\n      for (const k in m._movetarget) if (n = m._movetarget[k]) {\r\n        n.settitle(''); n.resetcolor()\r\n      } if (m._previewmove) { m._previewmove.resetcolor() }\r\n      if (d) { m._previewmove = m._movetarget[d] }\r\n    }\r\n    if (m.focusnode) { m.focusnode.setcolor(m.focuscolor) }\r\n    if (!m._moving) {\r\n      if (m.focusnode) { m.focusnode.setcolor(m.focuscolor, '44') }\r\n      if (m._previewmove) { m._previewmove.focus() }\r\n      return m._edgecreated = m._movetarget = m._previewmove = undefined\r\n    } m.getmovetarget()\r\n    for (const k in m._movetarget) if (n = m._movetarget[k]) {\r\n      n._title._dom.setAttribute('stroke-width', '1px')\r\n      n._title._dom.setAttribute('stroke', '#333')\r\n      n._title._dom.setAttribute('fill', '#c8ff17')\r\n      n._title._dom.setAttribute('font-size', '50px')\r\n      switch (k) {\r\n        case 'up': n.addtitle('โ'); break\r\n        case 'dw': n.addtitle('โ'); break\r\n        case 'lf': n.addtitle('โ'); break\r\n        case 'rt': n.addtitle('โ'); break\r\n      }\r\n    } if (m._previewmove) { m._previewmove.setcolor('#ff9700') }\r\n  })\r\n  df('startmove', m => m._moving || m._forceleavemove\r\n    ? 0 : m.updatemove(m._moving = true))\r\n  df('move', (m, d) => m.updatemove(m._moving = true, d))\r\n  df('endmove', m => {\r\n    m.updatemove(m._moving = false)\r\n    m._forceleavemove = false\r\n  })\r\n  df('pausemove', m => {\r\n    const n = m.focusnode; m.updatemove(m._moving = false)\r\n    m._forceleavemove = true; (n ? n : m).focus()\r\n  })\r\n  df('focus', m => m._dom.focus())\r\n  df('blur', m => m._dom.blur())\r\n  df('createorconnect', (m, second = false) => {\r\n    if (m._previewmove) {\r\n      if (!m.focusnode) { return } const b = m._previewmove\r\n      const a = m.focusnode, ab = a.to.has(b), ba = b.to.has(a)\r\n      if (second) {\r\n        if (ab) { m.unlink(a, b) } if (ba) { m.unlink(b, a) }\r\n      } else {\r\n        if (ab && ba) { m.unlink(b, a) } else if (ab) {\r\n          m.link(b, a); if (m._reverted) { delete m._reverted }\r\n          else { m.unlink(a, b), m._reverted = true }\r\n        } else if (ba) {\r\n          m.link(a, b); if (m._reverted) { delete m._reverted }\r\n          else { m.unlink(b, a), m._reverted = true }\r\n        } else { m.link(m.focusnode, b) }\r\n      }\r\n    } else {\r\n      m.endmove(); const a = m.focusnode, b = m.add(component.create(\r\n        'text-editor'), a ? a.position : m.cameraposition())\r\n      if (a) { m.link(a, b); second ? b.focus() : 0 } else { b.focus() }\r\n    }\r\n  })\r\n  df('cameraposition', m => [-m.camera[1] / m.camera[0], -m.camera[2] / m.camera[0]])\r\n  df('callhotkey', callhotkey)\r\n  df('onload', m => {\r\n    m.graphmoded = true\r\n    setTimeout(() => {\r\n      m.node.forEach(n => m._resizewatcher.observe(n._dom))\r\n      m.focusnode?.focus?.()\r\n    }, 20)\r\n  })\r\n  df('save', () => save())\r\n}, m => (m._resizewatcher = new ResizeObserver(() => m.needlayout = true),\r\n  m._horizontal = m.direction === 'horizontal',\r\n  m.realcameravalue = [...m.camera], m._hotkey = {\r\n    ntff: () => m.createorconnect(),\r\n    mtff: () => m.createorconnect(true),\r\n    alttff: () => m.startmove(),\r\n    altup: () => m.endmove(),\r\n    utff: () => m.pausemove(),\r\n    sftf: () => m.save(),\r\n    ytff: () => m.zoom([0, 0], m.zoomfactor),\r\n    htff: () => m.zoom([0, 0], 1 / m.zoomfactor),\r\n    itff: () => m.move('up'),\r\n    ktff: () => m.move('dw'),\r\n    jtff: () => m.move('lf'),\r\n    ltff: () => m.move('rt'),\r\n    otff: () => m.camera = [...cameradefault],\r\n    ptff: () => (m.needlayout = true,\r\n      m.direction = m._horizontal ? 'vertical' : 'horizontal',\r\n      m._horizontal = m.direction === 'horizontal'),\r\n    '[tff': () => (m.needlayout = true, m.usemargin = !m.usemargin),\r\n  }, {\r\n  type: 'svg', jsobj: {\r\n    onwheel: (e, r = m.zoomfactor) => (\r\n      m.zoom(e, e.deltaY < 0 ? r : 1 / r), e.preventDefault()),\r\n    onpointerdown: e => {\r\n      if (e.target !== m._dom) { return }\r\n      const cx = m.camera[1], cy = m.camera[2]\r\n      const o = m.graphcoord(e, cx, cy)\r\n      dragprocess(e => {\r\n        const [x, y] = m.graphcoord(e, cx, cy)\r\n        m.camera[1] = cx + (x - o[0]) * m.camera[0]\r\n        m.camera[2] = cy + (y - o[1]) * m.camera[0]\r\n      })\r\n    },\r\n    onfocus: () => m._dom.style.boxShadow = m.focuscolor + '88 0px 0px 20px inset',\r\n    onblur: () => (m._dom.style.boxShadow = '', m.endmove()),\r\n    onkeydown: e => {\r\n      if (e.target !== m._dom) { return }\r\n      e.preventDefault(), e.stopImmediatePropagation()\r\n      m.callhotkey(formatkeyevent(e), e)\r\n    },\r\n    onkeyup: e => {\r\n      if (e.target !== m._dom) { return }\r\n      e.preventDefault(), e.stopImmediatePropagation()\r\n      m.callhotkey(formatkeyevent(e, true), e)\r\n    },\r\n  }, children: [m._canvas = {\r\n    type: 'g', children: [m._vedge = {\r\n      type: 'g', children: [...m.node].map(n => [...n.to.values()]).flat(1),\r\n      filter: 'drop-shadow(0 2px 2px #00000055)'\r\n    }, m._vnode = {\r\n      type: 'foreignObject',\r\n      children: [...m.node], x: 0, y: 0,\r\n      style: `overflow:visible;width:1px;height:1px;`\r\n    }],\r\n    stroke: `rgb(${m.color.join(', ')})`, 'stroke-width': '1px',\r\n    fill: 'none', 'stroke-linecap': 'round',\r\n  }], 'tab-index': 1, style: `outline: none;\r\n    width:100%; height:100%;user-select:none; cursor: grab;\r\n    transition: box-shadow 0.3s; background: #fafafa;` }))\r\n\r\n// graph-node =============================================================================================\r\ncomponent.define('graph-node', (position = [0, 0]) => ({\r\n  from: new Map, to: new Map, position,\r\n  rposition: position.map(v => v + glrd.rd(-1, 1)),\r\n  acceleration: [0, 0], velocity: [0, 0],\r\n  bbox: [0, 0, 0, 0],\r\n}), df => {\r\n  df('link', (m, t, e) => m.parent.link(m, t, e))\r\n  df('unlink', (m, t) => m.parent.unlink(m, t))\r\n  df('del', m => (m.parent.focus(), m.parent.del(m)))\r\n  df('setcolor', (m, c, o = '88') => {\r\n    m._dom.style.boxShadow = c + o + ' 0px 4px 10px'\r\n    m._dragsign._dom.setAttribute('stroke', c)\r\n    m._title._dom.setAttribute('stroke', c)\r\n  })\r\n  df('resetcolor', m => {\r\n    m._dom.style.boxShadow = '#00000044 0px 4px 10px'\r\n    m._dragsign._dom.setAttribute('stroke', m._dragsigncolor)\r\n    m._title._dom.setAttribute('stroke', m._dragsigncolor)\r\n    m._title._dom.setAttribute('fill', m._dragsigncolor)\r\n  })\r\n  df('preupdate', m => {\r\n    const d = m._dom\r\n    m.size = [d.clientWidth, d.clientHeight]\r\n  })\r\n  df('update', m => {\r\n    const x = m.position[0] - m.size[0] / 2\r\n    const y = m.position[1] - 5\r\n    m.bbox = [x, y, x + m.size[0], y + m.size[1]]\r\n    m.center = [m.position[0], y + m.size[1] / 2]\r\n    m._dom.style.transform = `translate(${[x + 'px', y + 'px'].join(', ')})`\r\n    for (const [, e] of m.to) { e.reset() }\r\n  })\r\n  df('focus', m => (m._dom.style.zIndex = '100',\r\n    m.size ? 0 : (m.preupdate(), m.update()),\r\n    m.setcolor(m.parent.focuscolor, '44'),\r\n    m.parent.focusnode = m, m.data.focus?.()))\r\n  df('blur', m => (m.resetcolor(), m._dom.style.zIndex = '',\r\n    m.to.forEach(e => e.reset()), m.from.forEach(e => e.reset()),\r\n    m.parent.focusnode = _, m.data.blur?.(), m.parent.endmove()))\r\n  df('callhotkey', callhotkey)\r\n  df('addtitle', (m, t) => {\r\n    m.settitle(m._title._dom.textContent + t)\r\n  })\r\n  df('settitle', (m, t) => {\r\n    m._title._dom.textContent = t\r\n    const w = m._title._dom.getBBox().width\r\n    m._title._dom.style.transform =\r\n      `translate(calc(50% - ${w / 2}px), calc(50% - 10px))`\r\n  })\r\n  df('quitconnectmode', m => m.parent.setconnectmode(m))\r\n}, m => (m.data.parent = m, m._hotkey = {\r\n  deletetft: () => m.del(),\r\n  qtff: () => m.parent.focus(),\r\n}, m._dragsigncolor = '#666', {\r\n  type: 'div', children:\r\n    [{\r\n      type: 'svg', jsobj: {\r\n        onpointerdown: () => dragprocess(e => {\r\n          m.rposition = m.parent.graphcoord(e)\r\n          m.position = [...m.rposition]\r\n          m.parent.needlayout = m.lock = true\r\n        }, () => delete m.lock),\r\n      }, children: [\r\n        m._dragsign = {\r\n          type: 'path', d: 'M -10 0 L 10 0',\r\n          'stroke-width': '2', stroke: m._dragsigncolor,\r\n          'stroke-linecap': 'round',\r\n          style: `transform:translate(50%, 50%);`\r\n        },\r\n        m._title = {\r\n          type: 'text', stroke: 'none', fill: m._dragsigncolor\r\n        }\r\n      ], style: `width: 100%; height: 10px;\r\n      display: block; cursor: pointer;overflow: visible;`\r\n    }, {\r\n      type: 'div', children: [m.data], style: `\r\n      padding: 10px; padding-top: 0;`\r\n    }], style: `box-shadow: #00000044 0px 4px 10px;\r\n    backdrop-filter: blur(1px); cursor: initial;\r\n    color: #333; transition: box-shadow 0.3s; position: absolute;\r\n    background: linear-gradient(12deg, #0000001f, #00000010);\r\n    min-width: 100px; max-width: 50vw; width: fit-content;\r\n    border-radius: 10px;`\r\n}))\r\n\r\n// graph-edge =============================================================================================\r\ncomponent.define('graph-edge', _, df =>\r\n  df('reset', (e, h = e.parent._horizontal, clr = e.parent.color) => {\r\n    const s = 0.6, c = 10\r\n    const a = e.from.position, b = e.to.position\r\n    if (e.from === e.to) {\r\n      const r = 20, r2 = r * 2, x = a[0], y = a[1]\r\n      e._dom.setAttribute('d', `M ${x + r} ${y} m ${r} 0 ` +\r\n        `a ${r},${r} 0 1,0 ${-r2}, 0 a ${r},${r} 0 1,0 ${r2}, 0 ` +\r\n        `M ${x + r2 + c} ${y + c} L ${x + r2} ${y} L ${x + r2 - c} ${y + c}`)\r\n      e._dom.removeAttribute('stroke')\r\n    } else {\r\n      let dx = b[0] - a[0], dy = b[1] - a[1]\r\n      const mx = a[0] + dx * s, my = a[1] + dy * s\r\n      const l = Math.sqrt(dx * dx + dy * dy)\r\n      const ld = 1 / l; dx *= ld, dy *= ld\r\n      const cl = itp3(clr, [256, ...clr.slice(1)], -(h ? dx : dy) + 0.5)\r\n      e._dom.setAttribute('stroke', `rgb(${cl.join(', ')})`)\r\n      if (l < c) {\r\n        e._dom.setAttribute('d', ['M', ...a, 'L', ...b].join(' '))\r\n      } else {\r\n        dx *= c, dy *= c, e._dom.setAttribute('d', ['M', ...a, 'L', ...b,\r\n          'M', mx + dy, my - dx, 'L', mx + dx, my + dy, 'L', mx - dy, my + dx].join(' '))\r\n      }\r\n    } e._dom.removeAttribute('stroke-width')\r\n  }), _ => ({ type: 'path' }))\r\n\r\n// text-editor ============================================================================================\r\nconst te_keyfilter = new Set('azyxcv'.split('').map(n => n + 'ftf').concat(\r\n  'home end pageup pagedown'.split(' ').map(n => n + 'fft'),\r\n  ...'up down right left'.split(' ').map(n =>\r\n    ['fft', 'ftf', 'ftt'].map(v => 'arrow' + n + v)),\r\n))\r\nconst dfvalue = m => Object.defineProperty(m, 'value', {\r\n  set: v => m._dom.innerHTML = v,\r\n  get: () => m._dom?.innerHTML ?? '',\r\n  enumerable: true\r\n})\r\ncomponent.define('text-editor', (m = {}) => (dfvalue(m), m), df => {\r\n  df('focus', m => m._dom.focus())\r\n  df('blur', m => m._dom.blur())\r\n  df('onload', m => {\r\n    const v = m.value; dfvalue(m)\r\n    setTimeout(() => m.value = v)\r\n  })\r\n}, m => ({\r\n  type: 'div', contentEditable: true, jsobj: {\r\n    onkeydown: (e, k = formatkeyevent(e)) => {\r\n      e.stopImmediatePropagation(); const kf = k.slice(-3)\r\n      if (kf !== 'fff' && kf !== 'fft') {\r\n        if (!te_keyfilter.has(k)) { e.preventDefault() }\r\n      } else if (k === 'tabfff' || k === 'tabfft') { e.preventDefault() }\r\n      m.parent.callhotkey(k, e)\r\n    }, innerHTML: m.value ?? '',\r\n    onkeyup: e => (e.stopImmediatePropagation(),\r\n      m.parent.callhotkey(formatkeyevent(e, true), e)),\r\n    onfocus: () => m.parent.focus(),\r\n    onblur: () => m.parent.blur(),\r\n  }, class: 'text-editor', style: `\r\n    outline: none; overflow: hidden;\r\n    white-space: pre; overflow-wrap: anywhere;` }))\r\n\r\nconst gstyle = dom('style')\r\ngstyle.innerHTML = `\r\ndiv.text-editor * {\r\n  text-wrap: inherit !important;\r\n}`; root.append(gstyle)\r\n\r\nconst path = './test.json'\r\nconst save = async () => {\r\n  const data = component.topod(component.root)\r\n  const root = component.root.id\r\n  const s = JSON.stringify({ data, root })\r\n  const sz = new TextEncoder().encode(s).length / 1000\r\n  log(`File saved on \"${path}\", size ${sz}kB`)\r\n  await write(path, s, true)\r\n  $$.globalsave()\r\n}\r\nconst load = async () => {\r\n  try {\r\n    const { data, root } = JSON.parse(await read(path))\r\n    component.root = component.frompod(data)[root]\r\n  } catch {\r\n    component.root = component.create('graph', m => m.target_length = 150)\r\n  }\r\n}\r\n\r\nawait load()\r\n\r\nlet pt = now()\r\n$.frame = () => {\r\n  const t = now(), dt = t - pt; pt = t\r\n  component.root?.frame(dt)\r\n  component.frame()\r\n}"}