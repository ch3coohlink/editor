{"id":"6d15f5481f4adc8d22ae5a9fe97cd07642891aacaf7be6dfa8994af88fba7e41","to":[],"value":"const _ = undefined\r\nconst now = () => performance.now() / 1000\r\nconst { log, clear } = originconsole\r\n$.log = log\r\nconst rd = await require('../util/random.js')\r\nclear()\r\n\r\nconst local = n => globalThis.location.origin + '/' + n\r\nimportScripts(local('external/opentype.js'))\r\n\r\nconst cvs = await requestcanvas()\r\nconst ctx = cvs.getContext('2d', { willReadFrequently: true })\r\nlet devicePixelRatio = await requestdpi()\r\nlet needresize = true\r\non('canvasresize', () => needresize = true)\r\non('canvasresize', ({ w, h, dpi }) => w !== 0 && h !== 0\r\n  ? (cvs.width = w, cvs.height = h, devicePixelRatio = dpi) : 0)\r\n\r\nlet framecount = 0\r\nconst loop = () => {\r\n  if ($.frame) { framecount++; frame() }\r\n  requestAnimationFrame(loop)\r\n}; requestAnimationFrame(loop)\r\n\r\nconst fonts = {}\r\nconst loadfont = async (n, p) => {\r\n  let font = await fetch(local(p))\r\n  if (font.status !== 200) { throw Error(`Fail to load font file: ${n} at path: ${p}`) }\r\n  font = opentype.parse(await font.arrayBuffer())\r\n  font.defaultglyph = font.glyphs.glyphs[0], fonts[n] = font\r\n  font.scalefactordiv1 = (font.unitsPerEm ?? 1000) / 1000\r\n  font.scalefactor = 1 / font.scalefactordiv1\r\n}\r\n\r\nawait Promise.all([\r\n  loadfont('consolas', 'assets/font/consolas.ttf'),\r\n  loadfont('思源黑体', 'assets/font/SourceHanSansHWSC-Regular.otf'),\r\n])\r\n\r\nconst _segmenter = new Intl.Segmenter(\"en\", { granularity: 'grapheme' })\r\nconst splitunicode = t => Array.from(_segmenter.segment(t), ({ segment }) => segment)\r\nconst drawglyph = g => {\r\n  ctx.beginPath()\r\n  for (const c of g.path.commands) {\r\n    switch (c.type) {\r\n      case 'M': ctx.moveTo(c.x, c.y); break\r\n      case 'L': ctx.lineTo(c.x, c.y); break\r\n      case 'Q': ctx.quadraticCurveTo(c.x1, c.y1, c.x, c.y); break\r\n      case 'C': ctx.bezierCurveTo(c.x1, c.y1, c.x2, c.y2, c.x, c.y); break\r\n      case 'Z': break\r\n      default: log(c); throw Error(`unknown path command type: ${c.type}`)\r\n    }\r\n  }\r\n  ctx.fill()\r\n}\r\nconst defaultglyph = fonts['consolas'].defaultglyph\r\nconst usingfonts = ['consolas', '思源黑体'].map(n => fonts[n]).filter(v => v)\r\nconst drawtext = (t, x, y, px = 10) => {\r\n  const a = splitunicode(t), s = px / 1000\r\n  ctx.save(); ctx.transform(s, 0, 0, -s, x, y)\r\n  for (const t of a) {\r\n    const c = t.codePointAt(0); let usefont, g\r\n    for (const f of usingfonts) {\r\n      const i = f.tables.cmap.glyphIndexMap[c]\r\n      g = f.glyphs.glyphs[i]; if (g) { usefont = f; break }\r\n    } if (!g) { g = defaultglyph, usefont = fonts['consolas'] }\r\n    ctx.scale(usefont.scalefactor, usefont.scalefactor)\r\n    drawglyph(g); ctx.translate(g.advanceWidth, 0)\r\n    ctx.scale(usefont.scalefactordiv1, usefont.scalefactordiv1)\r\n  } ctx.restore()\r\n}\r\n\r\nlog(splitunicode('🕵️‍♀️👸').map(t => t.codePointAt(0)))\r\n\r\n$.frame = () => {\r\n  const t = performance.now() / 1000\r\n  // const s = '🕵️‍♀️👸abc' + (Math.floor(t) % 2 === 0 ? '中文' : ''), x = 20\r\n  const s = '🕵️‍♀️👸abc中文', x = 20\r\n  const cw = cvs.width, ch = cvs.height\r\n  ctx.clearRect(0, 0, cw, ch)\r\n  drawtext(s, x, 100, 100)\r\n  fonts.consolas.draw(ctx, s, x, 200, 100)\r\n  ctx.font = '100px consolas'\r\n  ctx.fillText(s, x, 300)\r\n}"}