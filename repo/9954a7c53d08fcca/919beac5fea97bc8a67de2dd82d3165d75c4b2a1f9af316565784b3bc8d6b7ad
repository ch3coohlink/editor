{"id":"919beac5fea97bc8a67de2dd82d3165d75c4b2a1f9af316565784b3bc8d6b7ad","to":[],"value":"const eventnode = ($ = {}) => {\r\n  $._handles = {}; with ($) {\r\n    let i = 0\r\n    $.emit = (t, ...arg) => {\r\n      const ht = _handles[t]\r\n      if (lock > 0) { da.push((arg.unshift(t), arg)) } else if (ht) {\r\n        const a = [], b = []; for (let [id, f] of ht) {\r\n          f = f.deref ? f.deref() : f; f ? a.push(f) : b.push(id)\r\n        } for (const i of b) { ht.delete(i) }\r\n        for (const f of a) { f(...arg) }\r\n      }\r\n    }; $.on = (t, f) => ((_handles[t] ??= new Map).set(i, f), i++)\r\n    $.onweak = (t, f) => ((_handles[t] ??= new Map).set(i, new WeakRef(f)), i++)\r\n    let da = [], lock = 0\r\n    $.setdelay = (locklevel = 1) => { lock = Math.max(locklevel, lock) }\r\n    $.enddelay = (unlocklevel = 1) => {\r\n      if (unlocklevel < lock) { return }\r\n      lock = 0; for (const a of da) { emit(...a) } da = []\r\n    }\r\n    $.off = (t, id) => _handles[t] ? (_handles[t].delete(id),\r\n      _handles[t].size > 0 ? 0 : delete _handles[t]) : 0\r\n    $.clearevent = () => _handles = {}\r\n  } return $\r\n}\r\nconst solvepath = (b, p) => b + (\r\n  p.startsWith('/') || b === '' || b.endsWith('/') ? '' : '/') + p\r\n\r\nlet i = 0, waitload = new Map\r\nconst call = f => (...a) => {\r\n  let rj, j, p = new Promise((...a) => [, j] = rj = a)\r\n    .finally(() => (clearTimeout(h), waitload.delete(id)))\r\n  const id = i++; send('$function$' + f, (a.id = id, a))\r\n  const h = setTimeout(() => j(a), 5000)\r\n  waitload.set(id, rj); return p\r\n}\r\nconst callvoid = f => (...a) =>\r\n  send('$voidfunction$' + f, a)\r\n\r\nconst _log = callvoid('console.log')\r\nconst _error = callvoid('console.error')\r\nconst _clear = callvoid('console.clear')\r\nglobalThis.originconsole = console\r\nglobalThis.console = { log: _log, error: _error, clear: _clear }\r\n\r\nconst read = globalThis.rawread = call('$.__sandbox__.read')\r\nconst write = globalThis.rawwrite = call('$.__sandbox__.write')\r\nglobalThis.__sandbox__ = { read, write }\r\nglobalThis.read = call('read')\r\nglobalThis.write = call('write')\r\nglobalThis.__read__ = (v, b, fst) => (p, opt) =>\r\n  read(v, solvepath(b, p), fst, opt, !(opt?.raw))\r\nglobalThis.__write__ = (v, b, fst) => (p, t, force) =>\r\n  write(v, solvepath(b, p), t, fst, force)\r\nglobalThis.__require = (v, b, fst) => async (ph, p = solvepath(b, ph)) => {\r\n  const data = await load(v, p, fst, { watch: true }), file = data.id\r\n  if (loaded.has(file)) { return loaded.get(file) }\r\n  const ex = await exec(...data); loaded.set(file, ex); return ex\r\n}\r\nglobalThis.requestcanvas = call('requestcanvas')\r\n\r\nconst env = eventnode()\r\nconst loaded = new Map, AF = (async () => { }).constructor\r\nconst exec = (ver, path, src, first = false) => new AF('$',\r\n  `//# sourceURL=${ver.slice(0, 16) + '/' + path}\\nconst __repoid = '${ver}'\\n` +\r\n  `const __dirname = '${path.split('/').slice(0, -1).join('/')}'\\n` +\r\n  `const readlocal = __read__(__repoid, __dirname, ${first})\\n` +\r\n  `const writelocal = __write__(__repoid, __dirname, ${first})\\n` +\r\n  `const require = __require(__repoid, __dirname, ${first})\\n` +\r\n  `with($) {\\n${src}\\n}\\n return $`)(Object.create(env))\r\n\r\nconst send = (t, o = {}, ...a) => {\r\n  if (Array.isArray(o)) { o = { a: o, isarr: true } }\r\n  postMessage((o.type = t, o), a)\r\n}\r\naddEventListener('message', e => {\r\n  let o = e.data\r\n  if (o.isarr) { o.a.type = o.type; o = o.a }\r\n  if (o.type === 'init') { exec(...o, true) }\r\n  else if (o.type === 'callfin') {\r\n    if (waitload.has(o.id)) {\r\n      waitload.get(o.id)[0](o.r)\r\n    }\r\n  } else if (o.type === 'canvasresize') {\r\n    env.emit('canvasresize', o)\r\n  } else if (o.type === 'error') {\r\n    if (waitload.has(o.id)) {\r\n      waitload.get(o.id)[1](o.error)\r\n    } // _error(o.error)\r\n    throw o.error\r\n  }\r\n})\r\nsetInterval(() => send('heartbeat'), 500)\r\n// addEventListener('error', _error)"}