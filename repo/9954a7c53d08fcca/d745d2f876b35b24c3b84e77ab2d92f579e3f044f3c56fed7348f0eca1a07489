{"id":"d745d2f876b35b24c3b84e77ab2d92f579e3f044f3c56fed7348f0eca1a07489","to":[],"value":"// 04.js - moving to svg\r\n\r\n{ // basic\r\n  let hexenc = b => [...b].map(v => v.toString(16).padStart(2, '0')).join(\"\")\r\n  $.uuid = (d = 32) => hexenc(crypto.getRandomValues(new Uint8Array(d)))\r\n  let { imul } = Math, mb32 = a => t =>\r\n    (a = a + 1831565813 | 0,\r\n      t = imul(a ^ a >>> 15, 1 | a),\r\n      t = t + imul(t ^ t >>> 7, 61 | t) ^ t,\r\n      (t ^ t >>> 14) >>> 0) / 4294967296\r\n  $.genrd = (seed, _rd = mb32(seed)) => {\r\n    let { log, cos, sqrt, ceil, PI } = Math\r\n    let rd = (a = 1, b) => (b ? 0 : (b = a, a = 0), _rd() * (b - a) + a)\r\n    let rdi = (a, b) => ceil(rd(a, b))\r\n    let gaussian = (mean = 0, stdev = 1) => {\r\n      let u = 1 - rd(), v = rd()\r\n      let z = sqrt(-2.0 * log(u)) * cos(2.0 * PI * v)\r\n      return z * stdev + mean\r\n    } // Standard Normal variate using Box-Muller transform\r\n    return { rd, rdi, gaussian }\r\n  }\r\n  let { max, min } = Math; $.clamp = (v, s, l) => max(min(v, l), s)\r\n  $.dom = n => document.createElement(n)\r\n  $.svg = n => document.createElementNS('http://www.w3.org/2000/svg', n)\r\n} { // time & frame\r\n  $.time = { current: 0, delta: 0, maxdelta: 1 / 60 }\r\n  time.now = () => performance.now() / 1000\r\n  const frame = t => {\r\n    let pt = time.current, ct = time.current = t / 1000\r\n    time.realdelta = Math.min(ct - pt, time.maxdelta)\r\n    time.delta = time.maxdelta * 3\r\n    requestAnimationFrame(frame); loop()\r\n  }; requestAnimationFrame(frame)\r\n} { // global pointer event\r\n  let fs = [], mfs = new Set\r\n  let u = e => { for (const f of fs) { f(e) } fs = [] }\r\n  let m = e => { for (const f of mfs) { f(e) } }\r\n  $.listenpointerdown = (e, f) => (\r\n    e.addEventListener('mousedown', f),\r\n    e.addEventListener('touchstart', f))\r\n  $.listenpointerup = f => fs.push(f)\r\n  $.listenpointermove = f => mfs.add(f)\r\n  $.stoplistenmove = f => mfs.delete(f)\r\n  on('pointerup', u)\r\n  on('touchend', u)\r\n  on('pointermove', m)\r\n  on('touchmove', m)\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n$.graph = ($ = { g: {}, i: 0 }) => {\r\n  with ($) {\r\n    $.addnode = (id = i++) => {\r\n      g[id] = { id, to: {}, from: {}, nto: 0, nfrom: 0 }\r\n      newnodeelm(g[id]); return id\r\n    }; $.delnode = (id, n = g[id]) => {\r\n      for (const k in n.to) { deledge(id, k) } delete g[id]\r\n      for (const k in n.from) { deledge(k, id) } n.elm.remove()\r\n    }; $.addedge = (a, b) => {\r\n      g[a].to[b] = { o: g[b] }, g[b].from[a] = g[a]\r\n      g[a].nto++, g[b].nfrom++, newedgeelm(g[a], g[b])\r\n    }; $.deledge = (a, b) => {\r\n      g[a].to[b].elm.remove(), g[a].nto--, g[b].nfrom--\r\n      delete g[a].to[b], delete g[b].from[a]\r\n    }\r\n  } return $\r\n}\r\n$.spawnrange = 200\r\n$.newpos = (n, d = n.data) => {\r\n  d.pos = { x: rd(-1, 1) * spawnrange, y: rd(-1, 1) * spawnrange }\r\n  d.vec = { x: 0, y: 0 }, d.acc = { x: 0, y: 0 }\r\n  d.mat = 1, d.ecc = 1; return n\r\n}\r\n$.layout = ns => {\r\n  const { sqrt, max, min, sign, abs } = Math\r\n  const electric = (b, p, ad, ap, m = 1) => {\r\n    const bd = b.data, bp = bd.pos\r\n    const pdx = bp.x - ap.x, pdy = bp.y - ap.y\r\n    const lsq = max(pdx * pdx + pdy * pdy, m), l = sqrt(lsq)\r\n    const f = ad.ecc * bd.ecc / lsq * p / l\r\n    const fx = f * pdx, fy = f * pdy\r\n    ad.acc.x += fx / ad.mat, ad.acc.y += fy / ad.mat\r\n    bd.acc.x -= fx / bd.mat, bd.acc.y -= fy / bd.mat\r\n  }\r\n  const distance = (b, p, ad, ap) => {\r\n    const bd = b.data, bp = bd.pos\r\n    const pdx = bp.x - ap.x, pdy = bp.y - ap.y\r\n    const fx = p * pdx, fy = p * pdy\r\n    ad.acc.x += fx / ad.mat, ad.acc.y += fy / ad.mat\r\n    bd.acc.x -= fx / bd.mat, bd.acc.y -= fy / bd.mat\r\n  }\r\n  const gravity = newpos({ data: {} }); total_speed = 0\r\n  gravity.data.pos.x = gravity.data.pos.y = 0\r\n  let tl = target_length, ts = target_speed\r\n  let ep = -(tl ** 2) * ts, ed = 1 / tl * ts * 20\r\n  for (let i = 0, l = ns.length; i < l; i++) {\r\n    const a = ns[i], ad = a.data, ap = ad.pos\r\n    for (let j = i + 1; j < l; j++) { electric(ns[j], ep, ad, ap) }\r\n    for (const k in a.to) { distance(a.to[k].o, ed / a.nto, ad, ap) }\r\n    if (ad.hardlock) { ad.vec.x = ad.vec.y = 0; continue }\r\n    distance(gravity, 0.05 * ed, ad, ap)\r\n    let vx = ad.vec.x + ad.acc.x * time.delta\r\n    let vy = ad.vec.y + ad.acc.y * time.delta\r\n    let v = sqrt(vx * vx + vy * vy), vrx = vx / v, vry = vy / v\r\n    total_speed += v = max(min(v, ts) - ts * friction, 0)\r\n    ad.vec.x = vx = v * vrx, ad.vec.y = vy = v * vry\r\n    if (ad.lock) { ad.vec.x = ad.vec.y = 0; continue }\r\n    ap.x += vx * time.delta, ap.y += vy * time.delta\r\n    ad.oldacc = { ...ad.acc }, ad.acc.x = ad.acc.y = 0\r\n  }\r\n}\r\n$.target_length = 125, $.target_speed = 250, $.friction = 0.01\r\n$.draw = ns => {\r\n  const w = se.clientWidth, h = se.clientHeight\r\n  const x = w / 2 + camera.x, y = h / 2 + camera.y\r\n  const transtr = `translate(${sorigin.x}, ${sorigin.y}) scale(${camera.s}) translate(${x}, ${y})`\r\n  sep.setAttribute('transform', transtr)\r\n  sen.setAttribute('transform', transtr)\r\n  for (const n of ns) {\r\n    const { x, y } = n.data.pos, e = n.elm\r\n    e.setAttribute('cx', x), e.setAttribute('cy', y)\r\n    // e.setAttribute('r', (circlesize / camera.s) + 'px')\r\n    for (const k in n.to) {\r\n      const b = n.to[k], bp = b.o.data.pos, e = b.elm\r\n      e.setAttribute('d', `M ${x} ${y} L ${bp.x} ${bp.y}`)\r\n      // e.setAttribute('stroke-width', linewidth / camera.s + 'px')\r\n    }\r\n  }\r\n}\r\n$.total_speed = 0, $.total_accelaration = 0, $.stop = false\r\n$.loop = () => {\r\n  const ns = [], _g = g.g; for (const k in _g) {\r\n    const n = _g[k]; if (!n.data) { n.data = {} } const d = n.data\r\n    if (!d.pos) { newpos(n) } ns.push(n)\r\n  } if (!stop) { layout(ns); layouttime += time.realdelta } draw(ns)\r\n  if (total_speed === 0) { if (!stop) { log('end in: ' + layouttime.toFixed(3) + 's') } stop = true }\r\n}\r\n$.camera = { x: 0, y: 0, s: 1 }\r\n$.sorigin = { x: 0, y: 0 } // scale origin\r\n$.screen2svgcoord = (c = camera) => (x, y) => {\r\n  const { left, top } = se.getBoundingClientRect()\r\n  const w = se.clientWidth, h = se.clientHeight\r\n  x = (x - left - sorigin.x) / camera.s - (c.x + w / 2)\r\n  y = (y - top - sorigin.y) / camera.s - (c.y + h / 2)\r\n  return { x, y }\r\n}\r\n\r\nconst sty = dom('style'); sty.innerHTML =\r\n  `svg circle:hover { fill: red; }` +\r\n  `svg { touch-action: none; }`\r\n$.se = svg('svg'); root.append(se)\r\nse.style.display = 'block', se.style.height = se.style.width = '100%'\r\n$.sep = svg('g'), $.sen = svg('g'); se.append(sep, sen, sty)\r\nlistenpointerdown(se, e => {\r\n  if (e.target !== se) { return }\r\n  const c = { ...camera }, s = screen2svgcoord(c)\r\n  const o = s(...geteventlocation(e)), m = e => {\r\n    if (e.touches && e.touches.length > 2) { return a_run() }\r\n    if (e.touches && e.touches.length === 2) { return pinch(e) }\r\n    const { x, y } = s(...geteventlocation(e))\r\n    camera.x = c.x + x - o.x, camera.y = c.y + y - o.y\r\n  }; listenpointermove(m), listenpointerup(() => (\r\n    ipd = false, stoplistenmove(m)))\r\n})\r\n$.ipd = false // inital pinch distance\r\n$.pinch = e => {\r\n  let a = { x: e.touches[0].clientX, y: e.touches[0].clientY }\r\n  let b = { x: e.touches[1].clientX, y: e.touches[1].clientY }\r\n  let d = Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2)\r\n  if (ipd === false) { ipd = d }\r\n  if (d === ipd) { return } const r = d / ipd; ipd = d\r\n  zoom([(a.x + b.x) / 2, (a.y + b.y) / 2], r)\r\n}\r\nse.addEventListener('wheel', (e, r = 1.2) => e.deltaY < 0\r\n  ? zoom(geteventlocation(e), r) : zoom(geteventlocation(e), 1 / r))\r\n$.zoom = ([x, y], f, s) => (s = camera.s,\r\n  camera.s = s * f, f = camera.s / s,\r\n  sorigin.x = x - (x - sorigin.x) * f,\r\n  sorigin.y = y - (y - sorigin.y) * f)\r\n$.circlesize = 7, $.linewidth = 1\r\n$.newnodeelm = n => {\r\n  const c = svg('circle')\r\n  c.setAttribute('fill', 'black')\r\n  c.setAttribute('r', circlesize + 'px')\r\n  listenpointerdown(c, e => {\r\n    if (e.target !== c) { return } const m = e => {\r\n      if (e.touches && e.touches.length > 1) { return }\r\n      c.setAttribute('fill', 'red')\r\n      const { x, y } = screen2svgcoord()(...geteventlocation(e))\r\n      n.data.pos.x = x, n.data.pos.y = y, n.data.lock = true\r\n      stop = false, layouttime = 0\r\n    }; listenpointermove(m), listenpointerup(() => (\r\n      c.setAttribute('fill', 'black'),\r\n      delete n.data.lock, stoplistenmove(m)))\r\n  })\r\n  n.elm = c, sen.append(c)\r\n}\r\n$.newedgeelm = (a, b) => {\r\n  const p = svg('path')\r\n  p.setAttribute('stroke', 'black')\r\n  p.setAttribute('stroke-width', linewidth + 'px')\r\n  a.to[b.id].elm = p, sep.append(p)\r\n}\r\n$.geteventlocation = e => e.touches && e.touches.length == 1 ?\r\n  [e.touches[0].pageX, e.touches[0].pageY] : [e.pageX, e.pageY]\r\n\r\nconst gengraph = (l = 10) => {\r\n  const g = graph(), { floor, abs } = Math, ids = []\r\n  for (let i = 0; i < l; i++) { ids.push(g.addnode()) }\r\n  for (let i = 0; i < l; i++) {\r\n    let r = floor(abs(gaussian(0, 2)) * 1) + (rd() > 0.5 ? 1 : 0)\r\n    const a = ids[i], s = [...ids]\r\n    for (let j = 0; j < r && s.length > 0; j++)\r\n      g.addedge(a, s.splice(floor(rd(s.length)), 1)[0])\r\n  } return g\r\n}\r\n\r\nlet seed = Math.floor(4294967296 * Math.random())\r\n$.drawforce = false, $.startseed = seed\r\nconst a_run = () => {\r\n  console.clear(); log('startseed: ' + startseed, 'seed: ' + seed)\r\n  const grd = genrd(seed), base = 25\r\n  sep.innerHTML = sen.innerHTML = ''\r\n  $.rd = grd.rd, $.gaussian = grd.gaussian, $.rdi = grd.rdi\r\n  $.g = gengraph(Math.floor(Math.abs(gaussian() * base) + rdi(base) + 5))\r\n  stop = false, $.layouttime = 0\r\n  seed = Math.floor(4294967296 * rd())\r\n  // setTimeout(a_run, 60 / 185 * 1000 * rdi(0, 3))\r\n}; a_run()\r\n\r\nse.onkeydown = () => { a_run() }"}