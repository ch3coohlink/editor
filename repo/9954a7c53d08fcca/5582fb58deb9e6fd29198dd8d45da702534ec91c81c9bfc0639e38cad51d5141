{"id":"5582fb58deb9e6fd29198dd8d45da702534ec91c81c9bfc0639e38cad51d5141","to":[],"value":"const jsmime = 'application/javascript'\r\nconst bootworker = (src, url) => {\r\n  url ??= URL.createObjectURL(new Blob([src], { type: jsmime }))\r\n  return new Worker(url)\r\n}\r\nconst loadsrc = async (p, type = jsmime) => {\r\n  let [ver, path, src] = await readlocal(p, { raw: true, watch: true })\r\n  if (type === jsmime) {\r\n    src = `//# sourceURL=${ver.slice(0, 16) + '/' + path}\\n` + src\r\n  } return URL.createObjectURL(new Blob([src], { type }))\r\n}\r\n\r\nconst w = bootworker(undefined, await loadsrc('./worker.js'))\r\nconst send = (t, o, a) => {\r\n  if (Array.isArray(o)) { o = { a: o, isarr: true } }\r\n  w.postMessage((o.type = t, o), a)\r\n}\r\n\r\nlet canvasrequested = false\r\nconst requestcanvas = o => {\r\n  if (canvasrequested) { return }\r\n  const cvs = document.createElement('canvas')\r\n  cvs.style.imageRendering = 'pixelated'\r\n  cvs.style.width = cvs.style.height = '100%'\r\n  root.append(cvs) // TODO: input event\r\n  // cvs.addEventListener('keydown')\r\n  // cvs.addEventListener('keyup')\r\n  // cvs.addEventListener('pointerdown')\r\n  // cvs.addEventListener('pointerup')\r\n  // cvs.addEventListener('pointermove')\r\n  // cvs.addEventListener('pointerenter')\r\n  // cvs.addEventListener('pointerleave')\r\n\r\n  const resize = () => {\r\n    let changed = false\r\n    const w = root.clientWidth, h = root.clientHeight\r\n    const r = window.devicePixelRatio\r\n    const wr = Math.floor(w * r), hr = Math.floor(h * r)\r\n    if (cvs.width !== wr) { changed = true }\r\n    if (cvs.height !== hr) { changed = true }\r\n    cvs.style.width = (wr / r) + 'px'\r\n    cvs.style.height = (hr / r) + 'px'\r\n    if (changed) { send('canvasresize', { w: wr, h: hr, dpi: r }) }\r\n  }; {\r\n    const w = root.clientWidth, h = root.clientHeight\r\n    const r = window.devicePixelRatio\r\n    const wr = Math.floor(w * r), hr = Math.floor(h * r)\r\n    if (cvs.width !== wr) { cvs.width = wr }\r\n    if (cvs.height !== hr) { cvs.height = hr }\r\n    cvs.style.width = (wr / r) + 'px'\r\n    cvs.style.height = (hr / r) + 'px'\r\n  } new ResizeObserver(resize).observe(root)\r\n  const offcvs = cvs.transferControlToOffscreen()\r\n  canvasrequested = true\r\n  return { r: offcvs, __transfer__: [offcvs] }\r\n}\r\n\r\nconst fs = '$function$', vfs = '$voidfunction$'\r\nw.addEventListener('message', async e => {\r\n  let o = e.data; if (o.isarr) { o.a.type = o.type; o = o.a }\r\n  if (o.type.startsWith(fs)) {\r\n    const fn = o.type.slice(fs.length)\r\n    const r = await (eval(fn)(...o))\r\n    if (!r?.__transfer__) { send('callfin', { r, id: o.id }) }\r\n    else { send('callfin', { r: r.r, id: o.id }, r.__transfer__) }\r\n  } else if (o.type.startsWith(vfs)) {\r\n    const fn = o.type.slice(vfs.length)\r\n    await (eval(fn)(...o))\r\n  } else if (o.type === 'heartbeat') {\r\n    alive = performance.now()\r\n    resetlight()\r\n  } else { throw Error(`unknown type: ${o.type}`) }\r\n})\r\n\r\n$.loadworker = async p =>\r\n  send('init', await read(p, { raw: true, watch: true }))\r\n\r\nlet alive = performance.now()\r\nconst light = document.createElement('div')\r\nconst resetlight = () => {\r\n  light.textContent = 'ðŸŸ¢'\r\n  light.style.position = 'absolute'\r\n  light.style.top = '-100px'\r\n  light.style.right = '-100px'\r\n  light.style.transition = 'all 0.2s'\r\n}; resetlight()\r\nsetInterval(() => {\r\n  if (alive + 1100 < performance.now()) {\r\n    light.textContent = 'ðŸ”´'\r\n    light.style.top = '0px'\r\n    light.style.right = '0px'\r\n  }\r\n}, 1000)\r\nroot.style.overflow = 'hidden'\r\nroot.style.position = 'relative'\r\nroot.append(light)"}