{"id":"2ef66b178410eef776cd4549a395f5cfe115c94ad815746ec8a39dc70f6b9dfc","to":[],"value":"Object.assign($, await require('common.js'))\r\nconst rd = await require('random.js')\r\nconst cvs2d = await require('canvas2d.js')\r\n\r\n$.dragprocess = (move, cancel) => {\r\n  let mi = on('pointermove', e => move((e.mousepos = mousepos, e)))\r\n  let ui = on('pointerup', e => (off('pointermove', mi),\r\n    off('pointerup', ui), cancel?.((e.mousepos = mousepos, e))))\r\n}\r\n$.getbbox = v => {\r\n  // TODO: rotate and scale not considered\r\n  const left = v.transform.e\r\n  const top = v.transform.f\r\n  const [width, height] = v.size\r\n  const right = left + width\r\n  const bottom = top + height\r\n  return { left, top, right, bottom, width, height }\r\n}\r\n\r\nconst id2color = i =>\r\n  '#' + [...new Uint8Array((new Uint32Array([i])).buffer)\r\n  ].slice(0, 3).map(v => v.toString(16).padStart(2, '0')).join('')\r\n\r\nconst globalenv = $\r\n$.component = (($ = {}) => {\r\n  with ($) {\r\n    $.globalenv = Object.create(globalenv)\r\n    globalenv.component = $\r\n    $.definition = {}, $.dirty = new Set, $.dirtyarray = []\r\n    $.markdirty = m => {\r\n      if (dirty.has(m)) { return }\r\n      dirty.add(m); dirtyarray.push(m)\r\n    }\r\n    const cdae = n => Error(`component definition \"${n}\" already exists.`)\r\n    const cdne = n => Error(`component definition \"${n}\" not exists.`)\r\n    $.define = (n, m = {}, tf, v = () => { }, d) => {\r\n      if (definition[n]) { throw adae(n) }\r\n      v = new Function('$', `with($) {\\nreturn ${v.toString()}\\n}`)(globalenv)\r\n      if (typeof m === 'function') { m = m() }\r\n      if (m.recordhistory) { m.history = [] }\r\n      m.type = n, m._iscomp = true\r\n      let t = {}; if (typeof tf === 'function')\r\n        tf((n, f, mkdirty = true, history = true) => t[n] = new Function('$',\r\n          `with($) {\\nconst __f__ = ${f.toString()}\r\nconst __rf__ = function (...a) {\\nconst m = this, r = __f__(m, ...a)\r\n// TODO: a should be serialized since it could contain something like component\r\nif(${history} && m.recordhistory) { m.history.push([${n}, a]) }\r\nif(__rf__.markdirty) { component.markdirty(m) }\\nreturn r\\n}\r\n__rf__.markdirty = ${!!mkdirty}\\nreturn __rf__\\n}`)(globalenv))\r\n      definition[n] = { m, v, t, d }\r\n      return (...a) => create(n, ...a)\r\n    }\r\n    $.definewatch = (n, m, v, tf, d) => {\r\n      const _tf = df => df('watch', (w, m) => ((m.watchers ??= new Set).add(w), w), false)\r\n      if (!tf) { tf = _tf } else { tf = df => { tf(df); _tf(df) } }\r\n      m._iswatch = true; define(n, m, v, tf, d)\r\n      return (...a) => create(n, ...a)\r\n    }\r\n    $.create = (n, f) => {\r\n      if (!definition[n]) { throw cdne(n) }\r\n      const d = definition[n], m = deepclone(d.m); m.id = rd.uuid()\r\n      Object.setPrototypeOf(m, d.t) // TODO: not sure whether this is slow or not\r\n      if (typeof f === 'function') { f(m) }\r\n      return m\r\n    }\r\n    $.clone = (m, mixin) => {\r\n\r\n    }\r\n    const watchtype = new Map\r\n    $.watch = (m, f) => {\r\n      let fs = f.toString(), n\r\n      if (n = watchtype.get(fs)) { return create(n).watch(m) }\r\n      watchtype.set(fs, n = 'watch-' + rd.uuid())\r\n      return definewatch(n, {}, f)().watch(m)\r\n    }\r\n    $.on = (m, en, f) => {\r\n      m.event ??= { id: 0 }\r\n      const id = m.event.id++\r\n      m.event[en] ??= new Map\r\n      let fs = f.toString(), n, o\r\n      if (n = watchtype.get(fs)) { o = create(n) } else {\r\n        watchtype.set(fs, n = 'event-' + rd.uuid())\r\n        o = define(n, {}, f)()\r\n      } m.event[en].set(id, o)\r\n      return id\r\n    }\r\n    $.emit = (m, en, ...a) =>\r\n      m.event[en].forEach(({ type }) => definition[type].v(m, ...a))\r\n\r\n    // update ------------------------------------------------------------------\r\n    $.objarray = [], $.oldobjarr = []\r\n    $.mouseid = 0, $.mousecomp = _\r\n    $.mousepos = [0, 0], $.mouseevent = false\r\n    $.bindcvs = cvs => {\r\n      $.cvs = cvs, $.ctx = cvs.ctx\r\n      globalenv.on('pointerrawupdate', async e => {\r\n        const b = await cvs.getBoundingClientRect()\r\n        mousepos[0] = (e.pageX - b.left) * cvs.dpi\r\n        mousepos[1] = (e.pageY - b.top) * cvs.dpi\r\n        e.mousepos = mousepos\r\n        mouseevent = e\r\n      })\r\n      cvs.on('pointerdown', () => {\r\n        if (!mousecomp) { return }\r\n        emit(mousecomp, 'pointerdown', mouseevent)\r\n      })\r\n      return $\r\n    }\r\n    const collectobj = c => {\r\n      if (Array.isArray(c)) { c.forEach(collectobj) }\r\n      else switch (c.type) {\r\n        case 'rect': case 'text': case 'path':\r\n          objarray.push([ctx.getTransform(), c]); break\r\n        case 'component': {\r\n          ctx.save(); c.position ? ctx.translate(...c.position) : 0\r\n          c.transform ? ctx.transform(...c.transform) : 0\r\n          const v = c.comp._view ??= definition[c.comp.type].v(c.comp)\r\n          if (!v) { throw Error(`component \"${c.comp.type}\" has no view output.`) }\r\n          c.transform = ctx.getTransform(); c.size = c.comp._size\r\n          collectobj(v); ctx.restore()\r\n        } break\r\n        default: { log(c); throw Error(`wrong view type \"${c.type}\"`) }\r\n      }\r\n    }\r\n    let updated = false; $.update = () => {\r\n      updated = dirtyarray.length > 0\r\n      let c; while (c = dirtyarray.shift()) {\r\n        if (!dirty.has(c)) { continue }\r\n        const d = definition[c.type]\r\n        if (!d) { throw cdne(c.type) }\r\n        c._view = d.v(c)\r\n        if (c.watchers) for (const w of c.watchers) {\r\n          const d = definition[w.type]\r\n          if (!d) { throw cdne(w.type) }\r\n          w._view = d.v(w, c)\r\n        } dirty.delete(c)\r\n      } if (updated) {\r\n        oldobjarr = objarray; objarray = []\r\n        if (!$.root) { return }\r\n        ctx.resetTransform()\r\n        collectobj($.root._view)\r\n      }\r\n    }\r\n    const draw = c => {\r\n      switch (c.type) {\r\n        case 'text': cvs2d.drawtext(cvs.ctx, ...c.args); break\r\n        case 'rect': ctx.fillRect(...c.args); break\r\n        case 'path': {\r\n          ctx.beginPath()\r\n          for (const [t, ...a] of c.args) {\r\n            switch (t) {\r\n              case 'M': case 'm': ctx.moveTo(...a); break\r\n              case 'L': case 'l': ctx.lineTo(...a); break\r\n              case 'Q': case 'q': ctx.quadraticCurveTo(...a); break\r\n              case 'C': case 'c': ctx.bezierCurveTo(...a); break\r\n              default: throw Error(`unknown path command type: ${c.type}`)\r\n            }\r\n          } switch (c.draw) {\r\n            case 'fill': ctx.fill(); break\r\n            case 'both': ctx.fill(); ctx.stroke(); break\r\n            case 'both-reverse': ctx.stroke(); ctx.fill(); break\r\n            case 'stroke': default: ctx.stroke(); break\r\n          }\r\n        } break\r\n        default: throw Error(`wrong view type \"${c.type}\"`)\r\n      }\r\n    }\r\n    $.render = () => {\r\n      let m, c, id = 1\r\n      const id2comp = {}\r\n      const cw = cvs.width, ch = cvs.height\r\n      ctx.reset(); ctx.clearRect(0, 0, cw, ch)\r\n      for (let i = 0, l = objarray.length; i < l; i++) {\r\n        [m, c] = objarray[i]\r\n        if (!c.pointerevent) { continue }\r\n        id2comp[id] = c.eventtarget\r\n        ctx.fillStyle = id2color(id); id += 50\r\n        ctx.setTransform(m); draw(c)\r\n      }\r\n      const r = ch / 2, t = now()\r\n      const mousecolor = ctx.getImageData(...mousepos.map(Math.floor), 1, 1).data\r\n      mousecolor[3] = 0; id = new Uint32Array(mousecolor.buffer)[0]\r\n      const comp = id2comp[id]; if (mouseid !== id) {\r\n        if (comp) { emit(comp, 'pointerenter', mouseevent) }\r\n        if (mousecomp) { emit(mousecomp, 'pointerleave', mouseevent) }\r\n      } mouseid = id, mousecomp = comp\r\n      // if (deepequal(oldobjarr, objarray)) { return }\r\n      ctx.reset(); ctx.clearRect(0, 0, cw, ch)\r\n      for ([m, c] of objarray) {\r\n        ctx.strokeStyle = c.color ?? 'black'\r\n        ctx.fillStyle = c.color ?? 'black'\r\n        ctx.setTransform(m); draw(c)\r\n      } oldobjarr = objarray\r\n    }\r\n    $.frame = () => {\r\n      const cw = cvs.width, ch = cvs.height\r\n      if (cvs.needresize && $.root) {\r\n        root._size = [cw, ch]\r\n        markdirty(root)\r\n        cvs.needresize = false\r\n      } update(); render()\r\n    }\r\n    $.destroy = () => { }\r\n    $.animation = () => { }\r\n    $.serialize = () => { }\r\n    $.deserialize = () => { }\r\n  } return $\r\n})()"}