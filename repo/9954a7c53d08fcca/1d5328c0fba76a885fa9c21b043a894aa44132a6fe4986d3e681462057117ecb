{"id":"1d5328c0fba76a885fa9c21b043a894aa44132a6fe4986d3e681462057117ecb","to":[],"value":"Object.assign($, await require('../util/common.js'))\r\nconst compsys = await require('../util/component.js')\r\nconst grd = await require('../util/random.js')\r\nconsole.clear()\r\n\r\nlet framecount = 0\r\nconst loop = () => {\r\n  if ($.frame) { framecount++; frame() }\r\n  requestAnimationFrame(loop)\r\n}; requestAnimationFrame(loop)\r\n\r\n$.cvs = await createcanvas()\r\n$.ctx = cvs.getContext('2d', { willReadFrequently: true })\r\n$.component = compsys.createcomponentsystem({ cvs, ctx })\r\nObject.defineProperty(component.globalenv, 'framecount', { get: () => framecount })\r\n\r\ncomponent.define('graph', {\r\n  direction: 'horizontal',\r\n  node: [], edge: [], vnode: [], vedge: [],\r\n}, df => (\r\n  df('add', (m, d, n = component.create('graph-node',\r\n    nm => (nm.parent = m, nm.data = d, nm.ranksum = 0, nm.rankcount = 0))) =>\r\n    (m.graphmoded = true, m.node.push(n), n)),\r\n  df('link', (m, a, b, d, e = component.create('graph-edge',\r\n    em => (em.parent = m, em.from = a, em.to = b, em.data = d))) =>\r\n    (m.graphmoded = true, a.to.push(e), b.from.push(e), m.edge.push(e), e))),\r\n  m => {\r\n    const h = m.direction === 'horizontal'; let r\r\n    m._horizontal = h\r\n    const base = 200\r\n    if (m.rankchanged) {\r\n      const nvs = m.node.map(comp => ({ type: 'component', comp }))\r\n      const evs = m.edge.map(comp => ({ type: 'component', comp }))\r\n      // TODO: sub graph\r\n      const narr = m.node.sort((a, b) => b.rank - a.rank)\r\n      const { min, max } = Math; let maxv = -Infinity, minv = Infinity\r\n      for (const n of narr) (maxv = max(maxv, n.rank), minv = min(minv, n.rank))\r\n      let position = 0, lastrank = 1\r\n      for (let i = 0, l = narr.length; i < l; i++) {\r\n        const rank = (narr[i].rank - minv) / (maxv - minv)\r\n        position += base * (lastrank - rank); lastrank = rank\r\n        narr[i].position = nvs[i].position = h ? [position, 0] : [0, position]\r\n      } m.edge.forEach(component.markdirty)\r\n      m.rankchanged = m.graphmoded = false\r\n      r = { type: 'component', comp: { _view: [...evs, ...nvs] } }\r\n    } else { r = m._view } r.position = h\r\n      ? [(m._size[0] - base) / 2, m._size[1] / 2]\r\n      : [m._size[0] / 2, (m._size[1] - base) / 2]\r\n    return r\r\n  })\r\nconst rankrd = grd.genrd()\r\nconst splitgraph = m => {\r\n  m.subgraph = []; let seen = new Set, sub = 0\r\n  for (let i = 0, l = m.node.length; i < l; i++) {\r\n    let n = m.node[i]; if (seen.has(n)) { continue }\r\n    const s = m.subgraph[sub++] = [], q = [n]\r\n    while (n = q.shift()) {\r\n      if (seen.has(n)) { continue } s.push(n), seen.add(n)\r\n      q.push(...n.to.map(e => e.to), ...n.from.map(e => e.from))\r\n    }\r\n  }\r\n}\r\nconst rankgraph = (m, l = 10000) => {\r\n  if (m.graphmoded) { splitgraph(m); m.converged = false }\r\n  if (m.converged) { return }\r\n\r\n  const { rdi } = rankrd\r\n  for (const g of m.subgraph) for (let i = 0; i < l; i++) {\r\n    const q = [[g[rdi(g.length)], 0]], seen = new Set\r\n    while (q.length > 0) {\r\n      const [n, d] = q.splice(rdi(q.length), 1)[0]\r\n      if (seen.has(n)) { continue } seen.add(n)\r\n      n.ranksum += d, q.push(\r\n        ...n.to.map(e => [e.to, d - 1]),\r\n        ...n.from.map(e => [e.from, d + 1]))\r\n    }\r\n  }\r\n  let d = 0; for (const n of m.node) {\r\n    n.rankcount ??= 0, n.rankcount += l\r\n    n.rank ??= 0; const or = n.rank\r\n    n.rank = n.ranksum / n.rankcount\r\n    d += Math.abs(n.rank - or)\r\n  } if (d < 0.0001) { m.converged = true; log(framecount) }\r\n  rankrd.next()\r\n  component.markdirty(m)\r\n  m.rankchanged = true\r\n}\r\n\r\ncomponent.define('graph-node', { from: [], to: [], _size: [20, 20] }, df => (\r\n  df('link', (m, t, e) => parent.link(m.node, t, e), false)\r\n), m => ({ type: 'rect', args: [-m._size[0] / 2, -m._size[1] / 2, ...m._size] }))\r\ncomponent.define('graph-edge', _, _, m => {\r\n  const a = m.from.position, b = m.to.position\r\n  const h = m.parent._horizontal\r\n  const l = (h ? a[0] - b[0] : a[1] - b[1]) / 2\r\n  const mid = (h ? a[0] + b[0] : a[1] + b[1]) / 2\r\n  const mp = h ? [mid, l] : [l, mid]\r\n  const args = [\r\n    ['M', ...a],\r\n    ['L', ...mp],\r\n    ['L', ...b],\r\n  ]\r\n  return { type: 'path', args }\r\n})\r\n\r\nconst g = component.create('graph')\r\ncomponent.root = g\r\n\r\n{\r\n  const a = g.add()\r\n  const b = g.add()\r\n  const c = g.add()\r\n  g.link(a, b)\r\n  g.link(a, c)\r\n  g.link(b, c)\r\n  g.link(c, a)\r\n\r\n  log(...g.node.map((n, i) => [i, n.id]))\r\n  log(...g.edge.map(({ from, to }) => [from.id, to.id]))\r\n}\r\n\r\n$.frame = () => {\r\n  rankgraph(g)\r\n  component.frame()\r\n}"}