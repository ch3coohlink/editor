{"id":"a58dc0dd478a7a552cb01ff5b744cd49ba0df1ec75d4958557dd3400c74d1716","to":[],"value":"const now = () => performance.now() / 1000\r\nconst { log, clear } = originconsole\r\nclear()\r\n\r\nconst local = n => globalThis.location.origin + '/' + n\r\nimportScripts(local('external/opentype.js'))\r\n\r\nconst cvs = await requestcanvas()\r\nconst ctx = cvs.getContext('2d', { willReadFrequently: true })\r\nlet devicePixelRatio = await requestdpi()\r\non('canvasresize', ({ w, h, dpi }) => w !== 0 && h !== 0\r\n  ? (cvs.width = w, cvs.height = h, devicePixelRatio = dpi) : 0)\r\n\r\nconst loop = () => {\r\n  $.frame?.()\r\n  requestAnimationFrame(loop)\r\n}; requestAnimationFrame(loop)\r\n\r\nconst fonts = {}\r\nconst loadfont = async (n, p) => {\r\n  let font = await fetch(local(p))\r\n  if (font.status !== 200) { throw Error(`Fail to load font file: ${n} at path: ${p}`) }\r\n  font = opentype.parse(await font.arrayBuffer())\r\n  font.defaultglyph = font.glyphs.glyphs[0], fonts[n] = font\r\n  log(font.tables.os2)\r\n  font.scalefactordiv1 = font.tables.os2.sTypoAscender / 1000\r\n  font.scalefactor = 1 / font.scalefactordiv1\r\n}\r\n\r\nawait Promise.all([\r\n  loadfont('consolas', 'assets/font/consolas.ttf'),\r\n  loadfont('思源黑体', 'assets/font/SourceHanSansHWSC-Regular.otf'),\r\n])\r\nlog(now())\r\n\r\nconst _segmenter = new Intl.Segmenter(\"en\", { granularity: 'grapheme' })\r\nconst splitunicode = t => Array.from(_segmenter.segment(t), ({ segment }) => segment)\r\nconst drawglyph = g => {\r\n  ctx.beginPath()\r\n  for (const c of g.path.commands) {\r\n    switch (c.type) {\r\n      case 'M': ctx.moveTo(c.x, c.y); break\r\n      case 'L': ctx.lineTo(c.x, c.y); break\r\n      case 'Q': ctx.quadraticCurveTo(c.x1, c.y1, c.x, c.y); break\r\n      case 'C': ctx.bezierCurveTo(c.x1, c.y1, c.x2, c.y2, c.x, c.y); break\r\n      case 'Z': break\r\n      default: log(c); throw Error(`unknown path command type: ${c.type}`)\r\n    }\r\n  }\r\n  ctx.fill()\r\n}\r\nconst defaultglyph = fonts['consolas'].defaultglyph\r\n\r\nconst drawtext = (t, x, y, s = 0.01) => {\r\n  const a = splitunicode(t)\r\n  ctx.save()\r\n  ctx.transform(s, 0, 0, -s, x, y)\r\n  for (const t of a) {\r\n    const c = t.charCodeAt(0); let usefont, g\r\n    for (const f of usingfonts) {\r\n      const i = f.tables.cmap.glyphIndexMap[c]\r\n      g = f.glyphs.glyphs[i]; if (g) { usefont = f; break }\r\n    } if (!g) { g = defaultglyph, usefont = fonts['consolas'] }\r\n    ctx.scale(usefont.scalefactor, usefont.scalefactor)\r\n    drawglyph(g); ctx.translate(g.advanceWidth, 0)\r\n    ctx.scale(usefont.scalefactordiv1, usefont.scalefactordiv1)\r\n  }\r\n  ctx.restore()\r\n}\r\n\r\nconst usingfonts = ['consolas', '思源黑体'].map(n => fonts[n])\r\n\r\nlet i = 0\r\n// ctx.fillStyle = '#00000001'\r\nlet cw = cvs.width, ch = cvs.height\r\n$.frame = () => {\r\n  cw = cvs.width, ch = cvs.height\r\n  ctx.resetTransform()\r\n  ctx.clearRect(0, 0, cw, ch)\r\n  drawtext('test text_测试中文', 100, 100, 0.05)\r\n  ctx.font = '65px consolas, 思源黑体 HW'\r\n  ctx.fillText('test text_测试中文', 100, 200)\r\n}"}