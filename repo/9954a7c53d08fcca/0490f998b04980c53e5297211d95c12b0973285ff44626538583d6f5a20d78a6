{"id":"0490f998b04980c53e5297211d95c12b0973285ff44626538583d6f5a20d78a6","to":[],"value":"$.mousepos = [0, 0], $.mouseevent = false\r\non('pointerrawupdate', async e => {\r\n  const b = await cvs.getBoundingClientRect()\r\n  mousepos[0] = (e.pageX - b.left) * devicePixelRatio\r\n  mousepos[1] = (e.pageY - b.top) * devicePixelRatio\r\n  e.mousepos = mousepos\r\n  mouseevent = e\r\n})\r\n$.dragprocess = (move, cancel) => {\r\n  let mi = on('pointermove', e => move((e.mousepos = mousepos, e)))\r\n  let ui = on('pointerup', e => (off('pointermove', mi),\r\n    off('pointerup', ui), cancel?.((e.mousepos = mousepos, e))))\r\n}\r\n$.getbbox = v => {\r\n  // TODO: rotate and scale not considered\r\n  const left = v.transform.e\r\n  const top = v.transform.f\r\n  const [width, height] = v.size\r\n  const right = left + width\r\n  const bottom = top + height\r\n  return { left, top, right, bottom, width, height }\r\n}\r\n\r\nconst id2color = i =>\r\n  '#' + [...new Uint8Array((new Uint32Array([i])).buffer)\r\n  ].slice(0, 3).map(v => v.toString(16).padStart(2, '0')).join('')\r\n\r\nconst globalenv = $\r\n$.component = (($ = {}) => {\r\n  with ($) {\r\n    $.globalenv = globalenv\r\n    $.definition = {}\r\n    $.dirty = new Set\r\n    $.dirtyarray = []\r\n    $.markdirty = m => {\r\n      if (dirty.has(m)) { return }\r\n      dirty.add(m); dirtyarray.push(m)\r\n    }\r\n    const cdae = n => Error(`component definition \"${n}\" already exists.`)\r\n    const cdne = n => Error(`component definition \"${n}\" not exists.`)\r\n    const vfne = n => Error(`view function not exist when defining component \"${n}\".`)\r\n    $.define = (n, m, v, tf, d) => {\r\n      if (definition[n]) { throw adae(n) }\r\n      if (typeof v !== 'function') { throw vfne(n) }\r\n      if (typeof m === 'function') { m = m() }\r\n      if (m.recordhistory) { m.history = [] }\r\n      m.type = n, m._iscomp = true\r\n      let t = {}; if (typeof tf === 'function')\r\n        tf((n, f, history = true) => t[n] = new Function('$',\r\n          `with($) {\\nconst __f__ = ${f.toString()}\r\nreturn function (...a) {\\nconst m = this, r = __f__(m, ...a)\r\n// TODO: a should be serialized since it could contain something like component\r\nif(${history} && m.recordhistory) { m.history.push([${n}, a]) }\r\nif(!m._iswatch) { component.markdirty(m) }\r\nreturn r\\n}\\n}`)(globalenv)); definition[n] = { m, v, t, d }\r\n      return (...a) => create(n, ...a)\r\n    }\r\n    $.definewatch = (n, m, v, tf, d) => {\r\n      const _tf = df => df('watch', (w, m) => ((m.watchers ??= new Set).add(w), w))\r\n      if (!tf) { tf = _tf } else { tf = df => { tf(df); _tf(df) } }\r\n      m._iswatch = true; define(n, m, v, tf, d)\r\n      return (...a) => create(n, ...a)\r\n    }\r\n    $.create = (n, f) => {\r\n      if (!definition[n]) { throw cdne(n) }\r\n      const d = definition[n], m = deepclone(d.m)\r\n      Object.setPrototypeOf(m, d.t) // TODO: not sure whether this is slow or not\r\n      if (typeof f === 'function') { f(m) }\r\n      return m\r\n    }\r\n    $.clone = (m, mixin) => {\r\n\r\n    }\r\n    const watchtype = new Map\r\n    $.watch = (m, f) => {\r\n      let fs = f.toString(), n\r\n      if (n = watchtype.get(fs)) { return create(n).watch(m) }\r\n      watchtype.set(fs, n = 'watch-' + rd.uuid(16))\r\n      return definewatch(n, {}, f)().watch(m)\r\n    }\r\n    $.on = (m, en, f) => {\r\n      m.event ??= { id: 0 }\r\n      const id = m.event.id++\r\n      m.event[en] ??= new Map\r\n      let fs = f.toString(), n, o\r\n      if (n = watchtype.get(fs)) { o = create(n) } else {\r\n        watchtype.set(fs, n = 'event-' + rd.uuid(16))\r\n        o = define(n, {}, f)()\r\n      } m.event[en].set(id, o)\r\n      return id\r\n    }\r\n    $.emit = (m, en, ...a) =>\r\n      m.event[en].forEach(({ type }) => definition[type].v(m, ...a))\r\n    let updated = false\r\n    $.update = () => {\r\n      updated = dirtyarray.length > 0\r\n      let c; while (c = dirtyarray.shift()) {\r\n        if (!dirty.has(c)) { continue }\r\n        const d = definition[c.type]\r\n        if (!d) { throw cdne(c.type) }\r\n        c._view = d.v(c)\r\n        if (c.watchers) for (const w of c.watchers) {\r\n          const d = definition[w.type]\r\n          if (!d) { throw cdne(w.type) } d.v(w, c)\r\n        } dirty.delete(c)\r\n      } if (updated) {\r\n        oldobjarr = objarray; objarray = []\r\n        if (!component.root) { return }\r\n        ctx.resetTransform()\r\n        collectobj(component.root._view)\r\n      }\r\n    }\r\n    $.objarray = [], $.oldobjarr = []\r\n    $.mouseid = 0, $.mousecomp = _\r\n    cvs.on('pointerdown', () => {\r\n      if (!mousecomp) { return }\r\n      emit(mousecomp, 'pointerdown', mouseevent)\r\n    })\r\n    const collectobj = c => {\r\n      if (Array.isArray(c)) { c.forEach(collectobj) }\r\n      else switch (c.type) {\r\n        case 'rect': case 'text':\r\n          objarray.push([ctx.getTransform(), c]); break\r\n        case 'component': {\r\n          ctx.save(); ctx.translate(...c.position)\r\n          const v = c.comp._view ??= definition[c.comp.type].v(c.comp)\r\n          if (!v) { throw Error(`component \"${c.comp.type}\" has no view output.`) }\r\n          c.transform = ctx.getTransform(); c.size = c.comp._size\r\n          collectobj(v); ctx.restore()\r\n        } break\r\n        default: { log(c); throw Error(`wrong view type \"${c.type}\"`) }\r\n      }\r\n    }\r\n    $.render = () => {\r\n      let m, c, id = 1\r\n      const id2comp = {}\r\n      const cw = cvs.width, ch = cvs.height\r\n      ctx.reset(); ctx.clearRect(0, 0, cw, ch)\r\n      for (let i = 0, l = objarray.length; i < l; i++) {\r\n        [m, c] = objarray[i]\r\n        if (!c.pointerevent) { continue }\r\n        id2comp[id] = c.eventtarget\r\n        ctx.fillStyle = id2color(id); id += 50\r\n        ctx.setTransform(m); switch (c.type) {\r\n          case 'text': drawtext(...c.args); break\r\n          case 'rect': ctx.fillRect(...c.args); break\r\n          default: throw Error(`wrong view type \"${c.type}\"`)\r\n        }\r\n      }\r\n      const r = ch / 2, t = now()\r\n      const mousecolor = ctx.getImageData(...mousepos.map(Math.floor), 1, 1).data\r\n      mousecolor[3] = 0; id = new Uint32Array(mousecolor.buffer)[0]\r\n      const comp = id2comp[id]; if (mouseid !== id) {\r\n        if (comp) { emit(comp, 'pointerenter', mouseevent) }\r\n        if (mousecomp) { emit(mousecomp, 'pointerleave', mouseevent) }\r\n      } mouseid = id, mousecomp = comp\r\n      // if (deepequal(oldobjarr, objarray)) { return }\r\n      ctx.reset(); ctx.clearRect(0, 0, cw, ch)\r\n      for ([m, c] of objarray) {\r\n        ctx.fillStyle = c.color ?? 'black'\r\n        ctx.setTransform(m); switch (c.type) {\r\n          case 'text': drawtext(...c.args); break\r\n          case 'rect': ctx.fillRect(...c.args); break\r\n          default: throw Error(`wrong view type \"${c.type}\"`)\r\n        }\r\n      } oldobjarr = objarray\r\n    }\r\n    $.destroy = () => { }\r\n    $.animation = () => { }\r\n    $.serialize = () => { }\r\n    $.deserialize = () => { }\r\n    $.frame = () => {\r\n      const cw = cvs.width, ch = cvs.height\r\n      if (cvs.needresize) {\r\n        if (component.root) {\r\n          component.root._size = [cw, ch]\r\n          component.markdirty(component.root)\r\n        } cvs.needresize = false\r\n      } component.update()\r\n      component.render()\r\n    }\r\n  } return $\r\n})()"}