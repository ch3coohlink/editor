{"id":"9f25717a3685cbed25fdfdb471905475a2559e2187d07badbc89cbcbc2bee73f","to":[],"value":"Object.assign($, await require('../util/common.js'))\r\nconst compsys = await require('../util/component.js')\r\nconst grd = await require('../util/random.js')\r\nconsole.clear()\r\n\r\nlet framecount = 0\r\nconst loop = () => {\r\n  if ($.frame) { framecount++; frame() }\r\n  requestAnimationFrame(loop)\r\n}; requestAnimationFrame(loop)\r\n\r\n$.cvs = await createcanvas()\r\n$.ctx = cvs.getContext('2d', { willReadFrequently: true })\r\n$.component = compsys.createcomponentsystem({ cvs, ctx })\r\nObject.defineProperty(component.globalenv, 'framecount', { get: () => framecount })\r\n\r\ncomponent.define('graph', {\r\n  direction: 'horizontal', subgraph: [],\r\n  node: [], edge: [], vnode: [], vedge: [],\r\n}, df => (\r\n  df('add', (m, d, n = component.create('graph-node',\r\n    nm => (nm.parent = m, nm.data = d, nm.ranksum = 0, nm.rankcount = 0))) =>\r\n    (m.graphmoded = true, m.node.push(n), n)),\r\n  df('link', (m, a, b, d, e = component.create('graph-edge',\r\n    em => (em.parent = m, em.from = a, em.to = b, em.data = d))) =>\r\n    (m.graphmoded = true, a.to.push(e), b.from.push(e), m.edge.push(e), e))),\r\n  m => {\r\n    const h = m.direction === 'horizontal'; let r\r\n    m._horizontal = h\r\n    const base = 1200\r\n    let nonbase = 0\r\n    const distance = 100\r\n    if (m.rankchanged) {\r\n      const nvs = []\r\n      for (const g of m.subgraph) {\r\n        const gvs = g.map(comp => ({ type: 'component', comp }))\r\n        for (let i = 0, l = g.length; i < l; i++) {\r\n          const b = base * g[i].rank\r\n          const p = h ? [b, nonbase] : [nonbase, b]\r\n          g[i].position = gvs[i].position = p\r\n        } nvs.push(...gvs); nonbase += distance\r\n      } nonbase = (m.subgraph.length - 1) * distance\r\n\r\n      const evs = m.edge.map(comp => ({ type: 'component', comp }))\r\n      m.edge.forEach(component.markdirty)\r\n\r\n      m.rankchanged = m.graphmoded = false\r\n      r = { type: 'component', comp: { _view: [...evs, ...nvs] } }\r\n    } else { r = m._view ?? [] } r.position = h\r\n      ? [(m._size[0] - base) / 2, (m._size[1] - nonbase) / 2]\r\n      : [(m._size[0] - nonbase) / 2, (m._size[1] - base) / 2]\r\n    return r\r\n  })\r\nconst splitgraph = m => {\r\n  m.subgraph = []; let seen = new Set, sub = 0\r\n  for (let i = 0, l = m.node.length; i < l; i++) {\r\n    let n = m.node[i]; if (seen.has(n)) { continue }\r\n    const s = m.subgraph[sub++] = [], q = [n]\r\n    while (n = q.shift()) {\r\n      if (seen.has(n)) { continue } s.push(n), seen.add(n)\r\n      q.push(...n.to.map(e => e.to), ...n.from.map(e => e.from))\r\n    }\r\n  }\r\n}\r\nconst rankrd = grd.genrd()\r\nconst rankgraph = (m, l = 10) => {\r\n  const { rdi } = rankrd, { min, max } = Math\r\n  for (const g of m.subgraph) {\r\n    if (g.converged) { continue }\r\n    if (g.length <= 1) { g[0].rank = 0; continue }\r\n    const st = now()\r\n\r\n    for (let i = 0; i < l; i++) {\r\n      const q = [[g[rdi(g.length)], 0]], seen = new Set\r\n      while (q.length > 0) {\r\n        const [n, d] = q.splice(rdi(q.length), 1)[0]\r\n        if (seen.has(n)) { continue } seen.add(n)\r\n        n.ranksum += d, q.push(\r\n          ...n.to.map(e => [e.to, d - 1]),\r\n          ...n.from.map(e => [e.from, d + 1]))\r\n      }\r\n    }\r\n\r\n    let maxv = -Infinity, minv = Infinity\r\n    let d = 0; for (const n of g) {\r\n      n.rankcount ??= 0, n.rankcount += l\r\n      n.oldrank = n.rawrank ??= 0\r\n      n.rawrank = n.ranksum / n.rankcount\r\n      maxv = max(maxv, n.rawrank)\r\n      minv = min(minv, n.rawrank)\r\n      d += Math.abs(n.rawrank - n.oldrank)\r\n    } if (d < 0.0001 * g.length) { g.converged = true }\r\n    const minmaxdiv = 1 / (maxv - minv)\r\n    for (const n of g) { n.rank = 1 - (n.rawrank - minv) * minmaxdiv }\r\n\r\n    const gs = g.sort((a, b) => b.rank - a.rank)\r\n\r\n    // while (gs) {\r\n\r\n    // }\r\n\r\n\r\n  } rankrd.next(), m.rankchanged = true\r\n\r\n  const et = now()\r\n}\r\nconst layoutgraph = m => {\r\n  if (m.graphmoded) { splitgraph(m) }\r\n  rankgraph(m)\r\n  component.markdirty(m)\r\n}\r\n\r\ncomponent.define('graph-node', { from: [], to: [], _size: [2, 2] }, df => (\r\n  df('link', (m, t, e) => parent.link(m, t, e), false)\r\n), m => ({ type: 'rect', args: [-m._size[0] / 2, -m._size[1] / 2, ...m._size] }))\r\ncomponent.define('graph-edge', _, _, m => {\r\n  const a = m.from.position, b = m.to.position\r\n  const h = m.parent._horizontal\r\n  const l = (h ? a[0] - b[0] : a[1] - b[1]) / 2\r\n  const mid = [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2]\r\n  const mp = h ? [mid[0], mid[1] + l] : [mid[0] + l, mid[1]]\r\n  const args = [\r\n    ['M', ...a],\r\n    ['L', ...mp],\r\n    ['L', ...b],\r\n  ]\r\n  return { type: 'path', args }\r\n})\r\n\r\nconst g = component.create('graph')\r\ncomponent.root = g\r\n\r\n// const rgrd = grd.genrd(23545236)\r\nconst rgrd = grd.genrd(); log(rgrd.seed)\r\nconst randomgraph = (g, l = rgrd.rdi(25, 200), ns = []) => {\r\n  for (let i = 0; i < l; i++) { ns.push(g.add()) }\r\n  for (let i = 0; i < l; i++) {\r\n    const r = rgrd.rd() > 0.9 ? 2 : 1\r\n    const a = ns[i], s = [...ns]\r\n    for (let j = 0; j < r && s.length > 0; j++) {\r\n      g.link(a, s.splice(rgrd.rdi(s.length), 1)[0])\r\n    }\r\n  } rgrd.next()\r\n}\r\nrandomgraph(g)\r\nrandomgraph(g)\r\n\r\n$.frame = () => {\r\n  layoutgraph(g)\r\n  component.frame()\r\n}"}