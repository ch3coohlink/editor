{"id":"79a09fb95c21fffe30123795e3b26441707ac056c8883f734bd61564acab71d1","to":[],"value":"Object.assign($, await require('lib/common.js'))\r\nconst grd = await require('lib/random.js')\r\nconsole.clear()\r\n\r\n$.framecount = 0\r\nconst loop = () => {\r\n  if ($.frame) { framecount++; frame() }\r\n  requestAnimationFrame(loop)\r\n}; requestAnimationFrame(loop)\r\n\r\nconst dom = (n = 'div') => document.createElement(n)\r\nconst svg = n => document.createElementNS('http://www.w3.org/2000/svg', n)\r\nconst svgtags = new Set(`a altGlyph altGlyphDef altGlyphItem\r\n  animate animateColor animateMotion animateTransform animation\r\n  audio canvas circle clipPath color-profile cursor defs desc discard\r\n  ellipse feBlend feColorMatrix feComponentTransfer feComposite\r\n  feConvolveMatrix feDiffuseLighting feDisplacementMap feDistantLight\r\n  feDropShadow feFlood feFuncA feFuncB feFuncG feFuncR feGaussianBlur\r\n  feImage feMerge feMergeNode feMorphology feOffset fePointLight\r\n  feSpecularLighting feSpotLight feTile feTurbulence filter font\r\n  font-face font-face-format font-face-name font-face-src font-face-uri\r\n  foreignObject g glyph glyphRef handler hkern iframe image line\r\n  linearGradient listener marker mask metadata missing-glyph mpath path\r\n  pattern polygon polyline prefetch radialGradient rect script set\r\n  solidColor stop style svg switch symbol tbreak text textArea textPath\r\n  title tref tspan unknown use video view vker`.split(/\\s+/))\r\n\r\n$.component = { globalenv: $ }; with (component) {\r\n  const $ = component\r\n  $.definition = {}\r\n  const cdae = n => Error(`component definition \"${n}\" already exists.`)\r\n  const cdne = n => Error(`component definition \"${n}\" not exists.`)\r\n  const initmodel = model => {\r\n    if (model.recordhistory) { model.history = [] }\r\n    model.type = name, model._iscomp = true\r\n  }\r\n  $.define = (name, model = {}, transition, view, extra = {}) => {\r\n    if (definition[name]) { throw adae(name) }\r\n    if (typeof model !== 'function') { initmodel(model) }\r\n    const t = {}; if (typeof transition === 'function') {\r\n      transition((n, f, history = true) => t[n] = function (...a) {\r\n        const m = this, r = f(m, ...a)\r\n        // TODO: a should be serialized since it could contain something like component\r\n        if (history && m.recordhistory) { m.history.push([n, a]) } return r\r\n      })\r\n    } definition[name] = { model, view, transition: t }\r\n    return (...a) => create(n, ...a)\r\n  }\r\n  $.create = (name, mod, ...a) => {\r\n    if (!definition[name]) { throw cdne(name) }\r\n    const d = definition[name], mf = typeof d.model === 'function'\r\n    const m = mf ? d.model(...a) : deepclone(d.model)\r\n    if (mf) { initmodel(m) } m.id = grd.uuid()\r\n    Object.setPrototypeOf(m, d.transition)\r\n    if (typeof mod === 'function') { mod(m) }\r\n    m._view = d.view(m); render(m)\r\n    return m\r\n  }\r\n  $.render = c => {\r\n    const iscomp = c._iscomp\r\n    if (iscomp && !c._view) {\r\n      const d = definition[c.type]\r\n      if (!d) { throw cdne(c.type) }\r\n      c._view = d.view(c)\r\n    }\r\n    const v = iscomp ? c._view : c\r\n    if (!c._dom) {\r\n      c._dom = v._namespace !== 'dom'\r\n        && svgtags.has(v.type) ? svg(v.type) : dom(v.type)\r\n    }\r\n\r\n    const d = c._dom\r\n    const vcs = v.children ?? []\r\n    for (const cd of vcs) {\r\n      if (!cd._iscomp || !cd._dom) { render(cd, true) }\r\n      d.append(cd._dom)\r\n    } delete v.children\r\n\r\n    if (v.jsobj) for (const k of Object.keys(v.jsobj)) {\r\n      d[k] = v.jsobj[k]\r\n    } delete v.jsobj; delete v.type\r\n\r\n    for (const k of Object.keys(v)) {\r\n      if (k[0] === '_') { continue }\r\n      d.setAttribute(k, v[k])\r\n    }\r\n  }\r\n  let previoussize = [0, 0]\r\n  $.frame = () => {\r\n    const groot = globalenv.root\r\n    const rbcr = groot.getBoundingClientRect()\r\n    const size = [rbcr.width, rbcr.height]\r\n    if (!deepequal(size, previoussize)) { root._size = size; }\r\n    previoussize = size\r\n    if (groot.childNodes[0] !== root._dom) {\r\n      groot.insertBefore(root._dom, groot.childNodes[0])\r\n    }\r\n  }\r\n}\r\n\r\nroot.style.overflow = 'hidden'\r\n\r\n$.glrd = grd.genrd(6834652831)\r\n{\r\n  $.splitgraph = m => {\r\n    m.subgraph = []; let seen = new Set, sub = 0\r\n    for (let n of m.node) {\r\n      if (seen.has(n)) { continue }\r\n      const s = m.subgraph[sub++] = [], q = [n]\r\n      while (n = q.shift()) {\r\n        if (seen.has(n)) { continue } s.push(n), seen.add(n)\r\n        q.push(...[...n.to.keys()], ...[...n.from.keys()])\r\n      }\r\n    }\r\n    for (const n of m.node) {\r\n      n.rank = n.ranksum = n.rankcount = 0\r\n    }\r\n    m.graphmoded = false\r\n    m.needlayout = true\r\n  }\r\n  const rankrd = grd.genrd(2462462542)\r\n  $.rankgraph = (m, l = 100) => {\r\n    const { rdi } = rankrd, { round, abs } = Math\r\n    for (const g of m.subgraph) {\r\n      if (g.converged) { continue }\r\n      if (g.length <= 1) { g[0].rank = 0; g.converged = true; continue }\r\n      for (let i = 0; i < l; i++) {\r\n        const q = [[g[rdi(g.length)], 0]], seen = new Set\r\n        while (q.length > 0) {\r\n          const [n, d] = q.splice(rdi(q.length), 1)[0]\r\n          if (seen.has(n)) { continue } seen.add(n)\r\n          n.ranksum += d, q.push(\r\n            ...[...n.to.keys()].map(v => [v, d - 1]),\r\n            ...[...n.from.keys()].map(v => [v, d + 1]))\r\n        }\r\n      }\r\n      let d = 0; for (const n of g) {\r\n        n.rankcount += l\r\n        n.oldrank = n.rank\r\n        n.rank = n.ranksum / n.rankcount\r\n        d += abs(n.rank - n.oldrank)\r\n      }\r\n      if (m.progressiveranking) {\r\n        if (d < 0.001 * g.length) { g.converged = true }\r\n      } else { g.converged = true }\r\n    } rankrd.next()\r\n\r\n  }\r\n  $.forcedirect = (m, step = 4) => {\r\n    const { sqrt, max, min, abs } = Math\r\n    const gravity = { rposition: [0, 0], acceleration: [0, 0] }\r\n    const margin = m.margin ?? 50, usemargin = m.margin > 0\r\n    const electric = (a, b, p, minl = 1) => {\r\n      const pdx = b.rposition[0] - a.rposition[0]\r\n      const pdy = b.rposition[1] - a.rposition[1]\r\n      const lsq = max(pdx * pdx + pdy * pdy, minl)\r\n      const l = sqrt(lsq), f = p / (lsq * l)\r\n      let fx = f * pdx, fy = f * pdy; if (usemargin &&\r\n        a.bbox[0] < b.bbox[2] + margin && b.bbox[0] < a.bbox[2] + margin &&\r\n        a.bbox[1] < b.bbox[3] + margin && b.bbox[1] < a.bbox[3] + margin) {\r\n        const r = 100\r\n        const d0 = b.bbox[2] + margin - a.bbox[0]\r\n        const d1 = b.bbox[0] - margin - a.bbox[2]\r\n        fx += r * (abs(d0) < abs(d1) ? d0 : d1)\r\n        const d2 = b.bbox[3] + margin - a.bbox[1]\r\n        const d3 = b.bbox[1] - margin - a.bbox[3]\r\n        fy += r * (abs(d2) < abs(d3) ? d2 : d3)\r\n      }\r\n      a.acceleration[0] += fx, a.acceleration[1] += fy\r\n      b.acceleration[0] -= fx, b.acceleration[1] -= fy\r\n    }, distance = (a, b, p) => {\r\n      const pdx = b.rposition[0] - a.rposition[0]\r\n      const pdy = b.rposition[1] - a.rposition[1]\r\n      const fx = p * pdx, fy = p * pdy\r\n      a.acceleration[0] += fx, a.acceleration[1] += fy\r\n      b.acceleration[0] -= fx, b.acceleration[1] -= fy\r\n    }, friction = 0.01, dt = 0.05\r\n    const tl = m.target_length, ts = tl * 2\r\n    const pe = -ts * tl ** 2, pd = ts * 20 / tl, pg = 0.05 * pd\r\n    const h = m.direction === 'horizontal' ? 0 : 1\r\n    const g = m.subgraph.flat(1)\r\n    for (let i = 0; i < step; i++) {\r\n      let total_speed = 0\r\n      for (let i = 0, l = g.length; i < l; i++) {\r\n        const n = g[i], nto = 1 / n.to.size\r\n        for (let j = i + 1; j < l; j++) { electric(n, g[j], pe) }\r\n        for (const [to] of n.to) { distance(n, to, pd * nto) }\r\n        if (n.hardlock) { n.velocity[0] = n.velocity[1] = 0; continue }\r\n        if (m.hierarchy) { n.acceleration[h] -= n.rank * tl * 10 }\r\n        distance(n, gravity, pg)\r\n        const vx = n.velocity[0] + n.acceleration[0] * dt\r\n        const vy = n.velocity[1] + n.acceleration[1] * dt\r\n        let v = sqrt(vx * vx + vy * vy), vrx = vx / v, vry = vy / v\r\n        total_speed += v = max(min(v, ts) - ts * friction, 0)\r\n        if (n.lock) { n.velocity[0] = n.velocity[1] = 0; continue }\r\n        n.rposition[0] += (n.velocity[0] = vrx * v) * dt\r\n        n.rposition[1] += (n.velocity[1] = vry * v) * dt\r\n        n.acceleration[0] = n.acceleration[1] = 0\r\n      } m.total_speed = total_speed\r\n    }\r\n  }\r\n}\r\n\r\n{\r\n  const { max, min } = Math; $.clamp = (v, s, l) => max(min(v, l), s)\r\n  $.itp = (a, b, t) => (t = clamp(t, 0, 1), a + t * (b - a))\r\n  $.itp3 = (a, b, t) => (t = clamp(t, 0, 1),\r\n    [a[0] + t * (b[0] - a[0]), a[1] + t * (b[1] - a[1]), a[2] + t * (b[2] - a[2])])\r\n\r\n  $.dragprocess = (move, cancel) => {\r\n    const c = e => (off('pointermove', mi),\r\n      off('pointerup', ui), off('pointercancel', ci), cancel?.(e))\r\n    const mi = on('pointermove', e => move(e))\r\n    const ui = on('pointerup', c)\r\n    const ci = on('pointercancel', c)\r\n  }\r\n  $.expdecay = (a, b, d, dt) => b + (a - b) * Math.exp(-d * dt)\r\n  $.callhotkey = (m, k, e) => {\r\n    while (m) {\r\n      if (m._hotkey[k]) {\r\n        return m._hotkey[k]?.(e)\r\n      } m = m.parent\r\n    }\r\n  }\r\n  $.formatkeyevent = (e, up) => e.key.toLowerCase() + (up ? 'up' : [\r\n    e.altKey, e.ctrlKey, e.shiftKey].map(v => v ? 't' : 'f').join(''))\r\n}\r\n\r\nconst cameradefault = [2, 0, 0]\r\ncomponent.define('graph', (camera = [...cameradefault]) => ({\r\n  direction: 'vertical', subgraph: [],\r\n  target_length: 50, node: new Set,\r\n  camera, realcameravalue: [...camera],\r\n  color: [90, 90, 90], focuscolor: '#0087ff',\r\n  zoomfactor: 1.2, hierarchy: true,\r\n}), df => {\r\n  df('add', (m, d, p) => {\r\n    const n = component.create('graph-node', n => (\r\n      n.parent = m, n.data = d, n.ranksum = 0, n.rankcount = 0), p)\r\n    m.graphmoded = true, m.node.add(n)\r\n    m._vnode._dom.append(n._dom)\r\n    m._resizewatcher.observe(n._foreign._dom)\r\n    return n\r\n  })\r\n  df('del', (m, n) => {\r\n    m.graphmoded = true, m.node.delete(n), n._dom.remove()\r\n    m._resizewatcher.unobserve(n._foreign._dom)\r\n    for (const [to] of n.to) { m.unlink(n, to) }\r\n    for (const [fr] of n.from) { m.unlink(fr, n) }\r\n  })\r\n  df('link', (m, a, b, d) => {\r\n    if (a.to.has(b)) { return a.to.get(b) }\r\n    const e = component.create('graph-edge', e => (\r\n      e.parent = m, e.from = a, e.to = b, e.data = d))\r\n    m.graphmoded = true, a.to.set(b, e), b.from.set(a, e)\r\n    m._vedge._dom.append(e._dom)\r\n    return e\r\n  })\r\n  df('unlink', (m, a, b, e = a.to.get(b)) => (m.graphmoded = true,\r\n    e._dom.remove(), a.to.delete(b), b.from.delete(a)))\r\n  df('offsetcoord', (m, e, r = m._dom.getBoundingClientRect()) =>\r\n    [e.pageX - r.left, e.pageY - r.top])\r\n  df('graphcoord', (m, e, cx = m.camera[1], cy = m.camera[2]) => {\r\n    const [x, y] = m.offsetcoord(e)\r\n    const { clientWidth: w, clientHeight: h } = m._dom\r\n    return [(x - cx - w / 2) / m.camera[0], (y - cy - h / 2) / m.camera[0]]\r\n  })\r\n  df('zoom', (m, e, r) => {\r\n    let [x, y] = Array.isArray(e) ? e : m.offsetcoord(e)\r\n    const { clientWidth: w, clientHeight: h } = m._dom\r\n    if (!Array.isArray(e)) { x -= w / 2; y -= h / 2 }\r\n    m.camera[0] *= r // equation: y - nsy === (y - sy) * r\r\n    m.camera[1] = x - (x - m.camera[1]) * r\r\n    m.camera[2] = y - (y - m.camera[2]) * r\r\n  })\r\n  df('updatecamera', (m, dt) => {\r\n    if (m.focusnode) {\r\n      [m.camera[1], m.camera[2]] = m.focusnode.center.map(v => -v * m.camera[0])\r\n    } const camera = [...m.camera]\r\n    if (m._movetarget) {\r\n      let mx = -Infinity, my = -Infinity, { abs } = Math\r\n      const a = m.focusnode ? m.focusnode.center : m.cameraposition()\r\n      for (const n of Object.values(m._movetarget).concat(m._previewmove)) {\r\n        if (!n) { continue } let v\r\n        v = abs(n.position[0] - a[0]); if (v > mx) { mx = v }\r\n        v = abs(n.position[1] - a[1]); if (v > my) { my = v }\r\n      } let { clientWidth: w, clientHeight: h } = m._dom\r\n      const ox = mx * m.camera[0] > (w *= .4)\r\n      const oy = my * m.camera[0] > (h *= .4)\r\n      camera[0] = ox || oy ? Math.min(w / mx, h / my) : camera[0]\r\n      camera[1] = -a[0] * camera[0]\r\n      camera[2] = -a[1] * camera[0]\r\n    }\r\n    m.realcameravalue = camera.map((v, i) =>\r\n      expdecay(m.realcameravalue[i], v, 10, dt))\r\n\r\n    const [s, x, y] = m.realcameravalue\r\n    m._canvas._dom.style.transform = `translate(50%, 50%) ` +\r\n      `translate(${x + 'px'}, ${y + 'px'}) scale(${s})`\r\n  })\r\n  df('frame', (m, dt) => {\r\n    m.updatecamera(dt)\r\n    if (m.graphmoded) { splitgraph(m) }\r\n    if (m.needlayout) {\r\n      for (const n of m.node) { n.preupdate() }\r\n      rankgraph(m, 100), forcedirect(m, 4)\r\n      if (m.total_speed <= 0) { m.needlayout = false }\r\n      for (const n of m.node) {\r\n        n.position = n.rposition.map(\r\n          (v, i) => expdecay(n.position[i], v, 16, dt))\r\n        n.update()\r\n      }\r\n    }\r\n    if (m.focusnode) {\r\n      for (const [, e] of m.focusnode.to) {\r\n        e._dom.setAttribute('stroke', m.focuscolor)\r\n        e._dom.setAttribute('stroke-width', '2px')\r\n      } for (const [, e] of m.focusnode.from) {\r\n        e._dom.setAttribute('stroke', '#ff9700')\r\n        e._dom.setAttribute('stroke-width', '2px')\r\n      }\r\n    }\r\n  })\r\n  df('getmovetarget', m => {\r\n    const a = m._previewmove ? m._previewmove.position :\r\n      m.focusnode ? m.focusnode.position : m.cameraposition()\r\n    let i = 0, mvup = i, mvdw = i, mvlf = i, mvrt = i\r\n    const maxnode = {}; for (const n of m.node) {\r\n      const dx = n.position[0] - a[0], dy = n.position[1] - a[1]\r\n      let l = Math.sqrt(dx * dx + dy * dy), ld = 1 / l, lp = 1 - l / 500\r\n      const dup = dy * -ld, ddw = dy * ld, dlf = dx * -ld, drt = dx * ld\r\n      if (dup > 0) { v = lp + dup; if (mvup < v) { mvup = v; maxnode.up = n } }\r\n      if (ddw > 0) { v = lp + ddw; if (mvdw < v) { mvdw = v; maxnode.dw = n } }\r\n      if (dlf > 0) { v = lp + dlf; if (mvlf < v) { mvlf = v; maxnode.lf = n } }\r\n      if (drt > 0) { v = lp + drt; if (mvrt < v) { mvrt = v; maxnode.rt = n } }\r\n    } m._movetarget = maxnode\r\n  })\r\n  df('updatemove', (m, moving, d) => {\r\n    let n; if (m._movetarget) {\r\n      for (const k in m._movetarget) if (n = m._movetarget[k]) {\r\n        n.settitle(''); n.resetcolor()\r\n      } if (m._previewmove) { m._previewmove.resetcolor() }\r\n      if (d) { m._previewmove = m._movetarget[d] }\r\n    }\r\n    if (m.focusnode) { m.focusnode.setcolor(m.focuscolor) }\r\n    if (!m._moving) {\r\n      if (m.focusnode) { m.focusnode.setcolor(m.focuscolor, '44') }\r\n      if (m._previewmove) { m._previewmove.focus() }\r\n      m._edgecreated = m._movetarget = m._previewmove = _; return\r\n    } m.getmovetarget()\r\n    for (const k in m._movetarget) if (n = m._movetarget[k]) {\r\n      n._title._dom.setAttribute('stroke-width', '1px')\r\n      n._title._dom.setAttribute('stroke', '#333')\r\n      n._title._dom.setAttribute('fill', '#c8ff17')\r\n      n._title._dom.setAttribute('font-size', '50px')\r\n      switch (k) {\r\n        case 'up': n.addtitle('↑'); break\r\n        case 'dw': n.addtitle('↓'); break\r\n        case 'lf': n.addtitle('←'); break\r\n        case 'rt': n.addtitle('→'); break\r\n      }\r\n    } if (m._previewmove) { m._previewmove.setcolor('#ff9700') }\r\n  })\r\n  df('startmove', m => m._moving || m._forceleavemove\r\n    ? 0 : m.updatemove(m._moving = true))\r\n  df('move', (m, d) => m.updatemove(m._moving = true, d))\r\n  df('endmove', m => {\r\n    m.updatemove(m._moving = false)\r\n    m._forceleavemove = false\r\n  })\r\n  df('quitmove', m => {\r\n    const n = m.focusnode\r\n    m.updatemove(m._moving = false)\r\n    m._forceleavemove = true; (n ? n : m).focus()\r\n  })\r\n  df('focus', m => m._dom.focus())\r\n  df('blur', m => m._dom.blur())\r\n  df('createorconnect', (m, f = false) => {\r\n    if (m._previewmove) {\r\n      if (!m.focusnode) { return } const n = m._previewmove\r\n      if (f) { if (m.focusnode.to.has(n)) { m.unlink(m.focusnode, n) } } else {\r\n        const a = m.focusnode, b = n, ab = a.to.has(b), ba = b.to.has(a)\r\n        if (ab && ba) { m.unlink(b, a) } else if (ab) {\r\n          m.link(b, a); if (m._reverted) { delete m._reverted }\r\n          else { m.unlink(a, b), m._reverted = true }\r\n        } else if (ba) {\r\n          m.link(a, b); if (m._reverted) { delete m._reverted }\r\n          else { m.unlink(b, a), m._reverted = true }\r\n        } else { m.link(m.focusnode, n) }\r\n      }\r\n    } else {\r\n      m.endmove(); const a = m.focusnode, b = m.add(component.create(\r\n        'text-editor'), a ? a.position : m.cameraposition())\r\n      if (a) { m.link(a, b); f ? b.focus() : 0 } else { b.focus() }\r\n    }\r\n  })\r\n  df('loadjson', m => {\r\n    // TODO\r\n  })\r\n  df('tojson', m => {\r\n    // TODO\r\n  })\r\n  df('cameraposition', m => [-m.camera[1] / m.camera[0], -m.camera[2] / m.camera[0]])\r\n  df('callhotkey', callhotkey)\r\n}, m => (m._resizewatcher = new ResizeObserver(() => m.needlayout = true),\r\n  m._horizontal = m.direction === 'horizontal',\r\n  m.realcameravalue = [...m.camera], m._hotkey = {\r\n    ntff: () => m.createorconnect(),\r\n    mtff: () => m.createorconnect(true),\r\n    alttff: () => m.startmove(), altup: () => m.endmove(),\r\n    utff: () => m.quitmove(),\r\n    ytff: () => m.zoom([0, 0], m.zoomfactor),\r\n    htff: () => m.zoom([0, 0], 1 / m.zoomfactor),\r\n    itff: () => m.move('up'), ktff: () => m.move('dw'),\r\n    jtff: () => m.move('lf'), ltff: () => m.move('rt'),\r\n    otff: () => m.camera = [...cameradefault],\r\n    ptff: () => (m.needlayout = true,\r\n      m.direction = m._horizontal ? 'vertical' : 'horizontal',\r\n      m._horizontal = m.direction === 'horizontal'),\r\n    '[tff': () => (m.needlayout = true, m.margin = m.margin > 0 ? 0 : 50),\r\n  }, {\r\n  type: 'svg', jsobj: {\r\n    onwheel: (e, r = m.zoomfactor) => (\r\n      m.zoom(e, e.deltaY < 0 ? r : 1 / r), e.preventDefault()),\r\n    onpointerdown: e => {\r\n      if (e.target !== m._dom) { return }\r\n      const cx = m.camera[1], cy = m.camera[2]\r\n      const o = m.graphcoord(e, cx, cy)\r\n      dragprocess(e => {\r\n        const [x, y] = m.graphcoord(e, cx, cy)\r\n        m.camera[1] = cx + (x - o[0]) * m.camera[0]\r\n        m.camera[2] = cy + (y - o[1]) * m.camera[0]\r\n      })\r\n    },\r\n    onfocus: () => m._dom.style.boxShadow = m.focuscolor + '88 0px 0px 20px inset',\r\n    onblur: () => (m._dom.style.boxShadow = '', m.endmove()),\r\n    onkeydown: e => {\r\n      if (e.target !== m._dom) { return }\r\n      e.preventDefault(), e.stopImmediatePropagation()\r\n      m.callhotkey(formatkeyevent(e), e)\r\n    },\r\n    onkeyup: e => {\r\n      if (e.target !== m._dom) { return }\r\n      e.preventDefault(), e.stopImmediatePropagation()\r\n      m.callhotkey(formatkeyevent(e, true), e)\r\n    },\r\n  }, children: [m._canvas = {\r\n    type: 'g', children: [m._vedge = {\r\n      type: 'g', children: [...m.node].map(n => [...n.to.values()]).flat(1),\r\n      filter: 'drop-shadow(0 2px 2px #00000055)'\r\n    }, m._vnode = { type: 'g', children: [...m.node] }],\r\n    stroke: `rgb(${m.color.join(', ')})`, 'stroke-width': '1px',\r\n    fill: 'none', 'stroke-linecap': 'round',\r\n  }], 'tab-index': 1, style: `outline: none;\r\n    width:100%; height:100%;user-select:none; cursor: grab;\r\n    transition: box-shadow 0.3s; background: #fafafa;` }))\r\n\r\n// graph-node ===========================================================\r\ncomponent.define('graph-node', (position = [0, 0]) => ({\r\n  from: new Map, to: new Map, position,\r\n  rposition: position.map(v => v + glrd.rd(-1, 1)),\r\n  acceleration: [0, 0], velocity: [0, 0],\r\n  bbox: [0, 0, 0, 0],\r\n}), df => {\r\n  df('link', (m, t, e) => m.parent.link(m, t, e))\r\n  df('unlink', (m, t) => m.parent.unlink(m, t))\r\n  df('del', m => (m.parent.focus(), m.parent.del(m)))\r\n  df('setcolor', (m, c, o = '88') => {\r\n    m._foreign._dom.style.boxShadow = c + o + ' 0px 4px 10px'\r\n    m._dragsign._dom.setAttribute('stroke', c)\r\n    m._title._dom.setAttribute('stroke', c)\r\n  })\r\n  df('resetcolor', m => {\r\n    m._foreign._dom.setAttribute('style', m._foreign.style)\r\n    m._dragsign._dom.setAttribute('stroke', m._dragsigncolor)\r\n    m._title._dom.setAttribute('stroke', m._dragsigncolor)\r\n    m._title._dom.setAttribute('fill', m._dragsigncolor)\r\n  })\r\n  df('preupdate', m => {\r\n    const d = m._foreign._dom\r\n    m.size = [d.clientWidth, d.clientHeight]\r\n  })\r\n  df('update', m => {\r\n    const x = m.position[0] - m.size[0] / 2\r\n    const y = m.position[1] - 5\r\n    m.bbox = [x, y, x + m.size[0], y + m.size[1]]\r\n    m.center = [m.position[0], y + m.size[1] / 2]\r\n    m._dom.style.transform = `translate(${[x + 'px', y + 'px'].join(', ')})`\r\n    for (const [, e] of m.to) { e.reset() }\r\n  })\r\n  df('focus', m => (\r\n    m.size ? 0 : (m.preupdate(), m.update()),\r\n    m.setcolor(m.parent.focuscolor, '44'),\r\n    m.parent.focusnode = m, m.data.focus?.()))\r\n  df('blur', m => (m.resetcolor(),\r\n    m.to.forEach(e => e.reset()), m.from.forEach(e => e.reset()),\r\n    m.parent.focusnode = _, m.data.blur?.(), m.parent.endmove()))\r\n  df('callhotkey', callhotkey)\r\n  df('addtitle', (m, t) => {\r\n    m.settitle(m._title._dom.textContent + t)\r\n  })\r\n  df('settitle', (m, t) => {\r\n    m._title._dom.textContent = t\r\n    const w = m._title._dom.getBBox().width\r\n    m._title._dom.style.transform =\r\n      `translate(calc(50% - ${w / 2}px), calc(50% - 10px))`\r\n  })\r\n  df('quitconnectmode', m => m.parent.setconnectmode(m))\r\n}, m => (m.data.parent = m, m._hotkey = {\r\n  deletetft: () => m.del(),\r\n  qtff: () => m.parent.focus(),\r\n}, m._dragsigncolor = '#666', {\r\n  type: 'foreignObject', style: `overflow:visible;width:1px;height:1px;`,\r\n  children: [m._foreign = {\r\n    type: 'div', children: [{\r\n      type: 'svg', jsobj: {\r\n        onpointerdown: () => dragprocess(e => {\r\n          m.rposition = m.parent.graphcoord(e)\r\n          m.position = [...m.rposition]\r\n          m.parent.needlayout = m.lock = true\r\n        }, () => delete m.lock),\r\n      }, children: [m._dragsign = {\r\n        type: 'path', d: 'M -10 0 L 10 0',\r\n        'stroke-width': '2', stroke: m._dragsigncolor,\r\n        'stroke-linecap': 'round',\r\n        style: `transform:translate(50%, 50%);`\r\n      }, m._title = { type: 'text', stroke: 'none', fill: m._dragsigncolor }],\r\n      style: `width: 100%; height: 10px;\r\n      display: block; cursor: pointer;overflow: visible;` }, {\r\n      type: 'div', children: [m.data], style: `\r\n      padding: 10px; padding-top: 0;` }],\r\n    style: `box-shadow: #00000044 0px 4px 10px;\r\n    backdrop-filter: blur(1px); cursor: initial;\r\n    color: #333; transition: box-shadow 0.3s;\r\n    background: linear-gradient(12deg, #0000001f, #00000010);\r\n    min-width: 100px; max-width: 50vw; width: fit-content;\r\n    border-radius: 10px;` }]\r\n}))\r\n\r\n// graph-edge ===========================================================\r\ncomponent.define('graph-edge', _, df =>\r\n  df('reset', (e, h = e.parent._horizontal, clr = e.parent.color) => {\r\n    const s = 0.6, c = 10\r\n    const a = e.from.position, b = e.to.position\r\n    if (e.from === e.to) {\r\n      const r = 20, r2 = r * 2, x = a[0], y = a[1]\r\n      e._dom.setAttribute('d', `M ${x + r} ${y} m ${r} 0 ` +\r\n        `a ${r},${r} 0 1,0 ${-r2}, 0 a ${r},${r} 0 1,0 ${r2}, 0 ` +\r\n        `M ${x + r2 + c} ${y + c} L ${x + r2} ${y} L ${x + r2 - c} ${y + c}`)\r\n      e._dom.removeAttribute('stroke')\r\n    } else {\r\n      let dx = b[0] - a[0], dy = b[1] - a[1]\r\n      const mx = a[0] + dx * s, my = a[1] + dy * s\r\n      const l = Math.sqrt(dx * dx + dy * dy)\r\n      const ld = 1 / l; dx *= ld, dy *= ld\r\n      const cl = itp3(clr, [256, ...clr.slice(1)], -(h ? dx : dy) + 0.5)\r\n      e._dom.setAttribute('stroke', `rgb(${cl.join(', ')})`)\r\n      if (l < c) {\r\n        e._dom.setAttribute('d', ['M', ...a, 'L', ...b].join(' '))\r\n      } else {\r\n        dx *= c, dy *= c, e._dom.setAttribute('d', ['M', ...a, 'L', ...b,\r\n          'M', mx + dy, my - dx, 'L', mx + dx, my + dy, 'L', mx - dy, my + dx].join(' '))\r\n      }\r\n    } e._dom.removeAttribute('stroke-width')\r\n  }), _ => ({ type: 'path' }))\r\n\r\n// text-editor ==========================================================\r\nconst te_keyfilter = new Set('axcv'.split('').map(n => n + 'ftf').concat(\r\n  'home end pageup pagedown'.split(' ').map(n => n + 'fft')\r\n))\r\ncomponent.define('text-editor', _, df => {\r\n  df('focus', m => m._dom.focus())\r\n  df('blur', m => m._dom.blur())\r\n}, m => ({\r\n  type: 'div', contentEditable: true, jsobj: {\r\n    onkeydown: (e, k = formatkeyevent(e)) => {\r\n      e.stopImmediatePropagation()\r\n      if (k.slice(-3) !== 'fff') {\r\n        if (!te_keyfilter.has(k)) { e.preventDefault() }\r\n      } else if (k === 'tabfff') { e.preventDefault() }\r\n      m.parent.callhotkey(k, e)\r\n    },\r\n    onkeyup: e => (e.stopImmediatePropagation(),\r\n      m.parent.callhotkey(formatkeyevent(e, true), e)),\r\n    onfocus: () => {\r\n      if (m.parent.parent._vnode._dom.lastChild !== m.parent._dom) {\r\n        m.parent.parent._vnode._dom.append(m.parent._dom)\r\n        m._dom.focus()\r\n      } else { m.parent.focus() }\r\n    },\r\n    onblur: () => m.parent.blur(),\r\n  }, class: 'text-editor', style: `outline: none;\r\n    overflow: hidden;\r\n    white-space: pre; overflow-wrap: anywhere;` }))\r\n\r\nconst gstyle = dom('style')\r\ngstyle.innerHTML = `\r\ndiv.text-editor * {\r\n  text-wrap: inherit !important;\r\n}`; root.append(gstyle)\r\n\r\nconst g = component.create('graph', m => m.target_length = 150)\r\ncomponent.root = g\r\n\r\n$.randomgraph = (g, a = 50, b = 100, l = rgrd.rdi(a, b), ns = []) => {\r\n  for (let i = 0; i < l; i++) { ns.push(g.add(component.create('text-editor'))) }\r\n  for (let i = 0; i < l; i++) {\r\n    // const r = rgrd.rd() > 0.8 ? 2 : 1\r\n    // const r = 2\r\n    const r = 1\r\n    const a = ns[i], s = [...ns]\r\n    for (let j = 0; j < r && s.length > 0; j++) {\r\n      g.link(a, s.splice(rgrd.rdi(s.length), 1)[0])\r\n    }\r\n  } rgrd.next()\r\n}\r\n\r\n// const rgrd = grd.genrd(3703646480)\r\nconst rgrd = grd.genrd()\r\n// g.add(component.create('text-editor'))\r\nrandomgraph(g, 50, 100)\r\n// randomgraph(g, 50, 100)\r\n\r\nlet pt = now()\r\n$.frame = () => {\r\n  const t = now(), dt = t - pt; pt = t\r\n  g.frame(dt)\r\n  component.frame()\r\n}"}