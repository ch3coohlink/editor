{"id":"a1604189606e01867be6c39f494a94f41139c427101e061f6ef0c28657a5efbf","to":[],"value":"const now = () => performance.now() / 1000\r\nconst { log, clear } = originconsole\r\nclear()\r\n\r\nconst local = n => globalThis.location.origin + '/' + n\r\nimportScripts(local('external/opentype.js'))\r\n\r\nconst cvs = await requestcanvas()\r\nconst ctx = cvs.getContext('2d', { willReadFrequently: true })\r\nlet devicePixelRatio = await requestdpi()\r\nlet needresize = true\r\non('canvasresize', () => needresize = true)\r\non('canvasresize', ({ w, h, dpi }) => w !== 0 && h !== 0\r\n  ? (cvs.width = w, cvs.height = h, devicePixelRatio = dpi) : 0)\r\n\r\nconst loop = () => {\r\n  $.frame?.()\r\n  requestAnimationFrame(loop)\r\n}; requestAnimationFrame(loop)\r\n\r\nconst fonts = {}\r\nconst loadfont = async (n, p) => {\r\n  let font = await fetch(local(p))\r\n  if (font.status !== 200) { throw Error(`Fail to load font file: ${n} at path: ${p}`) }\r\n  font = opentype.parse(await font.arrayBuffer())\r\n  font.defaultglyph = font.glyphs.glyphs[0], fonts[n] = font\r\n  font.scalefactordiv1 = font.tables.os2.sTypoAscender / 1000\r\n  font.scalefactor = 1 / font.scalefactordiv1\r\n}\r\n\r\nawait Promise.all([\r\n  loadfont('consolas', 'assets/font/consolas.ttf'),\r\n  // loadfont('思源黑体', 'assets/font/SourceHanSansHWSC-Regular.otf'),\r\n])\r\n\r\nconst _segmenter = new Intl.Segmenter(\"en\", { granularity: 'grapheme' })\r\nconst splitunicode = t => Array.from(_segmenter.segment(t), ({ segment }) => segment)\r\nconst drawglyph = g => {\r\n  ctx.beginPath()\r\n  for (const c of g.path.commands) {\r\n    switch (c.type) {\r\n      case 'M': ctx.moveTo(c.x, c.y); break\r\n      case 'L': ctx.lineTo(c.x, c.y); break\r\n      case 'Q': ctx.quadraticCurveTo(c.x1, c.y1, c.x, c.y); break\r\n      case 'C': ctx.bezierCurveTo(c.x1, c.y1, c.x2, c.y2, c.x, c.y); break\r\n      case 'Z': break\r\n      default: log(c); throw Error(`unknown path command type: ${c.type}`)\r\n    }\r\n  }\r\n  ctx.fill()\r\n}\r\nconst defaultglyph = fonts['consolas'].defaultglyph\r\nconst usingfonts = ['consolas', '思源黑体'].map(n => fonts[n]).filter(v => v)\r\nconst drawtext = (t, x, y, px = 10) => {\r\n  const a = splitunicode(t), s = px / 1000\r\n  ctx.save()\r\n  ctx.transform(s, 0, 0, -s, x, y)\r\n  for (const t of a) {\r\n    const c = t.charCodeAt(0); let usefont, g\r\n    for (const f of usingfonts) {\r\n      const i = f.tables.cmap.glyphIndexMap[c]\r\n      g = f.glyphs.glyphs[i]; if (g) { usefont = f; break }\r\n    } if (!g) { g = defaultglyph, usefont = fonts['consolas'] }\r\n    ctx.scale(usefont.scalefactor, usefont.scalefactor)\r\n    drawglyph(g); ctx.translate(g.advanceWidth, 0)\r\n    ctx.scale(usefont.scalefactordiv1, usefont.scalefactordiv1)\r\n  }\r\n  ctx.restore()\r\n}\r\n\r\nconst clearclosure = f => {\r\n  const src = f.toString()\r\n  const i = src.indexOf('=>')\r\n  if (i < 0) { throw Error() }\r\n  let h = src.slice(0, i).trim()\r\n  if (h.startsWith('async')) {\r\n    h = h.slice(5).trimStart()\r\n  } if (h.startsWith('(') && h.endsWith(')')) {\r\n    h = h.slice(1, -1)\r\n  } h = h.split(',')\r\n  return new f.constructor(...h, src.slice(i + 2))\r\n}\r\n\r\nconst component = {\r\n  definition: {},\r\n  sizedirty: new Set,\r\n  dirty: new Set,\r\n  define: (n, m, v, r) => {\r\n    if (component.definition[n]) { throw Error() }\r\n    m.history = [], m.type = n, m._iscomp = true\r\n    component.definition[n] = { m, v, r }\r\n  },\r\n  create: (n, f) => {\r\n    if (!component.definition[n]) { throw Error() }\r\n    const m = structuredClone(component.definition[n].m)\r\n    f?.(m)\r\n    component.dirty.add(m)\r\n    component.sizedirty.add(m)\r\n    return m\r\n  },\r\n  clone: (m, mixin) => {\r\n\r\n  },\r\n  watch: (m) => {\r\n\r\n  },\r\n  transition: async (m, op, ...a) => {\r\n    if (typeof op !== 'function') { throw Error() }\r\n    await (op.noclosure ??= clearclosure(op))(m, ...a)\r\n    m.history.push([op.noclosure, a])\r\n  },\r\n  resize: (m = component.root, size = [cvs.width, cvs.height]) => {\r\n    const { sizedirty } = component\r\n    if (!sizedirty.has(m)) { return }\r\n    m._size = size\r\n    component.definition[m.type].r?.(m)\r\n    sizedirty.delete(m)\r\n  },\r\n  update: () => {\r\n    const { dirty } = component\r\n    const current = [...dirty]\r\n    let c; while (c = current.shift()) {\r\n      if (!dirty.has(c)) { continue }\r\n      let d = component.definition[c.type]\r\n      if (!d) { throw Error() }\r\n      const v = d.v(c)\r\n      component.modelviewmap.set(c, v)\r\n      dirty.delete(c)\r\n    } dirty.clear()\r\n  },\r\n  modelviewmap: new Map,\r\n}\r\n// ----------------------------------------------------------\r\ncomponent.define('space-spliter', {\r\n  direction: 'horizontal',\r\n  barsize: 10,\r\n  children: [],\r\n  childsizes: [],\r\n}, m => {\r\n  log(m._size)\r\n}, m => {\r\n  log(m._size)\r\n  const h = m.direction === 'horizontal'\r\n  const base = (m._size[h ? 0 : 1] - (m.children.length - 1) * m.barsize) / m.children.length\r\n  const nonbase = m._size[h ? 1 : 0]\r\n  let i = 0; for (const c of m.children) {\r\n    const childbase = base * m.childsizes[i++]\r\n    component.resize(c, h ? [childbase, nonbase] : [nonbase, childbase])\r\n  }\r\n})\r\ncomponent.define('code-editor', {\r\n  range: [0, 10],\r\n}, m => {\r\n  log(m._size)\r\n}, m => {\r\n  log(m._size)\r\n})\r\ncomponent.define('resize-text', {\r\n\r\n})\r\ncomponent.define('scroll-list', {\r\n  direction: 'vertical',\r\n  children: [],\r\n  scroll: 0,\r\n}, m => {\r\n  log(m._size)\r\n}, m => {\r\n  log(m._size)\r\n})\r\n// ----------------------------------------------------------\r\ncomponent.root = component.create('space-spliter',\r\n  m => {\r\n    m.children.push(\r\n      component.create('code-editor'),\r\n      component.create('scroll-list'),\r\n      component.create('scroll-list'),\r\n    )\r\n    m.childsizes.push(1.5, 0.75, 0.75)\r\n  })\r\n\r\ncomponent.resize()\r\ncomponent.update()\r\n\r\nlet i = 0\r\n$.frame = () => {\r\n  const cw = cvs.width, ch = cvs.height\r\n  ctx.resetTransform()\r\n  ctx.clearRect(0, 0, cw, ch)\r\n  if (needresize) {\r\n    log('resize')\r\n    needresize = false\r\n  }\r\n}"}