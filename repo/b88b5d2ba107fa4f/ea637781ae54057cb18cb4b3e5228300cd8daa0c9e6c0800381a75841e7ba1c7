{"id":"ea637781ae54057cb18cb4b3e5228300cd8daa0c9e6c0800381a75841e7ba1c7","to":[],"value":"[{\"type\":\"text\",\"value\":\"2024/06/22<div><br><div>终于！经过一个月不间断的开发，我终于完成了这个（大概是）第七版的文学编程工具，如果单纯从编辑器版本迭代的次数来看，整个开发的迭代次数绝对不止七代，但单纯论尝试文学编程的次数的话，我认为这应该算第七次，所以姑且就这样记着数目。</div><div><br><div><div>这一代的核心设计我早在一年之前就已经有了基本的概念，但一直到现在才写出实现，可见对于那些全新的概念，要从捕捉转瞬即逝的念头开始到变为真正可用的工具，其实是一个非常漫长的过程，而作为回报，除了最终的这个工具之外，我觉得这种把概念一点点变为现实的经验也是非常宝贵的。</div></div></div></div>\",\"open\":true,\"name\":\"文学编程实践 VII\"},{\"type\":\"text\",\"value\":\"那么下面开始介绍这款工具的基本概念与使用方法：<div><br><div>首先整个文档是由块构成的，比如现在这个块就是一个文本块，它很简单，只能用来写字。</div></div><div><br></div><div>你可以用右上角的➕按钮创建各种类型的块。</div><div>➖按钮调整块的折叠状态。</div><div>🟰按钮可以拖拽调整块的顺序，而块的顺序在这个工具里有一定的意义，这在后面会提到。</div><div>✖️按钮的作用就是关闭一个块。</div><div><br></div><div>使用Ctrl+s快捷键保存文档。</div><div><br></div><div>下面我将展示其他块的功能：</div>\",\"open\":true,\"name\":\"我是一个文本块（点我修改标题）\"},{\"type\":\"code\",\"links\":[],\"value\":\"// 这是一个代码块\\r\\n// 它可以写代码\\r\\nconst t = '自页面启动经过了：' + performance.now() + '毫秒'\\r\\nroot.innerHTML = t\\r\\nconsole.log(t)\\r\\n// 并且在生成代码块的时候\\r\\n// 它下面总是会附带一个运行块\\r\\n// 点击下面的▶️按钮试试看，它会执行它上方的代码块\\r\\n// ⏹️按钮是清除它中间的内容\\r\\n// 🧾按钮是打开一个用于输出的console\",\"open\":true,\"name\":\"我是一个代码块（点我修改标题）\"},{\"type\":\"exec\",\"value\":\"block above\",\"open\":true},{\"type\":\"text\",\"value\":\"你可能已经发现了，在代码块上按保存键也会启动下面的执行块（这个类型的块总是执行在它上面的第一个代码块或者引用块），利用这个功能可以快速查看代码的执行结果从而提升代码迭代的效率。<div><br></div><div>不过需要注意的是，目前代码是在主线程执行的，也就是说本编辑器和用户的代码其实是运行在同一个线程上，并且由于JavaScript的单线程特性，这意味着如果你写了死循环的话，编辑器也会跟着你的代码一起卡死，后面我们可以使用worker线程解决这个问题，但目前还请注意一下这点。</div><div><br></div><div>下面我们来看一下引用块的功能：</div>\",\"open\":true,\"name\":\"执行块的特点\"},{\"type\":\"ref\",\"line\":[600,610],\"value\":\"99c80241c22153198e9a2405d1cadc21ffc380e849d29d4c50c452097bd3b1f7\",\"open\":true},{\"type\":\"text\",\"value\":\"创建引用块会要求用户选择一个文件节点，并引用对应文件的行（创建出块之后进行编辑）。<div>这里我引用了生成这篇文档的脚本的最后几行。</div><div>你可以修改引用的内容，注意这并不会影响原本的文件内容，你可以使用右上角的🔙按钮重置成文件原本的内容。</div><div>🔝按钮会把窗口大小和位置重置为设置的行范围，但是不会重置你的修改。</div><div>📚按钮可以原样拷贝这个引用节点。</div><div><br></div><div>并且你可以把执行块和引用块结合起来使用，就像这样：</div>\",\"open\":true,\"name\":\"引用块的基本介绍\"},{\"type\":\"ref\",\"line\":[600,610],\"value\":\"99c80241c22153198e9a2405d1cadc21ffc380e849d29d4c50c452097bd3b1f7\",\"open\":true,\"content\":\"const { log } = console\\r\\nconst dom = (t = 'div', opt) => document.createElement(t, opt)\\r\\n\\r\\nconst doceditor = async filepath => {\\r\\n  let data; try {\\r\\n    data = JSON.parse(await readfile(filepath))\\r\\n  } catch { data = [{ type: 'text', value: '' },] }\\r\\n  const block = d => {\\r\\n    const contextmenu = dom()\\r\\n    const pe = dom(), e = dom(); pe.append(e, contextmenu)\\r\\n    contextmenu.style.position = 'absolute'\\r\\n    contextmenu.style.background = 'white'\\r\\n    contextmenu.style.minWidth = '130px'\\r\\n    contextmenu.style.top = '30px'\\r\\n    contextmenu.style.right = '106px'\\r\\n    contextmenu.style.boxShadow = '#00000033 0 2px 4px'\\r\\n    contextmenu.style.zIndex = '1000'\\r\\n    contextmenu.style.overflow = 'hidden'\\r\\n    contextmenu.style.borderBottomLeftRadius = '10px'\\r\\n    contextmenu.style.borderBottomRightRadius = '10px'\\r\\n    contextmenu.style.display = 'flex'\\r\\n    contextmenu.style.flexDirection = 'column'\\r\\n    const openctxmenu = () => {\\r\\n      contextmenu.style.opacity = '1'\\r\\n      contextmenu.style.pointerEvents = 'initial'\\r\\n    }, closectxmenu = () => {\\r\\n      contextmenu.style.opacity = '0'\\r\\n      contextmenu.style.pointerEvents = 'none'\\r\\n    }; closectxmenu()\\r\\n    pe.style.position = 'relative'\\r\\n    pe.style.width = '100%'\\r\\n    e.style.margin = '10px'\\r\\n    e.style.minHeight = '30px'\\r\\n    e.style.overflow = 'hidden'\\r\\n    e.style.borderRadius = '10px'\\r\\n    e.style.boxShadow = '#00000033 0 2px 4px 2px'; {\\r\\n      const resizebar = dom(); pe.append(resizebar)\\r\\n      pe.resizebar = resizebar\\r\\n      const reset = resizebar.reset = () => {\\r\\n        resizebar.style.position = 'absolute'\\r\\n        resizebar.style.background = 'black'\\r\\n        resizebar.style.width = 'calc(100% - 40px)'\\r\\n        resizebar.style.transition = 'opacity 0.1s, height 0.1s, bottom 0.1s'\\r\\n        resizebar.style.height = '10px'\\r\\n        resizebar.style.bottom = '-10px'\\r\\n        resizebar.style.left = '20px'\\r\\n        resizebar.style.cursor = ''\\r\\n        resizebar.style.zIndex = '100'\\r\\n        resizebar.style.opacity = '0'\\r\\n        resizebar.style.userSelect = 'none'\\r\\n        resizebar.style.borderRadius = '10px'\\r\\n      }; reset()\\r\\n      resizebar.addEventListener('pointerenter', () => {\\r\\n        if (!pe.isopen) { return }\\r\\n        resizebar.style.cursor = 'ns-resize'\\r\\n        resizebar.style.opacity = '0.2'\\r\\n        resizebar.style.height = '20px'\\r\\n        resizebar.style.bottom = '-10px'\\r\\n      })\\r\\n      resizebar.addEventListener('pointerleave', reset)\\r\\n      $$.listenpointerdown(resizebar, e => {\\r\\n        const mh = Math.min(userdiv.clientHeight, 100)\\r\\n        const ot = userdiv.style.transition\\r\\n        userdiv.style.transition = ''\\r\\n        const m = e => {\\r\\n          if (!pe.isopen) { return }\\r\\n          const r = userdiv.getBoundingClientRect()\\r\\n          const p = $$.geteventlocation(e)\\r\\n          const h = p.y - r.top\\r\\n          userdiv.style.height = Math.max(h, mh) + 'px'\\r\\n        }; $$.listenpointermove(m); m(e)\\r\\n        $$.listenpointerup(() => {\\r\\n          $$.cancelpointermove(m)\\r\\n          userdiv.style.transition = ot\\r\\n        })\\r\\n      })\\r\\n    } const titlebar = dom(), blockopdiv = dom(), ctn = dom()\\r\\n    titlebar.append(ctn, blockopdiv)\\r\\n    titlebar.style.height = '30px'\\r\\n    titlebar.style.display = 'flex'\\r\\n    titlebar.style.position = 'relative'\\r\\n    titlebar.style.zIndex = '100'\\r\\n    titlebar.style.background = 'white'\\r\\n    titlebar.style.boxShadow = '#00000033 0 0 4px'\\r\\n    titlebar.style.justifyContent = 'space-between'\\r\\n    titlebar.style.userSelect = 'none'\\r\\n    const type = dom('span'), title = dom('span')\\r\\n    type.style.margin = '0 5px'\\r\\n    title.style.marginRight = '5px'\\r\\n    ctn.append(type, title)\\r\\n    ctn.style.padding = '3px'\\r\\n    ctn.style.position = 'relative'\\r\\n    ctn.style.display = 'flex'\\r\\n    ctn.style.alignItems = 'baseline'\\r\\n    const userdiv = dom()\\r\\n    userdiv.style.position = 'relative'\\r\\n    userdiv.style.transition = 'height 0.2s'\\r\\n    e.append(titlebar, userdiv)\\r\\n    const btnbehave = (e, v = 0.9, v2 = 0.8) => (\\r\\n      e.addEventListener('pointerenter', () => e.style.filter = `brightness(${v})`),\\r\\n      e.addEventListener('pointerleave', () => e.style.filter = ''),\\r\\n      e.addEventListener('pointerdown', () => e.style.filter = `brightness(${v2})`),\\r\\n      e.addEventListener('pointerup', () => e.style.filter = `brightness(${v})`))\\r\\n    const btn = (t, i, a = btnlist) => {\\r\\n      const e = dom('span'), last = i === a.length - 1\\r\\n      e.textContent = t\\r\\n      e.style.width = '32px'\\r\\n      e.style.display = 'flex'\\r\\n      e.style.background = 'white'\\r\\n      e.style.justifyContent = 'center'\\r\\n      e.style.alignItems = 'center'\\r\\n      e.style.boxShadow = '#00000033 0.5px 0 4px'\\r\\n      e.style.zIndex = 100 - i\\r\\n      btnbehave(e)\\r\\n      e.addEventListener('pointerenter', () => last ? e.style.background = '#ff9999' : 0)\\r\\n      e.addEventListener('pointerleave', () => last ? e.style.background = 'white' : 0)\\r\\n      return e\\r\\n    }\\r\\n    const btnlist = '➕ ➖ 🟰 ✖️'.split(' ').map(btn)\\r\\n    const ctxlist = ('✂️ file ref,📜 doc snippet,📝 code snippet,' +\\r\\n      ' 💻 exec above,💻 exec file').split(',').map(t => {\\r\\n        const e = dom('span')\\r\\n        e.textContent = t\\r\\n        e.style.width = '100%'\\r\\n        e.style.padding = '5px'\\r\\n        e.style.paddingRight = '10px'\\r\\n        e.style.flexShrink = '0'\\r\\n        e.style.display = 'flex'\\r\\n        e.style.background = 'white'\\r\\n        e.style.justifyContent = 'flex-start'\\r\\n        e.style.alignItems = 'baseline'\\r\\n        e.style.boxShadow = '#00000033 0.5px 0 4px'\\r\\n        btnbehave(e)\\r\\n        e.addEventListener('click', closectxmenu); return e\\r\\n      }); contextmenu.append(...ctxlist)\\r\\n\\r\\n    const copyblock = () => {\\r\\n      const b = block(pe.data), i = blocks.indexOf(pe) + 1\\r\\n      blocks.splice(i, 0, b); $$.dsplice(div, i, 0, b)\\r\\n      return b\\r\\n    }\\r\\n    const addblock = (type, f) => async () => {\\r\\n      const d = { type }; await f(d)\\r\\n      const b = block(d), i = blocks.indexOf(pe) + 1\\r\\n      blocks.splice(i, 0, b); $$.dsplice(div, i, 0, b)\\r\\n    }, pick = async (t = 'file') => {\\r\\n      const id = vcs.nodemap.getr((await vcs.pickonedialog(t)).id)\\r\\n      if (vcs.g[id].type !== t) { throw Error(`Invalid node: not a ${t}.`) }\\r\\n      return id\\r\\n    }\\r\\n    const newaboveexecblock = addblock('exec', d => d.value = 'block above')\\r\\n    const newcodeblock = addblock('code', d => d.links = [])\\r\\n    ctxlist[0].addEventListener('click', addblock('ref',\\r\\n      async d => (d.line = [0, 10], d.value = await pick())))\\r\\n    ctxlist[1].addEventListener('click', addblock('text', d => d.type = 'text'))\\r\\n    ctxlist[2].addEventListener('click', async () => (\\r\\n      await newaboveexecblock(), await newcodeblock()))\\r\\n    ctxlist[3].addEventListener('click', newaboveexecblock)\\r\\n    ctxlist[4].addEventListener('click', addblock('exec',\\r\\n      async d => d.value = await pick()))\\r\\n\\r\\n    let oriht = 0, getdata, toggleblock = () => {\\r\\n      oriht === 0 ? (oriht = userdiv.clientHeight, userdiv.style.height = 0)\\r\\n        : (userdiv.style.height = oriht + 'px', oriht = 0)\\r\\n    }; setTimeout(() => userdiv.style.height = userdiv.clientHeight + 'px')\\r\\n    btnlist[0].onclick = openctxmenu\\r\\n    titlebar.addEventListener('pointerleave', closectxmenu)\\r\\n    contextmenu.addEventListener('pointerenter', openctxmenu)\\r\\n    contextmenu.addEventListener('pointerleave', closectxmenu)\\r\\n    pe.toggleblock = btnlist[1].onclick = toggleblock\\r\\n    $$.listenpointerdown(btnlist[2], e => startdrag(pe, e))\\r\\n    btnlist[3].onclick = () => {\\r\\n      if (blocks.length < 2) { return } pe.remove()\\r\\n      blocks.splice(blocks.indexOf(pe), 1)\\r\\n      if (pe.sandbox) { pe.sandbox.clear() }\\r\\n    }\\r\\n    Object.defineProperty(pe, 'data', {\\r\\n      get: () => { const r = getdata(); r.open = pe.isopen; return r }\\r\\n    })\\r\\n    Object.defineProperty(pe, 'isopen', { get: () => oriht === 0 })\\r\\n    pe.datatype = d.type\\r\\n    if ('open' in d && d.open === false) {\\r\\n      setTimeout(toggleblock, 200)\\r\\n    }\\r\\n    const onenterkey = (d, f = () => { }) => d.addEventListener('keydown',\\r\\n      e => { if (e.key === 'Enter') { e.preventDefault(); d.blur(); f() } })\\r\\n\\r\\n    const vcs = $$.vcs; switch (d.type) {\\r\\n      case 'text': {\\r\\n        type.textContent = '📜'\\r\\n        title.textContent = d.name ?? 'doc snippet'\\r\\n        title.contentEditable = true\\r\\n        const c = dom(); userdiv.append(c)\\r\\n        c.contentEditable = true\\r\\n        c.style.padding = '10px'\\r\\n        c.style.whiteSpace = 'pre-wrap'\\r\\n        c.style.wordWrap = 'break-word'\\r\\n        c.style.boxSizing = 'border-box'\\r\\n        c.style.height = '100%'\\r\\n        c.style.borderBottomLeftRadius = '10px'\\r\\n        c.style.borderBottomRightRadius = '10px'\\r\\n        c.innerHTML = d.value ?? ''\\r\\n        onenterkey(title)\\r\\n        getdata = (r = { ...d, value: c.innerHTML }) => (title.textContent\\r\\n          === 'doc snippet' ? 0 : r.name = title.textContent, r)\\r\\n      } break\\r\\n      case 'ref': {\\r\\n        type.textContent = '✂️'\\r\\n        const te = $$.texteditor()\\r\\n        te.style.height = '100%'\\r\\n        userdiv.style.height = 19 * (d.line[1] - d.line[0] + 1) + 'px'\\r\\n        let file = vcs.g[d.value], path = vcs.getpath(file)\\r\\n        let name = path.slice(-1)[0]\\r\\n        pe.file = { file, path, name, text: () => te.value }\\r\\n        let titletext = 'ref: ' + path.version.id.slice(0, 8) + '/' + name\\r\\n        title.style.cursor = 'pointer'\\r\\n        title.onclick = async () => {\\r\\n          d.value = await pick()\\r\\n          let file = vcs.g[d.value], path = vcs.getpath(file)\\r\\n          let name = path.slice(-1)[0]\\r\\n          pe.file = { file, path, name, text: () => te.value }\\r\\n          titletext = 'ref: ' + path.version.id.slice(0, 8) + '/' + name\\r\\n          naming()\\r\\n        }\\r\\n        te.value = d.content ?? vcs.g[file.value].value\\r\\n        te.change_language('javascript')\\r\\n        te.on('save', () => (naming(), elm.emit('codemod', blocks.indexOf(pe)), save()))\\r\\n        const moded = () => vcs.g[vcs.g[d.value].value].value !== te.value\\r\\n        const naming = () => {\\r\\n          if (moded()) { title.textContent = titletext + '-mod' }\\r\\n          else { title.textContent = titletext }\\r\\n        }; naming()\\r\\n        const linedisplay = dom()\\r\\n        linedisplay.contentEditable = true\\r\\n        linedisplay.textContent = `[${d.line.join(', ')}]`\\r\\n        const updateline = () => {\\r\\n          try {\\r\\n            const a = JSON.parse(linedisplay.textContent), { floor: f } = Math\\r\\n            if (Array.isArray(a) && a.length === 2 && typeof a[0] === 'number'\\r\\n              && typeof a[1] === 'number' && f(a[0]) < f(a[1])) { d.line = a.map(f) }\\r\\n          } catch { } finally { linedisplay.textContent = `[${d.line.join(', ')}]` }\\r\\n          reset()\\r\\n        }\\r\\n        onenterkey(linedisplay, () => updateline())\\r\\n        linedisplay.addEventListener('blur', updateline)\\r\\n        ctn.append(type, title, linedisplay)\\r\\n        const reset = () => {\\r\\n          if (!pe.isopen) { return }\\r\\n          te.editor.revealLinesNearTop(d.line[0] + 5, d.line[1])\\r\\n          te.editor.setPosition({ lineNumber: d.line[0], column: 1000 })\\r\\n          userdiv.style.height = 19 * (d.line[1] - d.line[0] + 1) + 'px'\\r\\n        }; setTimeout(reset, 50); {\\r\\n          const preventscroll = dom()\\r\\n          preventscroll.style.position = 'absolute'\\r\\n          preventscroll.style.top = preventscroll.style.left = '0'\\r\\n          preventscroll.style.width = preventscroll.style.height = '100%'\\r\\n          userdiv.append(te, preventscroll); const focus = e => (e.preventDefault(),\\r\\n            te.focus(), te.editor.focus(), preventscroll.style.pointerEvents = 'none')\\r\\n          preventscroll.addEventListener('pointerdown', focus)\\r\\n          te.addEventListener('blur', () => preventscroll.style.pointerEvents = 'initial')\\r\\n        }\\r\\n        btnlist.unshift(btn('🔙', -1))\\r\\n        btnlist.unshift(btn('🔝', -2))\\r\\n        btnlist.unshift(btn('📚', -3))\\r\\n        btnlist[0].onclick = copyblock\\r\\n        btnlist[1].onclick = reset\\r\\n        btnlist[2].onclick = () =>\\r\\n          (reset(), te.value = vcs.g[vcs.g[d.value].value].value)\\r\\n        getdata = (r = { ...d, line: [...d.line] }) => (moded() ? r.content = te.value : 0, r)\\r\\n      } break\\r\\n      case 'code': {\\r\\n        type.textContent = '📝'\\r\\n        title.contentEditable = true\\r\\n        title.textContent = d.name ?? 'code snippet'\\r\\n        onenterkey(title)\\r\\n        const te = $$.texteditor()\\r\\n        te.change_language('javascript')\\r\\n        te.style.height = '100%'\\r\\n        userdiv.style.height = '200px'\\r\\n        te.value = d.value ?? ''\\r\\n        te.on('save', () => (elm.emit('codemod', blocks.indexOf(pe)), save()))\\r\\n        const linkdiv = dom()\\r\\n        linkdiv.style.display = 'flex'\\r\\n        const linkbtn = (t, i) => {\\r\\n          const e = dom('div'); e.index = i\\r\\n          e.style.fontSize = '10px'\\r\\n          e.style.cursor = 'pointer'\\r\\n          e.style.display = 'flex'\\r\\n          e.style.alignItems = 'center'\\r\\n          e.style.borderRadius = '10px'\\r\\n          e.style.marginRight = '5px'\\r\\n          e.style.paddingRight = '5px'\\r\\n          e.style.background = 'white'\\r\\n          const sme = dom('div')\\r\\n          sme.textContent = vcs.g[t]?.lock ? '🟤' : '🟢'\\r\\n          sme.style.fontSize = '15px'\\r\\n          e.append(e.sme = sme, t.slice(0, 8))\\r\\n          e.addEventListener('pointerdown', ev => {\\r\\n            if (ev.button !== 1) { return } ev.preventDefault()\\r\\n            if (e.index === undefined) { return } e.remove()\\r\\n            d.links.splice(e.index, 1); lbs.splice(e.index, 1)\\r\\n            let j = 0; for (const e of lbs) { e.index = j++ }\\r\\n            linkbtn.innerHTML = '', linkdiv.append(...lbs, addbtn)\\r\\n          })\\r\\n          e.onclick = async () => {\\r\\n            const v = await pick('version')\\r\\n            d.links[i] = v, e.innerHTML = ''\\r\\n            sme.textContent = vcs.g[v]?.lock ? '🟤' : '🟢'\\r\\n            e.append(e.sme = sme, v.slice(0, 8))\\r\\n          }; btnbehave(e); return e\\r\\n        }, lbs = d.links.map(linkbtn)\\r\\n        pe.onverchange = ({ o }) => {\\r\\n          for (let i = 0; i < d.links.length; i++) {\\r\\n            if (d.links[i] === o.id) {\\r\\n              lbs[i].sme.textContent = vcs.g[o.id]?.lock ? '🟤' : '🟢'\\r\\n            }\\r\\n          }\\r\\n        }; vcs.onweak('version lock change', pe.onverchange)\\r\\n        const addbtn = linkbtn('+')\\r\\n        addbtn.innerText = '+'\\r\\n        addbtn.style.padding = '0 5px'\\r\\n        addbtn.onclick = async () => {\\r\\n          const v = await pick('version')\\r\\n          d.links.push(v); lbs.push(linkbtn(v, lbs.length))\\r\\n          linkbtn.innerHTML = '', linkdiv.append(...lbs, addbtn)\\r\\n        }\\r\\n        linkdiv.append(...lbs, addbtn)\\r\\n        ctn.append(linkdiv); {\\r\\n          const preventscroll = dom()\\r\\n          preventscroll.style.position = 'absolute'\\r\\n          preventscroll.style.top = preventscroll.style.left = '0'\\r\\n          preventscroll.style.width = preventscroll.style.height = '100%'\\r\\n          userdiv.append(te, preventscroll); const focus = e => (e.preventDefault(),\\r\\n            te.focus(), te.editor.focus(), preventscroll.style.pointerEvents = 'none')\\r\\n          preventscroll.addEventListener('pointerdown', focus)\\r\\n          te.addEventListener('blur', () => preventscroll.style.pointerEvents = 'initial')\\r\\n        }\\r\\n        btnlist.unshift(btn('📚', -1))\\r\\n        btnlist.unshift(btn('❇️', -2))\\r\\n        btnlist[0].onclick = () => {\\r\\n          const d = pe.data\\r\\n\\r\\n          // TODO: copy and update all link\\r\\n          const b = block(d), i = blocks.indexOf(pe) + 1\\r\\n          blocks.splice(i, 0, b); $$.dsplice(div, i, 0, b)\\r\\n        }\\r\\n        btnlist[1].onclick = copyblock\\r\\n        getdata = (r = { ...d, value: te.value, links: [...d.links] }) => (\\r\\n          title.textContent === 'code snippet' ? 0 : r.name = title.textContent, r)\\r\\n      } break\\r\\n      case 'exec': {\\r\\n        type.textContent = '💻'\\r\\n        userdiv.style.height = '300px'\\r\\n        if (d.value === 'block above') {\\r\\n          pe.oncodemod = $$.debounce(ci => {\\r\\n            const si = blocks.indexOf(pe)\\r\\n            if (ci > si) { return } const t = blocks[si - 1]?.datatype\\r\\n            if (t !== 'ref' && t !== 'code') { return }\\r\\n            if (ci <= si - 1) { sb.exec(); return }\\r\\n            for (let i = si - 2; i > 0; i--) {\\r\\n              if (blocks[i]?.datatype !== 'ref') { return }\\r\\n              if (ci >= i) { sb.exec(); return }\\r\\n            }\\r\\n          })\\r\\n          elm.onweak('codemod', pe.oncodemod)\\r\\n\\r\\n          const getreplace = (r = new Map) => {\\r\\n            const si = blocks.indexOf(pe)\\r\\n            let b = blocks[si - 1], t = b?.datatype\\r\\n            if (t !== 'ref' && t !== 'code') { return r }\\r\\n            if (t === 'ref') { r.set(d.value, b.file.text()) }\\r\\n            for (let i = si - 2; i > 0; i--) {\\r\\n              b = blocks[i], t = b?.datatype\\r\\n              if (t !== 'ref') { return r }\\r\\n              r.set(d.value, b.file.text())\\r\\n            } return r\\r\\n          }\\r\\n          const getfile = () => {\\r\\n            const i = blocks.indexOf(pe), b = blocks[i - 1]\\r\\n            if (!b) { throw Error('No above block') }\\r\\n            const d = b.data; if (d.type === 'code') {\\r\\n              const i = '61788816003b7d997ec97e6c855e' +\\r\\n                '92dd405fd174d7e12171773473c90d7fd4e1'\\r\\n              return ['virtual.js', d.value, i, d.links, getreplace()]\\r\\n            } else if (d.type === 'ref') {\\r\\n              const f = b.file, p = f.path, t = f.text()\\r\\n              return [p.join('/'), t, p.version.id, undefined, getreplace()]\\r\\n            } else { throw Error('Can not exec above block') }\\r\\n          }, sb = $$.sandboxtab(vcs, { type: 'virtual', getfile })\\r\\n          ctn.append(sb.configtab)\\r\\n          pe.sandbox = sb\\r\\n          userdiv.append(sb)\\r\\n          title.textContent = 'exec: above block'\\r\\n        } else {\\r\\n          const file = vcs.g[d.value]\\r\\n          const sb = $$.sandboxtab(vcs, file)\\r\\n          ctn.append(sb.configtab)\\r\\n          userdiv.append(sb)\\r\\n          const name = vcs.getfrom(file).to[file.id].name\\r\\n          const path = vcs.getpath(file)\\r\\n          title.textContent = 'exec: ' + path.version.id.slice(0, 8) + '/' + name\\r\\n          title.style.cursor = 'pointer'\\r\\n          title.onclick = async () => {\\r\\n            d.value = await pick()\\r\\n            const file = vcs.g[d.value]\\r\\n            const name = vcs.getfrom(file).to[file.id].name\\r\\n            const path = vcs.getpath(file)\\r\\n            title.textContent = 'exec: ' + path.version.id.slice(0, 8) + '/' + name\\r\\n            sb.target = file\\r\\n          }\\r\\n        } getdata = () => ({ ...d })\\r\\n      } break;\\r\\n    } blockopdiv.append(...btnlist)\\r\\n    blockopdiv.style.display = 'flex'\\r\\n    return pe\\r\\n  }\\r\\n\\r\\n  const startdrag = (b, e) => {\\r\\n    let i = blocks.indexOf(b)\\r\\n    const obs = []; for (const b of blocks) {\\r\\n      if (b.isopen) { obs.push(b); b.toggleblock() }\\r\\n    } blocks.splice(i, 1), b.remove(), elm.append(b)\\r\\n    b.style.position = 'absolute'\\r\\n    b.style.top = b.style.left = '0px'\\r\\n    b.style.zIndex = '100'\\r\\n    b.style.opacity = '0.5'\\r\\n    const highlight = i => {\\r\\n      if (i === 0) {\\r\\n        topbar.style.background = '#0088ff'\\r\\n        topbar.style.opacity = '0.5'\\r\\n        for (const b of blocks) { b.resizebar.reset() }\\r\\n      } else {\\r\\n        let j = 0; for (const b of blocks) {\\r\\n          if (i - 1 === j) {\\r\\n            b.resizebar.style.background = '#0088ff'\\r\\n            b.resizebar.style.opacity = '0.5'\\r\\n          } else { b.resizebar.reset() } j++\\r\\n        } topbar.reset()\\r\\n      }\\r\\n    }\\r\\n    const m = e => {\\r\\n      const r = div.getBoundingClientRect()\\r\\n      const bsrs = [...div.children].map(e => e.getBoundingClientRect())\\r\\n      const br = b.getBoundingClientRect()\\r\\n      const p = $$.geteventlocation(e)\\r\\n      const y = p.y - br.height / 2\\r\\n      let j = 0; for (const r of bsrs) {\\r\\n        if (y < r.top) { break; } j++\\r\\n      } highlight(i = j)\\r\\n      b.style.top = y - r.top + 'px'\\r\\n    }; $$.listenpointermove(m); m(e)\\r\\n    $$.listenpointerup(() => {\\r\\n      $$.cancelpointermove(m)\\r\\n      b.style.position = 'relative'\\r\\n      b.style.top = b.style.left = ''\\r\\n      b.style.zIndex = ''\\r\\n      b.style.opacity = ''\\r\\n      blocks.splice(i, 0, b)\\r\\n      $$.dsplice(div, i, 0, b)\\r\\n      obs.forEach(b => b.toggleblock())\\r\\n      for (const b of blocks) { b.resizebar.reset() } topbar.reset()\\r\\n      setTimeout(() => {\\r\\n        const h = b.getBoundingClientRect().top -\\r\\n          div.getBoundingClientRect().top\\r\\n        div.scrollTo({ top: h, left: 0, behavior: \\\"smooth\\\" })\\r\\n      }, 200)\\r\\n    })\\r\\n  }\\r\\n\\r\\n  const elm = $$.eventnode(dom())\\r\\n  elm.style.position = 'relative'\\r\\n  elm.style.height = '100%'\\r\\n  elm.style.overflow = 'auto'\\r\\n  const topbar = dom()\\r\\n  topbar.reset = () => {\\r\\n    topbar.style.position = 'absolute'\\r\\n    topbar.style.background = 'black'\\r\\n    topbar.style.width = 'calc(100% - 40px)'\\r\\n    topbar.style.transition = 'opacity 0.1s, height 0.1s, bottom 0.1s'\\r\\n    topbar.style.height = '10px'\\r\\n    topbar.style.top = '0px'\\r\\n    topbar.style.left = '20px'\\r\\n    topbar.style.cursor = ''\\r\\n    topbar.style.zIndex = '100'\\r\\n    topbar.style.opacity = '0'\\r\\n    topbar.style.userSelect = 'none'\\r\\n    topbar.style.borderRadius = '10px'\\r\\n  }; topbar.reset()\\r\\n  const div = dom()\\r\\n  div.style.height = '100%'\\r\\n  div.style.overflow = 'auto'\\r\\n  const blocks = data.map(block)\\r\\n  div.append(...blocks)\\r\\n  elm.append(div, topbar)\\r\\n  root.append(elm)\\r\\n  elm.tabIndex = 1\\r\\n  elm.addEventListener('keydown', e => {\\r\\n    if (e.key === 's' && e.ctrlKey && !e.altKey && !e.shiftKey) {\\r\\n      e.preventDefault(); save()\\r\\n    }\\r\\n  })\\r\\n  const save = () => {\\r\\n    const a = blocks.map(b => b.data)\\r\\n    writefile(filepath, JSON.stringify(a), true)\\r\\n    $$.globalsave()\\r\\n  }\\r\\n  return elm\\r\\n}\\r\\n\\r\\ndoceditor('doc2.json') // 注意这一行的修改\"},{\"type\":\"exec\",\"value\":\"block above\",\"open\":true},{\"type\":\"text\",\"value\":\"启动上面的执行块，你会发现它打开了另一个文档文件，这是通过修改被引用的“打开文档编辑器的脚本“的内容实现的，请注意看我修改的那一行。<div><br><div>值得一提的是，执行块会使用它上方所有的引用块直到它遇到第一个非引用块，因此你可以修改好几个不同的文件并查看它们组合在一起的效果。</div></div>\",\"open\":true,\"name\":\"引用，修改，并执行\"},{\"type\":\"text\",\"value\":\"以上就是我对编辑器基本功能的介绍了，如果有没覆盖到的地方我会在用到的时候提一下，下面我会介绍如何通过文学编程的思维去组织开发流程。\",\"name\":\"基本介绍结束\",\"open\":true},{\"type\":\"text\",\"value\":\"<div><div>文学编程的出发点之一就是要用“文档组织代码”而非“先写代码再添加文档”。</div><div>这种方式的优点在于，用户可以用他们思考的顺序来组织代码，至少理论上是这样的。</div><div><br></div><div>但是实践当中，文档强制了一个线性的结构，这和我们平时编程的逻辑是冲突的，我们总是会在多个文件之间跳转来修改一整个代码库，所以传统的文学编程都会显得很别扭，因为它强制用户使用一个不合适的模型来进行编程。</div></div><div><br></div><div>所以我对文学编程的实践流程做了重大的修改，把编写文档的流程和编写的代码的流程分开，这么说有点抽象，但实际上很简单：平时我们该怎么写代码还是怎么写，但有一个文档工具可以对实际代码库中的代码进行引用，并且把代码的执行功能也集成到文档当中，从而同时获得文学编程流程和传统编程流程的好处。</div>\",\"open\":true,\"name\":\"文学编程简介\"},{\"type\":\"text\",\"value\":\"接下来该写什么好？文学编程鼓励你这样对自己提问，别担心这些内容会影响到阅读文档的人，我很快会让文档工具支持分支结构，你只要确保你的碎碎念不会出现在大部分人的阅读路径上就好了！\",\"open\":true,\"name\":\"思考\"},{\"type\":\"text\",\"value\":\"下面我们来写点实用程序，具体来说，写一个docking system，就是vscode等编辑器里常常出现的，把整个画面分割成几个框，然后可以把编辑器在各个框之间拖动的东西（之所以选择写它是因为现在编辑器的docking system写得很烂，在这里写一个更好的版本之后将其替换到编辑器里去）。<div><br></div><div><div>首先新建一个代码块:</div></div>\",\"open\":true},{\"type\":\"code\",\"links\":[],\"value\":\"// root是执行环境的根dom节点，为了确保整个编辑器能正常运行，你的代码不应该操作它之外的dom节点\\r\\nroot.innerHTML = performance.now()\",\"open\":true},{\"type\":\"text\",\"value\":\"我在之前实现docking system的过程中学到了教训，因此这次的实现有一个总的设计纲领，那就是完全通过js来计算布局，不依赖于嵌套的html结构。<div>这个设计对应的代码结构长这样：</div>\",\"open\":true},{\"type\":\"code\",\"links\":[],\"value\":\"const data = [] // 我们把描述窗口的数据放在这里\\r\\nconst layout = data => {\\r\\n  root.innerHTML = ''\\r\\n  // 首先清空root节点，然后根据data进行布局\\r\\n}\\r\\nlayout(data)\\r\\n\\r\\n// 监听root节点的大小变化，并重新布局\\r\\nconst ro = new ResizeObserver(() => layout(data))\\r\\nro.observe(root)\",\"open\":true},{\"type\":\"text\",\"value\":\"那么现在的重点是设计数据结构来描述所有的窗口，我尝试了如下设计：\",\"open\":true},{\"type\":\"code\",\"links\":[],\"value\":\"const _ = undefined\\r\\nconst arrobj = (t, o = {}, ...a) => (a.type = t, Object.assign(a, o), a)\\r\\nconst data = arrobj('container', { direction: 'row' },\\r\\n  arrobj('docker', _,\\r\\n    { type: 'tab', content: 'a' },\\r\\n    { type: 'tab', content: 'b' }),\\r\\n  arrobj('container', { direction: 'column' },\\r\\n    arrobj('docker', _, { type: 'tab', content: 'c' }),\\r\\n    arrobj('docker', _, { type: 'tab', content: 'd' }),\\r\\n  ),\\r\\n)\\r\\nconsole.log(data)\",\"open\":true},{\"type\":\"text\",\"value\":\"上面的数据结构描述是静态的，让我们按这个设计生成一些随机数据。\",\"name\":\"也许试试随机生成？\",\"open\":true},{\"type\":\"code\",\"links\":[\"eb65e183d886a11d5b5ad6ac89c1708e4634013a0373ee57c25dece51d0d3197\"],\"value\":\"const { rd, rdi, uuid } = await require('0/random.js')\\r\\nconst arrobj = (t, o = {}, ...a) => (a.type = t, Object.assign(a, o), a)\\r\\nconst rdir = () => rd() > 0.5 ? 'row' : 'column'\\r\\nconst data = arrobj('container', { direction: rdir() })\\r\\nconst layer = (data, d) => {\\r\\n  if (!(d > 0)) { return data }\\r\\n  for (let i = 0, l = rdi(1, 5); i < l; i++) {\\r\\n    const r = rd();\\r\\n    if (data.type === 'docker') {\\r\\n      data.push({ type: 'tab', content: uuid() })\\r\\n    } else if (data.type === 'container') {\\r\\n      if (r < 0.5) {\\r\\n        data.push(layer(arrobj('container', { direction: rdir() }), d - 1))\\r\\n      } else {\\r\\n        const o = arrobj('docker', {})\\r\\n        if (d === 1) { o.push({ type: 'tab', content: uuid() }) }\\r\\n        else { layer(o, d - 1) } data.push(o)\\r\\n      }\\r\\n    }\\r\\n  } return data\\r\\n}\\r\\nconst tostring = (d, i = 0) => {\\r\\n  const t = '|-'.repeat(i)\\r\\n  if (!d) { return t + 'undefined' }\\r\\n  switch (d.type) {\\r\\n    case 'container': return t + 'ctn ' + d.direction + '\\\\n'\\r\\n      + d.map(v => tostring(v, i + 1)).join('')\\r\\n    case 'docker': return t + 'docker\\\\n' + d.map(v => tostring(v, i + 1)).join('')\\r\\n    case 'tab': return t + 'tab ' + d.content + '\\\\n'\\r\\n  }\\r\\n}\\r\\nconst d = layer(data, 3)\\r\\nconsole.log(d)\\r\\nconsole.log(tostring(d))\",\"open\":true,\"name\":\"创建随机数据\"},{\"type\":\"exec\",\"value\":\"block above\",\"open\":false},{\"type\":\"text\",\"value\":\"现在我们有了创建随机数据的函数，将它创建为一个文件并稍作修改（使其可以导出函数），引用如下：\",\"open\":true,\"name\":\"将编写出来的demo转化为代码库\"},{\"type\":\"ref\",\"line\":[29,40],\"value\":\"1f331cf75000c51ac15be3927fe50ab714f0615d1977ab150b41cd2fc285a378\",\"open\":true},{\"type\":\"code\",\"links\":[\"a8d3d420f154d8b840408b5968f56ea75f37a06ec739db8316c47f3f71d895aa\"],\"value\":\"console.clear()\\r\\nconst gendd = await require('0/gen_docking_data.js')\\r\\nconsole.log(gendd.tostring(gendd.layer(4)))\",\"open\":true,\"name\":\"测试上面的引用\"},{\"type\":\"exec\",\"value\":\"block above\",\"open\":true},{\"type\":\"text\",\"value\":\"上面这种通过编写简单demo来实现功能，并将其固化到实际代码库中去的流程，是文学编程的一种核心模式\",\"name\":\"recap：demo驱动的编程\",\"open\":true},{\"type\":\"text\",\"value\":\"那么下面我们就来把数据渲染为实际的DOM结构：\",\"name\":\"继续\",\"open\":true},{\"type\":\"code\",\"links\":[\"a8d3d420f154d8b840408b5968f56ea75f37a06ec739db8316c47f3f71d895aa\"],\"value\":\"console.clear()\\r\\nconst gendd = await require('0/gen_docking_data.js')\\r\\nconst data = gendd.layer(4)\\r\\nconsole.log(gendd.tostring(data))\\r\\nconst layout = data => {\\r\\n  root.innerHTML = ''\\r\\n}; layout(data)\\r\\nconst ro = new ResizeObserver(() => layout(data))\\r\\nro.observe(root)\",\"open\":true},{\"type\":\"exec\",\"value\":\"block above\",\"open\":true},{\"type\":\"text\",\"value\":\"<div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div>你猜到我会在这里写点东西了？</div>\",\"name\":\"这个文档块只是用来空出滚动距离\",\"open\":true}]"}