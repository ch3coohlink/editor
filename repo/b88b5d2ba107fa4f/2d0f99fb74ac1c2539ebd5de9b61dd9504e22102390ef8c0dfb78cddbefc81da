{"id":"2d0f99fb74ac1c2539ebd5de9b61dd9504e22102390ef8c0dfb78cddbefc81da","to":[],"value":"const solvepath = (b, p) => b + (\r\n  p.startsWith('/') || b === '' || b.endsWith('/') ? '' : '/') + p\r\n\r\nlet i = 0, waitload = new Map\r\nconst call = f => (...a) => {\r\n  let rj, j, p = new Promise((...a) => [, j] = rj = a)\r\n    .finally(() => (clearTimeout(h), waitload.delete(id)))\r\n  const id = i++; send('$function$' + f, (a.id = id, a))\r\n  const h = setTimeout(() => j(a), 5000)\r\n  waitload.set(id, rj); return p\r\n}\r\nconst callvoid = f => (...a) =>\r\n  send('$function$' + f, a)\r\n\r\nconst _log = callvoid('console.log')\r\nconst _error = callvoid('console.error')\r\nconst _clear = callvoid('console.clear')\r\nglobalThis.originconsole = console\r\nglobalThis.console = { log: _log, error: _error, clear: _clear }\r\n\r\nconst load = call('$.__sandbox__.load')\r\nconst write = call('$.__sandbox__.write')\r\nconst loadtext = (...a) => load(...a, true)\r\nglobalThis.readfile = call('readfile')\r\nglobalThis.writefile = call('writefile')\r\nglobalThis.__require = (v, b, fst) => async (ph, p = solvepath(b, ph)) => {\r\n  const data = await load(v, p, fst, { watch: true }), file = data.id\r\n  if (loaded.has(file)) { return loaded.get(file) }\r\n  const ex = await exec(...data); loaded.set(file, ex); return ex\r\n}\r\nglobalThis.requestcanvas = call('requestcanvas')\r\noriginconsole.log(requestcanvas)\r\n\r\nconst loaded = new Map, AF = (async () => { }).constructor\r\nconst exec = (ver, path, src, first = false) => new AF('$',\r\n  `//# sourceURL=${ver.slice(0, 16) + '/' + path}\\nconst __repoid = '${ver}'\\n` +\r\n  `const __dirname = '${path.split('/').slice(0, -1).join('/')}'\\n` +\r\n  `const require = __require(__repoid, __dirname, ${first})\\n` +\r\n  `with($) {\\n${src}\\n}\\n return $`)({})\r\n\r\nconst send = (t, o = {}, ...a) => {\r\n  if (Array.isArray(o)) { o = { a: o, isarr: true } }\r\n  postMessage((o.type = t, o), a)\r\n}\r\naddEventListener('message', e => {\r\n  let o = e.data\r\n  if (o.isarr) { o.a.type = o.type; o = o.a }\r\n  if (o.type === 'init') { exec(...o, true) }\r\n  else if (o.type === 'callfin') {\r\n    if (waitload.has(o.id)) {\r\n      waitload.get(o.id)[0](o.r)\r\n    }\r\n  } else if (o.type === 'error') {\r\n    if (waitload.has(o.id)) {\r\n      waitload.get(o.id)[1](o.error)\r\n    } _error(o.error)\r\n  }\r\n})\r\nsetInterval(() => send('heartbeat'), 500)\r\n// addEventListener('error', _error)"}